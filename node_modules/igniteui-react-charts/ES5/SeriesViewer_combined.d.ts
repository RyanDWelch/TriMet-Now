import { Control } from "igniteui-react-core/ES5/Control";
import { INotifyPropertyChanged, Type, Base, Point, EventArgs, PropertyChangedEventArgs, IEnumerable, IEnumerable$1, IList$1 } from "igniteui-react-core/ES5/type";
import { ILegendOwner } from "igniteui-react-core/ES5/ILegendOwner";
import { IInternalLegendOwner } from "igniteui-react-core/ES5/IInternalLegendOwner";
import { ISeriesViewerWidget } from "./ISeriesViewerWidget";
import { SRProvider } from "igniteui-react-core/ES5/SRProvider";
import { DoubleAnimator } from "igniteui-react-core/ES5/DoubleAnimator";
import { IChartLegend } from "igniteui-react-core/ES5/IChartLegend";
import { DependencyProperty } from "igniteui-react-core/ES5/DependencyProperty";
import { DependencyObject } from "igniteui-react-core/ES5/DependencyObject";
import { Rect } from "igniteui-react-core/ES5/Rect";
import { ChartHitTestMode } from "./ChartHitTestMode";
import { InteractionState } from "igniteui-react-core/ES5/InteractionState";
import { WindowResponse } from "./WindowResponse";
import { Visibility } from "igniteui-react-core/ES5/Visibility";
import { IOverviewPlusDetailPane } from "igniteui-react-core/ES5/IOverviewPlusDetailPane";
import { SeriesViewerComponentsFromView } from "./SeriesViewerComponentsFromView";
import { Brush } from "igniteui-react-core/ES5/Brush";
import { ModifierKeys } from "igniteui-react-core/ES5/ModifierKeys";
import { DataTemplate } from "igniteui-react-core/ES5/DataTemplate";
import { HorizontalAlignment } from "igniteui-react-core/ES5/HorizontalAlignment";
import { CanvasRenderScheduler } from "igniteui-react-core/ES5/CanvasRenderScheduler";
import { SyncSettings } from "./SyncSettings";
import { CultureInfo } from "igniteui-react-core/ES5/culture";
import { SeriesViewerComponentsForView } from "./SeriesViewerComponentsForView";
import { Dictionary$2 } from "igniteui-react-core/ES5/Dictionary$2";
import { PropertyUpdatedEventArgs } from "igniteui-react-core/ES5/PropertyUpdatedEventArgs";
import { NotifyCollectionChangedEventArgs } from "igniteui-react-core/ES5/NotifyCollectionChangedEventArgs";
import { ObservableCollection$1 } from "igniteui-react-core/ES5/ObservableCollection$1";
import { Size } from "igniteui-react-core/ES5/Size";
import { List$1 } from "igniteui-react-core/ES5/List$1";
import { FrameworkElement } from "igniteui-react-core/ES5/FrameworkElement";
import { MouseEventArgs } from "igniteui-react-core/ES5/MouseEventArgs";
import { MouseButtonEventArgs } from "igniteui-react-core/ES5/MouseButtonEventArgs";
import { Key } from "igniteui-react-core/ES5/Key";
import { EventProxy } from "igniteui-react-core/ES5/EventProxy";
import { RectChangedEventArgs } from "igniteui-react-core/ES5/RectChangedEventArgs";
import { Thickness } from "igniteui-react-core/ES5/Thickness";
import { AxisTitlePosition } from "./AxisTitlePosition";
import { FontInfo } from "igniteui-react-core/ES5/FontInfo";
import { IFastItemsSource } from "igniteui-react-core/ES5/IFastItemsSource";
import { CoercionInfo } from "./CoercionInfo";
import { ChartContentType } from "./ChartContentType";
import { ISchedulableRender } from "igniteui-react-core/ES5/ISchedulableRender";
import { Rectangle } from "igniteui-react-core/ES5/Rectangle";
import { Path } from "igniteui-react-core/ES5/Path";
import { Line } from "igniteui-react-core/ES5/Line";
import { RenderingContext } from "igniteui-react-core/ES5/RenderingContext";
import { TextBlock } from "igniteui-react-core/ES5/TextBlock";
import { ITileZoomTile } from "./ITileZoomTile";
import { RenderSurface } from "./RenderSurface";
import { PathGeometry } from "igniteui-react-core/ES5/PathGeometry";
import { Geometry } from "igniteui-react-core/ES5/Geometry";
import { DataContext } from "igniteui-react-core/ES5/DataContext";
import { LabelPanelsArrangeState } from "./LabelPanelsArrangeState";
import { AxisLabelsLocation } from "./AxisLabelsLocation";
import { IProvidesViewport } from "./IProvidesViewport";
import { DomRenderer, DomWrapper } from "igniteui-react-core/ES5/dom";
import { PointerTooltipStyle } from "./PointerTooltipStyle";
import { BrushCollection } from "igniteui-react-core/ES5/BrushCollection";
import { DefaultPaletteInfo } from "./DefaultPaletteInfo";
import { AxisRange } from "./AxisRange";
import { AxisAnnotationCollection } from "./AxisAnnotationCollection";
import { VerticalAlignment } from "igniteui-react-core/ES5/VerticalAlignment";
import { Canvas } from "igniteui-react-core/ES5/Canvas";
import { IFastItemsSourceProvider } from "igniteui-react-core/ES5/IFastItemsSourceProvider";
import { AxisExtentType } from "./AxisExtentType";
import { DoubleCollection } from "igniteui-react-core/ES5/DoubleCollection";
import { LabelPosition } from "./LabelPosition";
import { LabelFontHeuristics } from "./LabelFontHeuristics";
import { AxisOrientation } from "./AxisOrientation";
import { Pool$1 } from "igniteui-react-core/ES5/Pool$1";
import { AxisComponentsFromView } from "./AxisComponentsFromView";
import { AxisRangeChangedEventArgs } from "./AxisRangeChangedEventArgs";
import { GeometryCollection } from "igniteui-react-core/ES5/GeometryCollection";
import { PathRenderingInfo } from "./PathRenderingInfo";
import { RenderRequestedEventArgs } from "./RenderRequestedEventArgs";
import { ScalerParams } from "./ScalerParams";
import { CategoryMode } from "./CategoryMode";
import { GridMode } from "./GridMode";
import { Panel } from "igniteui-react-core/ES5/Panel";
import { UIElement } from "igniteui-react-core/ES5/UIElement";
import { TickmarkValues } from "./TickmarkValues";
import { ICategoryScaler } from "./ICategoryScaler";
import { FastItemsSourceEventArgs } from "igniteui-react-core/ES5/FastItemsSourceEventArgs";
import { FastItemsSourceEventAction } from "igniteui-react-core/ES5/FastItemsSourceEventAction";
import { NumericAxisRenderingParameters } from "./NumericAxisRenderingParameters";
import { AxisRenderingParametersBase } from "./AxisRenderingParametersBase";
import { HighlightingState } from "./HighlightingState";
import { Marker } from "./Marker";
import { Polyline } from "igniteui-react-core/ES5/Polyline";
import { ContentControl } from "igniteui-react-core/ES5/ContentControl";
import { Polygon } from "igniteui-react-core/ES5/Polygon";
import { ILegendSeries } from "igniteui-react-core/ES5/ILegendSeries";
import { ILegendTemplateProvider } from "igniteui-react-core/ES5/ILegendTemplateProvider";
import { StandardLegendItems } from "igniteui-react-core/ES5/StandardLegendItems";
import { StandardLegendBadges } from "igniteui-react-core/ES5/StandardLegendBadges";
import { PenLineCap } from "igniteui-react-core/ES5/PenLineCap";
import { Color } from "igniteui-react-core/ES5/Color";
import { TransitionInSpeedType } from "./TransitionInSpeedType";
import { SeriesHitTestMode } from "./SeriesHitTestMode";
import { SeriesComponentsForView } from "./SeriesComponentsForView";
import { SeriesPointOfInterest } from "./SeriesPointOfInterest";
import { SeriesComponentsFromView } from "./SeriesComponentsFromView";
import { IFastItemColumn$1 } from "igniteui-react-core/ES5/IFastItemColumn$1";
import { ISortingAxis } from "./ISortingAxis";
import { MarkerType } from "./MarkerType";
import { Style } from "igniteui-react-core/ES5/Style";
import { HashPool$2 } from "igniteui-react-core/ES5/HashPool$2";
/**
 * @hidden
 */
export declare abstract class SeriesViewer extends Control implements INotifyPropertyChanged, ILegendOwner, IInternalLegendOwner {
    static $t: Type;
    private _widget;
    widget: ISeriesViewerWidget;
    bn: SeriesViewerView;
    static staticInit(): void;
    private by;
    private readonly bz;
    private a0;
    readonly a1: ISeriesViewerInteractionManager;
    readonly cv: boolean;
    constructor();
    private bh;
    hq(): void;
    private i9;
    hr(): void;
    readonly series: SeriesCollection;
    private a3;
    private j2;
    private _skipDataCleanup;
    skipDataCleanup: boolean;
    protected jw(a: any): void;
    private j3;
    hu(a: number, b: number, c: boolean, d: boolean): {
        p0?: number;
        p1?: number;
    };
    cl(): boolean;
    protected readonly cs: boolean;
    readonly az: IHighlightingManager;
    bo: DoubleAnimator;
    private hp;
    ke(a: number): void;
    ho(): void;
    l6(a: number): Brush;
    mc(a: number): Brush;
    ma(a: number): Brush;
    mb(a: number): Brush;
    al: ChartContentManager;
    mi: Point;
    private mh;
    readonly cu: boolean;
    legend: IChartLegend;
    static readonly la: DependencyProperty;
    cd: boolean;
    static readonly kz: DependencyProperty;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected jh(a: string, b: any, c: any): void;
    ii(): void;
    ij(a: IEnumerable): void;
    it(a: Series, b: any, c: any): void;
    ix(a: Series, b: any, c: any): void;
    iu(a: Series, b: any, c: any): void;
    iv(a: Series, b: any, c: any): void;
    iw(a: Series, b: any, c: any): void;
    iy(a: Series, b: any, c: any): void;
    iz(a: Series, b: any, c: any): void;
    seriesCursorMouseMove: (sender: any, e: ChartCursorEventArgs) => void;
    jk(a: Series, b: any): void;
    seriesMouseLeftButtonDown: (sender: any, e: DataChartMouseButtonEventArgs) => void;
    jo(a: Series, b: any, c: MouseButtonEventArgs): void;
    seriesMouseLeftButtonUp: (sender: any, e: DataChartMouseButtonEventArgs) => void;
    jp(a: Series, b: any, c: MouseButtonEventArgs): void;
    seriesMouseMove: (sender: any, e: ChartMouseEventArgs) => void;
    jq(a: Series, b: any, c: MouseEventArgs): void;
    seriesMouseEnter: (sender: any, e: ChartMouseEventArgs) => void;
    jm(a: Series, b: any, c: MouseEventArgs): void;
    seriesMouseLeave: (sender: any, e: ChartMouseEventArgs) => void;
    jn(a: Series, b: any, c: MouseEventArgs): void;
    private mp;
    protected get_m3(): Rect;
    readonly m3: Rect;
    private mn;
    mu: Rect;
    my(a: Rect, b: Rect, c: Rect): Rect;
    private b1;
    private mm;
    protected get_mt(): Rect;
    readonly mt: Rect;
    mw(a: Rect, b: Rect, c: Rect): Rect;
    protected ms(a: Rect): Rect;
    mx(): Rect;
    protected ka(a: Axis): void;
    m4: Rect;
    dj: boolean;
    cb: boolean;
    db: boolean;
    e6: number;
    private ez;
    e2: number;
    e5: number;
    jc(a: Rect, b: Rect): void;
    private a5;
    a6(): SeriesViewerComponentsForView;
    cy: boolean;
    private an;
    ap: ChartHitTestMode;
    js(): void;
    protected aq(): ChartHitTestMode;
    private am;
    ao: ChartHitTestMode;
    cz: boolean;
    seriesAnimating: (series: Series) => void;
    jj(a: Series): void;
    abstract c3(): boolean;
    abstract c4(): boolean;
    c2(): boolean;
    h9(): void;
    h4(): void;
    bg: InteractionState;
    private b3;
    private bf;
    il(a: Point): void;
    im(a: Point): void;
    c9(a: Point, b: number): boolean;
    ia(a: Point): void;
    c8(a: Key): boolean;
    private b7;
    ch: boolean;
    private b2;
    ce: boolean;
    protected get_cw(): boolean;
    readonly cw: boolean;
    ic(a: Point): void;
    readonly ck: boolean;
    g0: string;
    ir(a: Point): void;
    id(a: Point, b: boolean): void;
    ib(a: Point): void;
    da: boolean;
    private i7;
    iq(a: Point): void;
    i8(a: Point, b: number, c: number, d: number): void;
    ip(a: number): void;
    i4(a: Point, b: number, c: number, d: number): void;
    ik(a: Point): void;
    io(a: number): void;
    ie(a: Point): void;
    i3(a: Point, b: number, c: number, d: number): void;
    ih(a: Size): void;
    hn(): void;
    h7(a: Point, b: boolean): void;
    bd(a: boolean): InteractionState;
    i6(): void;
    i5(): void;
    j7(): void;
    hj(): void;
    he(): void;
    hd(): void;
    ja(): void;
    jv(): void;
    jt(): void;
    h6(a: Point, b: boolean): void;
    private b8;
    df: boolean;
    h5(a: Point, b: boolean): void;
    kj(a: any, b: PropertyUpdatedEventArgs): void;
    ki(a: SyncLink, b: SyncLink): void;
    hf(a: Point): void;
    kl(a: Rect, b: boolean): void;
    km(a: Rect, b: boolean, c: boolean): void;
    jb(a: Rect, b: boolean): void;
    readonly c0: boolean;
    private _dm;
    dm(): IEnumerable$1<SeriesViewer>;
    mk(a: Point): Point;
    m2(a: Rect): Rect;
    windowRectChanged: (sender: any, e: RectChangedEventArgs) => void;
    private jr;
    i2(a: Rect, b: Rect): void;
    sizeChanged: (sender: any, e: RectChangedEventArgs) => void;
    i0(a: Size, b: Size): void;
    cn: boolean;
    dc(a: Rect, b: Rect): boolean;
    actualWindowRectChanged: (sender: any, e: RectChangedEventArgs) => void;
    private jf;
    j1(): void;
    gridAreaRectChanged: (sender: any, e: RectChangedEventArgs) => void;
    private jg;
    protected get_cx(): boolean;
    readonly cx: boolean;
    is(a: Rect, b: Rect): void;
    ba: WindowResponse;
    cj: boolean;
    ex: number;
    private _syncChannel;
    syncChannel: string;
    private a7;
    actualSyncLink: SyncLink;
    ht(): void;
    m8: Visibility;
    readonly bi: IOverviewPlusDetailPane;
    protected kf(a: boolean): void;
    m7: Visibility;
    cm: boolean;
    di: boolean;
    me: Brush;
    l4: Brush;
    md: Brush;
    cg(): boolean;
    cc(): boolean;
    private e1;
    private notifyCrosshairUpdate;
    protected kk(a: number, b: number): void;
    eg(): number;
    eh(): number;
    protected jd(a: any, b: string, c: any, d: any): void;
    kh(): void;
    protected h3(): void;
    kg(): void;
    private b9;
    protected dg: boolean;
    bc: InteractionState;
    be: InteractionState;
    l0: ModifierKeys;
    l1: ModifierKeys;
    private mo;
    mz: Rect;
    dn: Date;
    dk: boolean;
    protected j9(): void;
    g9(): void;
    ev: number;
    ew: number;
    private m1;
    refreshCompleted: (sender: any, e: EventArgs) => void;
    ji(): void;
    protected abstract bm(): SeriesViewerView;
    protected i1(a: SeriesViewerView): void;
    static m0: Rect;
    kn: DataTemplate;
    kw: DataTemplate;
    kt: DataTemplate;
    ku: DataTemplate;
    ko: DataTemplate;
    kr: DataTemplate;
    kp: DataTemplate;
    kv: DataTemplate;
    ks: DataTemplate;
    kq: DataTemplate;
    gq: string;
    lz: HorizontalAlignment;
    ly: HorizontalAlignment;
    private fb;
    gx: string;
    private fa;
    gl: string;
    private l3;
    mg: Brush;
    private l2;
    mf: Brush;
    private d7;
    et: number;
    private d5;
    er: number;
    private d6;
    es: number;
    private d4;
    eq: number;
    private d3;
    ep: number;
    private d1;
    en: number;
    private d2;
    eo: number;
    private d0;
    em: number;
    ge: string;
    m5(): Thickness;
    m6(): Thickness;
    aj(a: Axis): AxisTitlePosition;
    ak(a: Axis): AxisTitlePosition;
    abstract getFontInfo(): FontInfo;
    getFontHeight(): number;
    abstract getFontBrush(): Brush;
    abstract l5(): Brush;
    e8: any;
    provideContainer(a: any): void;
    h8(a: number, b: number): void;
    notifyContainerResized(): void;
    mv(): Rect;
    hk(): void;
    mj(): Point;
    bq(): FontInfo;
    bp(): FontInfo;
    l7(): Brush;
    l8(): Brush;
    hb(a: Series): void;
    jx(a: Series): void;
    ah: CanvasRenderScheduler;
    ai: CanvasRenderScheduler;
    ag: CanvasRenderScheduler;
    private b6;
    c7: boolean;
    private b0;
    ca: boolean;
    private _syncSettings;
    syncSettings: SyncSettings;
    ha(a: any): void;
    jz(a: any): void;
    h0(source_: any, a: number, b: any, c: any): void;
    hv(source_: any): void;
    hy(source_: any, a: number, b: any): void;
    hz(source_: any, a: number, b: any): void;
    destroyed: boolean;
    protected e7: any;
    protected dl: Dictionary$2<string, any>;
    c6: boolean;
    destroy(): void;
    protected hi(): void;
    j6(source_: any): void;
    j0(): void;
    j5(a: string, source_: any): void;
    jy(a: string, b: boolean): void;
    protected j4(a: Series, b: any): void;
    protected kc(a: any): void;
    protected kd(): void;
    private d8;
    eu: number;
    private dx;
    ej: number;
    private dz;
    el: number;
    private dv;
    ef: number;
    private du;
    ee: number;
    private dt;
    ed: number;
    dd(): boolean;
    private b4;
    cp: boolean;
    private dy;
    ek: number;
    private dw;
    ei: number;
    static bb(a: string, b: any): CoercionInfo;
    private e9;
    f1: string;
    private dq;
    ea: number;
    private dp;
    d9: number;
    private ml;
    mq: Rect;
    private hs;
    protected mr(): Rect;
    private dr;
    eb: number;
    private ds;
    ec: number;
    h2(): void;
    h1(): void;
    flush(): void;
    hm(a: boolean, b: boolean): void;
    dh(): boolean;
    private kx;
    private ar;
    protected ju(a: DependencyObject, b: (arg1: boolean) => void): void;
    protected j8(a: DependencyObject): void;
    hg(): void;
    cq: boolean;
    cr: boolean;
    co: boolean;
    ig(): void;
    private b5;
    readonly c1: boolean;
    hc(): void;
    c5(): boolean;
    private e0;
    e4(): number;
    bt(): FontInfo;
    bs(): FontInfo;
    kb(): void;
    protected cf: boolean;
    ct: boolean;
    seriesDataUpdated: (sender: any, e: EventArgs) => void;
    jl(): void;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class SeriesViewerView extends Base implements ISchedulableRender {
    static $t: Type;
    constructor(a: SeriesViewer);
    ch(): void;
    n: SeriesViewer;
    cv(): void;
    private cg;
    a: CanvasRenderScheduler;
    l: IOverviewPlusDetailPane;
    private dd;
    private dc;
    ec(): void;
    private cm;
    private cl;
    m: OverviewPlusDetailViewportHost;
    b4(a: number, b: number, c: RenderSurface): void;
    dv(): void;
    b6(): void;
    dx(): void;
    cd(): void;
    b5(): void;
    b7(): void;
    dn(a: Series): void;
    c2(): void;
    ao(a: Series): boolean;
    protected f: SeriesCollection;
    protected b: AxisCollection;
    private ag;
    as: boolean;
    bm(a: Series): void;
    di(a: RenderingContext): void;
    bu(): void;
    bq(): void;
    b8(): void;
    b3(): void;
    dg(): void;
    protected e5: Rectangle;
    protected e4: Path;
    dy(): void;
    d6(a: Rect): void;
    bt(): void;
    c5(): void;
    ee(a: number, b: number, c: number, d: number): void;
    protected e3: Line;
    protected e2: Line;
    d3(): void;
    ce(): void;
    d7(a: number, b: number, c: number, d: number): void;
    dz(): void;
    b9(): void;
    cc(): void;
    private ev;
    private ew;
    ed(a: Rect, b: Rect): void;
    d2(): void;
    ef(a: Rect): void;
    dl(a: Axis): void;
    dm(a: Axis): void;
    bl(a: Axis): void;
    bi(a: Axis): void;
    private g;
    h(): SeriesViewerComponentsFromView;
    static au(a: Series): List$1<Series>;
    ds(): void;
    i: SeriesViewerViewManager;
    protected u: RenderingContext;
    x: RenderingContext;
    w: RenderingContext;
    protected v: RenderingContext;
    al: boolean;
    am: boolean;
    protected bg: any;
    cs(a: any): void;
    private aj;
    protected cq(a: Point, b: boolean): void;
    protected cr(a: Point, b: boolean): void;
    protected cu(a: Point): void;
    protected cp(a: Point, b: boolean): void;
    dj(a: RenderingContext): void;
    protected get_an(): boolean;
    readonly an: boolean;
    j: EventProxy;
    d5(): void;
    a7: number;
    e(a: Point, b: boolean, c: DataContext, d: boolean): {
        ret: Series;
        p2: DataContext;
    };
    bb(): number;
    ba(): number;
    a6: number;
    a5: number;
    private ey;
    private ah;
    cn(): void;
    ct(a: number, b: number): void;
    dt(): void;
    private az;
    private ax;
    private ay;
    private aw;
    private ai;
    private y;
    private bz;
    private ea;
    t(): FontInfo;
    s(): FontInfo;
    private eu;
    private et;
    private bd;
    private a0;
    private bc;
    e9(): Thickness;
    e8(): Thickness;
    protected dk(a: Rect): void;
    cj(): void;
    private ez;
    protected dq(): void;
    isValid(): boolean;
    preRender(): void;
    protected dh(): void;
    protected z: boolean;
    protected dr(): void;
    e0(): Rect;
    ex(): Point;
    private dw;
    d4(): void;
    de(): void;
    protected aq(a: Point): boolean;
    cz(a: Point, b: boolean, c: boolean): void;
    protected cy(a: Point): void;
    protected cx(a: Point): void;
    protected c0(a: Point): void;
    du(): void;
    readonly eo: ModifierKeys;
    eg(a: Rect): void;
    ck(a: boolean): void;
    bh(a: boolean): void;
    protected eb(): void;
    private ad;
    isDirty: boolean;
    undirty(a: boolean): void;
    readonly index: number;
    postRender(): void;
    b2(): void;
    protected ac: boolean;
    ca(): void;
    d0(): void;
    bs(a: boolean): void;
    bj(a: any): void;
    d8(a: number): void;
    d9(a: number): void;
    bk(a: any): void;
    dp(a: any): void;
    c1(a: Brush): void;
    br(a: Point): void;
    at: boolean;
    k(a: boolean): InteractionState;
    cw(): void;
    private ei;
    private eh;
    a9(a: TextBlock, b: FontInfo): number;
    a8(a: string, b: FontInfo): number;
    c9(): void;
    private ej;
    c8(): void;
    c4(): void;
    c(a: Axis): AxisTitlePosition;
    d(a: Axis): AxisTitlePosition;
    da(): void;
    db(): void;
    r(): FontInfo;
    es(): Brush;
    o(): FontInfo;
    ep(): Brush;
    q(): FontInfo;
    p(): FontInfo;
    er(): Brush;
    eq(): Brush;
    readonly a2: number;
    readonly a3: number;
    readonly a4: number;
    readonly a1: number;
    readonly el: TextBlock;
    readonly ek: TextBlock;
    e1(): Rect;
    e7(): Thickness;
    e6(): Thickness;
    private ab;
    private aa;
    c3(a: any, b: any): void;
    c7(a: any, b: any): void;
    en(): HorizontalAlignment;
    em(): HorizontalAlignment;
    private ae;
    bn(): void;
    ak(): boolean;
    b1(): void;
    ci(): void;
    ar(a: Point): boolean;
    df(): void;
    private av;
    b0(a: Dictionary$2<any, ITileZoomTile>, b: List$1<ITileZoomTile>, c: number): void;
    bf(a: Rect, b: ITileZoomTile, c: number): any;
    bx(): void;
    by(a: ITileZoomTile): void;
    cf(): void;
    ap: boolean;
    private be;
    bv(): void;
    bo(): void;
    bw(a: number): void;
    bp(): void;
    private af;
    cb(): void;
    d1(): void;
    c6(): void;
    co(): void;
}
/**
 * @hidden
 */
export declare class OverviewPlusDetailViewportHost extends Base implements IProvidesViewport {
    static $t: Type;
    constructor(a: SeriesViewerView);
    a: SeriesViewerView;
    getViewInfo(a: Rect, b: Rect): {
        p0: Rect;
        p1: Rect;
    };
    getEffectiveViewport(): Rect;
}
/**
 * @hidden
 */
export declare class SeriesViewerViewManager extends Base {
    static $t: Type;
    af: DomRenderer;
    protected ag: DomWrapper;
    protected ak: DomWrapper;
    protected aj: DomWrapper;
    protected ah: DomWrapper;
    al: DomWrapper;
    t: RenderingContext;
    w: RenderingContext;
    v: RenderingContext;
    u: RenderingContext;
    x: RenderingContext;
    f: EventProxy;
    private j;
    constructor(a: SeriesViewerView);
    protected ai: DomWrapper;
    bg(): void;
    be(a: any): void;
    static bv(a: DomRenderer, b: () => void): void;
    private bf;
    private ae;
    a9(): void;
    g(): IOverviewPlusDetailPane;
    bj(): void;
    bk(): void;
    b0(): Brush;
    private ab;
    private aa;
    private ac;
    ay(a: number, b: number, c: number): void;
    b5(): Point;
    y(): boolean;
    bb(a: boolean): void;
    a7(a: BrushCollection, b: BrushCollection, c: Brush, d: FontInfo, e: Brush): {
        p0: BrushCollection;
        p1: BrushCollection;
        p2: Brush;
        p3: FontInfo;
        p4: Brush;
    };
    e(): DefaultPaletteInfo;
    a6(a: number, b: number[], c: Brush, d: Brush, e: number, f: boolean): {
        p0: number;
        p1: number[];
        p2: Brush;
        p3: Brush;
        p4: number;
        p5: boolean;
    };
    ax(): void;
    br(x_: number): void;
    private ad;
    bs(y_: number): void;
    at(a: any): void;
    a8(): void;
    bl(): void;
    au(a: any): void;
    bh(a: any): void;
    bc(): void;
    private l;
    p(): FontInfo;
    private b7;
    cb(): Thickness;
    private aq;
    as(): string;
    private ap;
    ar(): string;
    private b6;
    ca(): Thickness;
    private bx;
    b2(): Brush;
    private bw;
    b1(): Brush;
    private k;
    o(): FontInfo;
    private a;
    c(): AxisTitlePosition;
    private b;
    d(): AxisTitlePosition;
    private n;
    r(): FontInfo;
    private bz;
    b4(): Brush;
    private m;
    q(): FontInfo;
    private by;
    b3(): Brush;
    private b8;
    cc(): Thickness;
    private b9;
    cd(): Thickness;
    bm(): void;
    private bu;
    private bo;
    private bn;
    private bp;
    private bq;
    a5(a: number, b: number): void;
    private h;
    i(): PointerTooltipStyle;
    ba(a: boolean): void;
    private z;
    ao(a: Rect, b: ITileZoomTile, c: number): any;
    a2(a: ITileZoomTile): void;
    a1(): void;
    bi(a: List$1<ITileZoomTile>): void;
    private am;
    az(): void;
    av(): void;
    private an;
    a0(a: number): void;
    aw(): void;
    private s;
    bd(): void;
    bt(a: boolean): void;
    a3(): void;
    a4(): void;
}
/**
 * @hidden
 */
export declare class AutoRangeCalculator extends Base {
    static $t: Type;
    static a(a: NumericAxisBase, b: number, c: number, d: boolean, e: number, f: number, g: number): {
        p5: number;
        p6: number;
    };
}
/**
 * @hidden
 */
export interface IAxisAnnotationManager {
    owner: Axis;
    onAutoAnnotionsChanged(a: Axis, b: AxisAnnotationCollection, c: NotifyCollectionChangedEventArgs): void;
    onAutoAnnotionsReset(a: Axis, b: AxisAnnotationCollection, c: EventArgs): void;
    onAnnotionsChanged(a: Axis, b: AxisAnnotationCollection, c: NotifyCollectionChangedEventArgs): void;
    onAnnotionsReset(a: Axis, b: AxisAnnotationCollection, c: EventArgs): void;
    onAddAnnotations(a: Axis): void;
    arrangeAnnotations(a: Axis, b: AxisLabelPanelBaseView, c: List$1<FrameworkElement>, d: List$1<Rect>, e: boolean, f: number, g: number, h: number, i: number, j: number): void;
}
/**
 * @hidden
 */
export declare let IAxisAnnotationManager_$type: Type;
/**
 * @hidden
 */
export declare class AxisLabelSettings extends Base implements INotifyPropertyChanged {
    static $t: Type;
    constructor();
    private aa;
    textStyle: string;
    private ax;
    textColor: Brush;
    location: AxisLabelsLocation;
    private b;
    visibility: Visibility;
    private a2;
    showFirstLabel: boolean;
    private h;
    c: AxisLabelsLocation;
    a: Axis;
    registerAxis(a: Axis): void;
    unregisterAxis(a: Axis): void;
    angle: number;
    private m;
    extent: number;
    private o;
    margin: number;
    leftMargin: number;
    private p;
    rightMargin: number;
    private q;
    topMargin: number;
    private r;
    bottomMargin: number;
    private n;
    private au;
    horizontalAlignment: HorizontalAlignment;
    private az;
    verticalAlignment: VerticalAlignment;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    ar(a: string, b: any, c: any): void;
    protected aq(a: any, b: string, c: any, d: any): void;
    j(): boolean;
    k(): boolean;
    static readonly extentPropertyDefault: number;
    readonly i: boolean;
    private f;
    g(a: DomRenderer): FontInfo;
}
/**
 * @hidden
 */
export declare class TitleSettings extends AxisLabelSettings {
    static $t: Type;
    constructor();
    private a4;
    position: AxisTitlePosition;
    protected aq(a: any, b: string, c: any, d: any): void;
}
/**
 * @hidden
 */
export declare abstract class Axis extends Control implements INotifyPropertyChanged {
    static $t: Type;
    a1(): AxisView;
    a2: AxisView;
    gr(a: AxisView): void;
    ge(): void;
    private bq;
    readonly br: SRProvider;
    private a6;
    readonly a7: IAxisVisualDataManager;
    du(): number;
    e8(): any;
    e7(): any;
    protected get_b2(): boolean;
    readonly b2: boolean;
    protected get_ca(): boolean;
    readonly ca: boolean;
    protected get_b0(): boolean;
    readonly b0: boolean;
    protected get_cb(): boolean;
    readonly cb: boolean;
    protected get_ce(): boolean;
    readonly ce: boolean;
    protected get_cc(): boolean;
    readonly cc: boolean;
    protected get_b5(): boolean;
    readonly b5: boolean;
    protected get_b3(): boolean;
    readonly b3: boolean;
    protected get_b4(): boolean;
    readonly b4: boolean;
    ah(): Axis;
    constructor();
    private a4;
    readonly a5: IAxisAnnotationManager;
    readonly b1: boolean;
    private gc;
    private gd;
    private ga;
    private gb;
    provideRenderer(a: DomRenderer): void;
    ar: (item: any) => string;
    go(a: Rect, b: Rect): void;
    abstract as(): AxisLabelPanelBase;
    ac(): void;
    hi: Canvas;
    bl: IFastItemsSourceProvider;
    private bk;
    bf: SeriesViewer;
    private be;
    bd: XamDataChart;
    readonly bp: (sender: any, e: RectChangedEventArgs) => void;
    private bu;
    co: boolean;
    private c2;
    ec: number;
    private cx;
    dd: number;
    private c8;
    ei: number;
    private c5;
    ef: number;
    private ap;
    aq: AxisExtentType;
    private c1;
    eb: number;
    dc: number;
    private c7;
    eh: number;
    private c4;
    ee: number;
    private bh;
    private bg;
    bj: FontInfo;
    private e9;
    fx: string;
    private c3;
    ed: number;
    de: number;
    private c9;
    ej: number;
    private c6;
    eg: number;
    private eu;
    ez: number;
    private et;
    ey: number;
    private es;
    ex: number;
    ev: number;
    private i6;
    i9: VerticalAlignment;
    private db;
    el: number;
    private da;
    ek: number;
    ha(): void;
    private g2;
    private g3;
    hj: TextBlock;
    f6: string;
    il: Brush;
    ih: Brush;
    em: number;
    iq: DoubleCollection;
    ik: Brush;
    ii: Brush;
    ie: Brush;
    d2: number;
    io: DoubleCollection;
    ij: Brush;
    ig: Brush;
    d5: number;
    ip: DoubleCollection;
    im: Brush;
    eo: number;
    ir: DoubleCollection;
    en: number;
    df: number;
    private hc;
    b6: boolean;
    b8: boolean;
    b9: boolean;
    cn: boolean;
    static readonly ib: DependencyProperty;
    ew: number;
    aw: AxisLabelSettings;
    dj(): number;
    ic(): HorizontalAlignment;
    i7(): VerticalAlignment;
    id(): HorizontalAlignment;
    i8(): VerticalAlignment;
    dl(): number;
    dn(): number;
    dm(): number;
    dk(): number;
    dr(): number;
    dt(): number;
    ds(): number;
    dq(): number;
    ax(): AxisLabelsLocation;
    ay(): AxisLabelsLocation;
    ag: Axis;
    e1: any;
    rangeChanged: (sender: any, e: AxisRangeChangedEventArgs) => void;
    protected g0(a: AxisRangeChangedEventArgs): void;
    bc: TitleSettings;
    dp(): number;
    di(): number;
    readonly ak: AxisAnnotationCollection;
    private ai;
    readonly al: AxisAnnotationCollection;
    private aj;
    private it;
    i0: Rect;
    iz: Rect;
    hd(): void;
    cq(a: Rect, b: Rect, c: AxisView): boolean;
    cd(): boolean;
    cu: List$1<any>;
    cv: List$1<LabelPosition>;
    at: AxisLabelPanelBase;
    protected hg(a: Rect, b: Rect): void;
    private bt;
    cf: boolean;
    protected ix(): Rect;
    protected hh(a: Rect, b: Rect): void;
    g1(): void;
    a3: ContentInfo;
    er: DomRenderer;
    protected gt(a: any, b: string, c: any, d: any): void;
    private _coercionMethods;
    coercionMethods: any;
    private bs;
    protected get_expectFunctions(): boolean;
    protected set_expectFunctions(a: boolean): void;
    expectFunctions: boolean;
    ci: boolean;
    private g8;
    cp: boolean;
    protected gq(a: GeometryCollection, b: number, c: number, d: Rect): void;
    protected gp(a: GeometryCollection, b: number, c: Rect, d: PathRenderingInfo, e: boolean): void;
    protected hf(a: GeometryCollection, b: number, c: number, d: Rect): void;
    protected he(a: GeometryCollection, b: number, c: Rect, d: PathRenderingInfo, e: boolean): void;
    private b7;
    protected g9(a: number, b: number, c: Rect, d: Rect, e: Rect, f: number, g: number): {
        p0: number;
        p1: number;
    };
    dg(a: number, b: number, c: number, d: PathRenderingInfo): number;
    gh(a: GeometryCollection): void;
    protected gg(): void;
    g4(): void;
    g5(a: boolean): void;
    renderRequested: (sender: any, e: RenderRequestedEventArgs) => void;
    a9: LabelFontHeuristics;
    static d4: number;
    d9(): number;
    d7(): number;
    d8(): number;
    protected readonly cj: boolean;
    gj(a: boolean): void;
    private cz;
    private bw;
    g7(): void;
    private c0;
    a8(): LabelFontHeuristics;
    bi(): FontInfo;
    private gk;
    cg: boolean;
    ck(): boolean;
    cl(a: boolean): boolean;
    cm(): boolean;
    protected g6(a: boolean): void;
    hb(): void;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected gz(a: string, b: any, c: any): void;
    cw: List$1<Series>;
    ch(a: Series): boolean;
    bv(a: Series): boolean;
    e6: any;
    e3(a: any, b: string): any;
    private cs;
    protected fu(a: string): string;
    private cr;
    protected e4(a: any, b: string, c: string): any;
    e5(a: any): any;
    fi(a: number): string;
    d6(): number;
    dv(a: number, b: ScalerParams): number;
    dw(a: number, b: ScalerParams, c: CategoryMode): number;
    iw(a: Rect): Rect;
    iv(): Rect;
    iu(): Rect;
    protected iy(a: Rect, b: Rect): Rect;
    dx(a: number, b: Rect, c: Rect): number;
    gm(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    gl(a: IList$1<number[]>, b: IList$1<number>, c: number, d: number, e: ScalerParams): void;
    dy(a: number, b: ScalerParams): number;
    dz(a: number, b: ScalerParams, c: CategoryMode): number;
    d0(a: number, b: Rect, c: Rect): number;
    gn(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    ea(a: number): number;
    abstract readonly az: AxisOrientation;
    i5: Size;
    gs(): void;
    am: AxisComponentsForView;
    an(): AxisComponentsForView;
    dh: number;
    private cy;
    d3: number;
    bz(): boolean;
    d1(): number;
    protected gf(): void;
    gi(a: AxisRangeChangedEventArgs): void;
    bo: Pool$1<TextBlock>;
    bn: Pool$1<TextBlock>;
    bm: Pool$1<Rectangle>;
    readonly i1: Path;
    readonly i2: Path;
    readonly i4: Path;
    readonly i3: Path;
    bb(): SyncSettings;
    ao(): AxisComponentsFromView;
    private au;
    readonly av: AxisLabelSettings;
    gu(a: RenderingContext, b: RenderingContext): void;
    by(): boolean;
    e2(): any;
    private _ct;
    ct(): IEnumerable$1<Series>;
    gv(a: string): void;
    gy(a: any): void;
    gx(a: any): void;
    eq: CultureInfo;
    is(a: number, b: Rect, c: Rect, d?: any, e?: any): Geometry;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class AxisCollection extends ObservableCollection$1<Axis> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class AxisLabelManager extends Base {
    static $t: Type;
    e: List$1<any>;
    f: List$1<LabelPosition>;
    b: AxisLabelPanelBase;
    a: Axis;
    c: (arg1: number) => void;
    constructor();
    m(a: Rect, b: Rect): void;
    i(a: any, b: LabelPosition): void;
    s(): void;
    static j(a: FrameworkElement): void;
    private static k;
    static l(a: FrameworkElement): void;
    h(a: FrameworkElement): void;
    q(a: number): void;
    n(a: number): void;
    t(a: number): FrameworkElement;
    r(a: number): void;
    readonly d: boolean;
    p(): void;
    o(): void;
    g(): void;
}
/**
 * @hidden
 */
export declare abstract class AxisLabelPanelBase extends Panel {
    static $t: Type;
    ad(): AxisLabelPanelBaseView;
    b8(a: AxisLabelPanelBaseView): void;
    ae: AxisLabelPanelBaseView;
    cl: Rect;
    bz(): void;
    ce(): void;
    cd(): void;
    constructor();
    bn: number;
    ac: Axis;
    private aj;
    at: boolean;
    private ax;
    a1: List$1<any>;
    a2: List$1<LabelPosition>;
    co: Rect;
    private ck;
    cp: Rect;
    private cj;
    cn: Rect;
    private a4;
    a8: number;
    bo: () => boolean;
    a3: List$1<FrameworkElement>;
    a0: List$1<Rect>;
    af: AxisLabelSettings;
    am: boolean;
    ap: boolean;
    aq: boolean;
    ar: boolean;
    bq: any;
    ak: boolean;
    protected al(a: List$1<Rect>, b: List$1<boolean>): boolean;
    protected bp(a: number, b: List$1<Rect>, c: List$1<boolean>): {
        ret: number;
        p1?: List$1<Rect>;
    };
    ay(): List$1<Rect>;
    bx(): void;
    bt(a: Size): void;
    bd(): number;
    bh(): number;
    ao(a: number, b: Rect): boolean;
    bc(a: any): number;
    bm(a: any): number;
    be(a: any): number;
    bb(a: any): number;
    an(): boolean;
    protected ch(a: Rect, b: Rect): void;
    protected b4(a: Rect, b: Rect): void;
    az(): List$1<Rect>;
    bg(a: number, b: Size): number;
    bf(a: number, b: Size): number;
    bk(): number;
    bi(): number;
    bj(): number;
    bl(): number;
    cq(a: Size): Size;
    cm(): Rect;
    protected bw(a: Size): void;
    protected bv(a: Size): void;
    protected b0(): void;
    protected aw(): IEnumerable$1<number>;
    readonly ag: AxisLabelsLocation;
    cg(a: GeometryCollection, b: number, c: number, d: number, e: Rect, f: PathRenderingInfo): void;
    b3(a: GeometryCollection, b: number, c: number, d: number, e: Rect, f: PathRenderingInfo): void;
    cb(a: FrameworkElement, b: number): void;
    cc(a: FrameworkElement): void;
    b2(a: FrameworkElement, b: number): void;
    cr(a: Size): Size;
    static readonly ci: DependencyProperty;
    a9: number;
    a5: number;
    ai(a: TitleSettings): AxisTitlePosition;
    ah(): AxisLabelsLocation;
    as(a: AxisLabelsLocation): boolean;
    private _au;
    au(): IEnumerable$1<any>;
    bs(a: number, b: TextBlock, c: number, d: number, e: number): string;
    by(a: any): void;
    b7(a: FrameworkElement): void;
    private _av;
    av(): IEnumerable$1<any>;
    protected a6: number;
    protected a7: number;
    b1(): void;
    cf(): void;
    b5(): void;
    ba(a: Rect): number;
    b6(): void;
    b9(a: RenderingContext): void;
    bu(): void;
    ca(): void;
}
/**
 * @hidden
 */
export declare abstract class CategoryAxisBase extends Axis implements ICategoryScaler {
    static $t: Type;
    a1(): AxisView;
    protected get_b4(): boolean;
    gr(a: AxisView): void;
    ja: CategoryAxisBaseView;
    constructor();
    cq(a: Rect, b: Rect, c: AxisView): boolean;
    ki(): void;
    kh(): void;
    jl: List$1<number>;
    protected get_b2(): boolean;
    kt(a: Point, b: boolean, c: number): Rect;
    ku(a: Point, b: boolean, c: number, d: boolean): Rect;
    je: IFastItemsSource;
    private jd;
    itemsSource: IEnumerable;
    static readonly kq: DependencyProperty;
    private jw;
    jx: number;
    jy: number;
    categoryMode: CategoryMode;
    private jb;
    jn: number;
    ju: number;
    ji: boolean;
    j0: number;
    private jz;
    dy(a: number, b: ScalerParams): number;
    getUnscaledValue3(a: number, b: Rect, c: Rect, d: CategoryMode): number;
    getCategorySize(a: Rect, b: Rect, c: Rect): number;
    jq(a: Rect, b: Rect, c: Rect): number;
    getGroupCenter(a: number, b: Rect, c: Rect, d: Rect): number;
    jv(a: number): number;
    private _jk;
    private jk;
    private jg;
    jh(a: SeriesViewer): boolean;
    private _jj;
    private jj;
    private jf;
    km(a: boolean): void;
    protected gt(a: any, b: string, c: any, d: any): void;
    protected ka(): void;
    kc(a: any, b: FastItemsSourceEventArgs): void;
    protected kj(a: FastItemsSourceEventArgs): void;
    private kn;
    ch(a: Series): boolean;
    bv(a: Series): boolean;
    private kk;
    j9(): void;
    kl(): void;
    kb(a: NotifyCollectionChangedEventArgs): void;
    kg(a: number, b: any, c: any): void;
    kd(): void;
    ke(a: number, b: any): void;
    kf(a: number, b: any): void;
    jr(a: Rect, b: Rect, c: Rect, d: number): number;
    js(a: Rect, b: Rect, c: Rect, d: number, e: number): number;
    getSeriesOffset(a: Rect, b: Rect, c: Rect, d: number, e: number): number;
    readonly isVertical: boolean;
    j$c(a: number, b: ScalerParams): number;
    j$b(a: number, b: ScalerParams): number;
    j$d(a: IList$1<number[]>, b: IList$1<number>, c: number, d: number, e: ScalerParams): void;
    j$e(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    j$f(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    readonly j$a: boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class HorizontalAxisLabelPanelBase extends AxisLabelPanelBase {
    static $t: Type;
    ad(): AxisLabelPanelBaseView;
    b8(a: AxisLabelPanelBaseView): void;
    cs: HorizontalAxisLabelPanelBaseView;
    c4: number;
    c1: number;
    c3: number;
    c2: number;
    bx(): void;
    cu(): boolean;
    cv(): boolean;
    an(): boolean;
    ay(): List$1<Rect>;
    c6(a: List$1<Rect>, b: List$1<boolean>, c: number): void;
    private c5;
    private c7;
    protected c8(a: List$1<Rect>, b: List$1<boolean>): void;
    protected c9(): void;
    cb(a: FrameworkElement, b: number): void;
    protected cw(): boolean;
    protected ct(): boolean;
    protected bp(a: number, b: List$1<Rect>, c: List$1<boolean>): {
        ret: number;
        p1?: List$1<Rect>;
    };
    cm(): Rect;
    c0(): number;
    cx(): number;
    cz(): number;
    cy(): number;
    protected b0(): void;
}
/**
 * @hidden
 */
export declare class HorizontalAxisLabelPanel extends HorizontalAxisLabelPanelBase {
    static $t: Type;
    ah(): AxisLabelsLocation;
    as(a: AxisLabelsLocation): boolean;
}
/**
 * @hidden
 */
export declare abstract class NumericAxisBase extends Axis {
    static $t: Type;
    a1(): AxisView;
    gr(a: AxisView): void;
    jb: NumericAxisBaseView;
    protected get_ca(): boolean;
    constructor();
    kb: number;
    j3: number;
    private jx;
    j9: number;
    e8(): any;
    j6: number;
    private j0;
    ka: number;
    j2: number;
    private jw;
    e7(): any;
    j8: number;
    private jz;
    j5: number;
    j7: number;
    private jv;
    j1: number;
    d6(): number;
    kc: number;
    private jy;
    j4: number;
    kd: number;
    js: boolean;
    private jm;
    jo: boolean;
    readonly jt: boolean;
    kf: number;
    kg: number;
    je: NumericAxisRenderer;
    protected ju: boolean;
    protected g6(a: boolean): void;
    gy(a: any): void;
    gx(a: any): void;
    protected gt(a: any, b: string, c: any, d: any): void;
    protected k0(): void;
    ja(): AxisRange;
    ky(a: NumericAxisBase, b: number, c: number, d: boolean, e: number, f: number, g: number): {
        p5: number;
        p6: number;
    };
    cm(): boolean;
    k1(a: AxisRangeChangedEventArgs): void;
    ch(a: Series): boolean;
    bv(a: Series): boolean;
    jd(a: AxisLabelManager): NumericAxisRenderer;
    jc(): NumericAxisRenderer;
    jg(): NumericAxisRenderingParameters;
    kz(): void;
    jh(): NumericScaler;
    jf(a: Rect, b: Rect, c: Rect, d: Rect): NumericAxisRenderingParameters;
    ke(a: number): number;
    jp(): boolean;
    readonly jr: boolean;
    readonly jq: boolean;
    private k2;
    static readonly la: DependencyProperty;
    jk: TickmarkValues;
    private ji;
    jj: TickmarkValues;
    private jl;
    jn: boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class NumericScaler extends DependencyObject {
    static $t: Type;
    static readonly ac: Rect;
    abstract t(a: NumericAxisBase, b: number, c: number, d: number, e: number): {
        p3: number;
        p4: number;
    };
    l: number;
    k: number;
    protected o: number;
    protected n: number;
    y(a: number): void;
    x(a: number): void;
    protected w(a: string, b: any, c: any): void;
    private z;
    protected m: number;
    abstract q(a: number, b: ScalerParams): number;
    abstract p(a: number, b: ScalerParams): number;
    j(a: IList$1<number>, b: number, c: number, d: ScalerParams): IList$1<number>;
    v(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    u(a: IList$1<number[]>, b: IList$1<number>, c: number, d: number, e: ScalerParams): void;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class AxisRendererBase extends Base {
    static $t: Type;
    constructor(a: AxisLabelManager);
    u: () => void;
    o: (viewportRect: Rect, windowRect: Rect) => boolean;
    v: () => void;
    m: (p: AxisRenderingParametersBase, value: number) => number;
    l: (p: AxisRenderingParametersBase, geometry: GeometryCollection, startValue: number, endValue: number) => void;
    k: (p: AxisRenderingParametersBase, geometry: GeometryCollection, value: number) => void;
    q: (p: AxisRenderingParametersBase, value: number) => boolean;
    n: (p: AxisRenderingParametersBase, value: number) => boolean;
    j: (p: AxisRenderingParametersBase) => void;
    e: (p: AxisRenderingParametersBase) => void;
    p: (p: AxisRenderingParametersBase, position: number, isLastLabel: boolean) => boolean;
    h: (p: AxisRenderingParametersBase, value: number) => LabelPosition;
    t: (p: AxisRenderingParametersBase, value: number) => number;
    b: AxisLabelManager;
    g: (item: any) => any;
    d: (viewportRect: Rect, windowRect: Rect, effectiveViewportRect: Rect, contentViewport: Rect) => AxisRenderingParametersBase;
    r: (p: AxisRenderingParametersBase, value: number, absoluteIndex: number, interval: number) => number;
    a: (p: AxisRenderingParametersBase, value: number, absolueIndex: number, interval: number) => number;
    f: (index: number, window: Rect, viewport: Rect, effectiveViewport: Rect) => number;
    i: (index: number) => number;
    c(a: boolean, b: Rect, c: Rect, d: Rect, e: Rect): AxisRenderingParametersBase;
    private aa;
    private ab;
    protected x(a: Rect, b: Rect): void;
    private z;
    private s;
    private y;
    w(a: AxisRenderingParametersBase, b: number, c: number, d: number): any;
}
/**
 * @hidden
 */
export declare class NumericAxisRenderer extends AxisRendererBase {
    static $t: Type;
    constructor(a: AxisLabelManager);
    w(a: AxisRenderingParametersBase, b: number, c: number, d: number): any;
    private ac;
    private ad;
    private ae;
}
/**
 * @hidden
 */
export declare class VerticalAxisLabelPanel extends AxisLabelPanelBase {
    static $t: Type;
    ad(): AxisLabelPanelBaseView;
    b8(a: AxisLabelPanelBaseView): void;
    cs: VerticalAxisLabelPanelView;
    c1: number;
    cy: number;
    c0: number;
    cz: number;
    bx(): void;
    bh(): number;
    cu(): number;
    cw(): number;
    cx(): number;
    cv(): number;
    ay(): List$1<Rect>;
    private c2;
    private c3;
    cb(a: FrameworkElement, b: number): void;
    protected ct(): boolean;
    cm(): Rect;
    ai(a: TitleSettings): AxisTitlePosition;
    ah(): AxisLabelsLocation;
    as(a: AxisLabelsLocation): boolean;
    protected b0(): void;
}
/**
 * @hidden
 */
export interface IHasCategoryAxis {
    readonly categoryAxis: CategoryAxisBase;
    getOffsetValue(): number;
    getCategoryWidth(): number;
}
/**
 * @hidden
 */
export declare let IHasCategoryAxis_$type: Type;
/**
 * @hidden
 */
export interface IHasCategoryModePreference extends IHasCategoryAxis {
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
}
/**
 * @hidden
 */
export declare let IHasCategoryModePreference_$type: Type;
/**
 * @hidden
 */
export interface IHighlightingManager {
    startHighlight(a: HighlightingInfo): void;
    endHighlight(a: HighlightingInfo): void;
    clear(): void;
    getHighlightingInfo(a: Series, b: IFastItemsSource, c: Axis, d: number, e: number, f: boolean): HighlightingInfo;
    tick(a: number): boolean;
    inProgress: boolean;
    maxHighlightingProgress: number;
    sumHighlightingProgress: number;
    maxMarkerHighlightingProgress: number;
    sumMarkerHighlightingProgress: number;
    readonly dirtySeries: List$1<Series>;
}
/**
 * @hidden
 */
export declare let IHighlightingManager_$type: Type;
/**
 * @hidden
 */
export declare class HighlightingInfo extends Base {
    static $t: Type;
    constructor();
    f: number;
    e: number;
    a: HighlightingState;
    d: number;
    c: boolean;
    b: Series;
}
/**
 * @hidden
 */
export interface ISeriesInteractionManager {
    a$i(a: Series, b: Point, c: number, d: Axis, e: ScalerParams, f: number, g: number, h: (arg1: Point) => number): number;
    a$l(a: Series, b: IList$1<number>, c: Point, d: Axis, e: ScalerParams, f: number, g: (arg1: Point) => number, h: boolean, i: boolean): number;
    a$k(a: Series, b: number, c: IList$1<number>, d: number, e: number, f: number, g: number, h: number, i: boolean): number;
    a$n(a: Series, b: Point, c: boolean, d: Axis, e: (arg1: Point) => number, f: IList$1<number>): number;
    a$d(a: Series, b: Point, c: boolean): boolean;
    a$a(a: Series, b: CategoryAxisBase, c: List$1<number[]>, d: number, e: number, f: Point, g: boolean): number[][];
    a$e(a: Series, b: Point, c: boolean, d: PathGeometry): boolean;
    a$f(a: Series, b: Point, c: PathGeometry): boolean;
    a$m(a: Series, b: Point, c: boolean, d: Axis, e: (arg1: Point) => number, f: IList$1<number>): number;
    a$j(a: Series, b: Point, c: Axis): number;
    a$g(a: Series, b: Point, c: boolean): boolean;
    a$aj(a: Series, b: Point, c: boolean, d: boolean, e: number, f: Axis, g: Axis, h: (arg1: Point, arg2: boolean, arg3: boolean) => number, i: (arg1: Point, arg2: boolean) => number, j: (arg1: Point, arg2: boolean) => number): Point;
    a$t(a: Series, b: any, c: Point, d: boolean, e: boolean): void;
    a$ai(a: Series, b: HighlightingInfo, c: Brush): Brush;
    a$w(a: Series, b: Point, c: any, d: any): void;
    a$ag(a: Series, b: Point): void;
    a$z(a: Series, b: Point, c: any, d: any): void;
    a$x(a: Series, b: Point, c: any, d: any): void;
    a$u(a: Series, b: Point, c: any, d: any): void;
    a$y(a: Series, b: Point, c: any, d: any): void;
    a$v(a: Series, b: Point, c: any, d: any): void;
    a$aa(a: Series, b: Point, c: any, d: any): void;
    a$ab(a: Series, b: Point, c: any, d: any): void;
    a$p(a: Series): string;
    a$q(a: Series): string;
    readonly a$b: boolean;
    readonly a$o: any;
    a$ah(a: Series, b: any): void;
    a$af(a: Series, b: Point, c: (arg1: any) => void): void;
    a$s(a: Series): void;
    a$ae(a: Series): void;
    readonly a$c: boolean;
    readonly a$h: Dictionary$2<string, SeriesView>;
    a$r(a: Series, b: Rect, c: Rect, d: string, e: number): void;
    a$ac(a: Series, b: SeriesViewer): void;
    a$ad(a: Series, b: string, c: SeriesViewer): void;
}
/**
 * @hidden
 */
export declare let ISeriesInteractionManager_$type: Type;
/**
 * @hidden
 */
export interface ISeriesViewerInteractionManager {
    f$a(a: SeriesViewer): ChartHitTestMode;
    f$ae(a: SeriesViewer): void;
    f$p(a: SeriesViewer, b: Point): void;
    f$ac(a: SeriesViewer, b: Point): void;
    f$q(a: SeriesViewer, b: Point, c: boolean): void;
    f$o(a: SeriesViewer, b: Point): void;
    f$aj(a: SeriesViewer): void;
    f$ab(a: SeriesViewer, b: Point): void;
    f$ak(a: SeriesViewer, b: Point, c: number, d: number, e: number): void;
    f$aa(a: SeriesViewer, b: number): void;
    f$ag(a: SeriesViewer, b: Point, c: number, d: number, e: number): void;
    f$x(a: SeriesViewer, b: Point): void;
    f$z(a: SeriesViewer, b: number): void;
    f$r(a: SeriesViewer, b: Point): void;
    f$af(a: SeriesViewer, b: Point, c: number, d: number, e: number): void;
    f$m(a: SeriesViewer, b: Point, c: boolean): void;
    f$ai(a: SeriesViewer): void;
    f$ah(a: SeriesViewer): void;
    f$am(a: SeriesViewer): void;
    f$j(a: SeriesViewer): void;
    f$g(a: SeriesViewer): void;
    f$l(a: SeriesViewer, b: Point, c: boolean): void;
    f$k(a: SeriesViewer, b: Point, c: boolean): void;
    f$al(a: SeriesViewer): void;
    f$ad(a: SeriesViewer): void;
    f$d(a: SeriesViewer, b: Key): boolean;
    f$e(a: SeriesViewer, b: Point, c: number): boolean;
    f$n(a: SeriesViewer, b: Point): void;
    f$i(a: SeriesViewer): void;
    f$h(a: SeriesViewer): void;
    readonly f$b: IHighlightingManager;
    f$c(a: SeriesViewer, b: SeriesCollection, c: RenderingContext, d: Point, e: boolean, f: DataContext, g: boolean): {
        ret: Series;
        p5: DataContext;
    };
    f$f(a: SeriesViewer, b: Point): boolean;
    f$v(a: SeriesViewer, b: SeriesCollection, c: RenderingContext, d: Point, e: boolean, f: boolean): void;
    f$u(a: SeriesViewer, b: Point): void;
    f$t(a: SeriesViewer, b: EventProxy, c: Point): void;
    f$w(a: SeriesViewer, b: EventProxy, c: Point): void;
    f$s(a: SeriesViewer, b: Point, c: boolean): void;
    f$y(a: SeriesViewer, b: boolean): void;
}
/**
 * @hidden
 */
export declare let ISeriesViewerInteractionManager_$type: Type;
/**
 * @hidden
 */
export interface IDataChartVisualDataManager {
    exportVisualData(a: XamDataChart): any;
}
/**
 * @hidden
 */
export declare let IDataChartVisualDataManager_$type: Type;
/**
 * @hidden
 */
export interface IAxisVisualDataManager {
    exportVisualData(a: Axis): any;
}
/**
 * @hidden
 */
export declare let IAxisVisualDataManager_$type: Type;
/**
 * @hidden
 */
export interface ISeriesVisualDataManager {
    exportVisualData(a: Series, b: Rect): any;
    exportMarkerVisualData(a: MarkerSeries, b: any): void;
    getMarkerVisualData(a: Series, b: Marker, c: DataTemplate): any;
    copyVisualData(a: any, b: any): void;
    exportTrendlineData(a: Series, b: any, c: Polyline): void;
    exportStackedVisualData(a: Series, b: Rect): any;
    createFragmentVisualData(a: Series, b: Rect, c: string, d: string): any;
    addSubSeriesVisualData(a: any, b: any): void;
    exportRectangleData(a: any, b: Rectangle, c: string, d: string[]): void;
    exportMarkerVisualDataFromMarker(a: Series, b: any, c: ContentControl): void;
    exportPathData(a: any, b: Path, c: string, d: string[]): void;
    exportPolylineData(a: any, b: Polyline, c: string, d: string[]): void;
    exportPolygonData(a: any, b: Polygon, c: string, d: string[]): void;
    exportSeriesPixelsData(a: any, b: number[], c: number, d: number): void;
    addPointerTooltipData(a: any, b: any, c: number, d: number, e: List$1<string>): void;
    exportPointerTooltipData(a: Polygon, b: Polyline, c: Rectangle, d: Rect): any;
    exportCalloutData(a: number, b: number, c: number, d: number, e: any, f: Rectangle, g: TextBlock, h: FontInfo, i: Line, j: string, k: string[]): void;
}
/**
 * @hidden
 */
export declare let ISeriesVisualDataManager_$type: Type;
/**
 * @hidden
 */
export declare class XamDataChart extends SeriesViewer {
    static $t: Type;
    static n6: number;
    static n5: number;
    private _xsr;
    private readonly XSRP;
    private nh;
    readonly ni: IDataChartVisualDataManager;
    static staticInit(): void;
    static od(a: Series): number;
    constructor();
    protected jd(a: any, b: string, c: any, d: any): void;
    private o2;
    ns: boolean;
    eg(): number;
    eh(): number;
    protected j9(): void;
    ob: number;
    oc: number;
    private nx;
    n3: number;
    private ny;
    n4: number;
    c3(): boolean;
    c4(): boolean;
    nq: boolean;
    nv: boolean;
    nr: boolean;
    nt: boolean;
    ng: GridMode;
    nn: boolean;
    nu: boolean;
    m9: BrushCollection;
    na: BrushCollection;
    nc: BrushCollection;
    nb: BrushCollection;
    po: Brush;
    pm: Brush;
    pn: Brush;
    readonly axes: AxisCollection;
    private nd;
    private oz;
    private o0;
    axisRangeChanged: (sender: any, e: ChartAxisRangeChangedEventArgs) => void;
    private o1;
    private static o3;
    ki(a: SyncLink, b: SyncLink): void;
    private nk;
    getFontInfo(): FontInfo;
    o4(): void;
    getFontBrush(): Brush;
    protected hi(): void;
    l5(): Brush;
    dd(): boolean;
    protected kd(): void;
    l6(a: number): Brush;
    private pp;
    ma(a: number): Brush;
    mb(a: number): Brush;
    mc(a: number): Brush;
    cl(): boolean;
    private np;
    protected bm(): SeriesViewerView;
    protected i1(a: SeriesViewerView): void;
    nj: XamDataChartView;
    jt(): void;
    private n0;
    n8: number;
    private n2;
    oa: number;
    private n1;
    n9: number;
    private nz;
    n7: number;
    protected ms(a: Rect): Rect;
    mx(): Rect;
    oe(): any;
    om(): string;
    ja(): void;
    jv(): void;
    nw(a: Axis): List$1<Axis>;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class LabelPanelArranger extends Base {
    static $t: Type;
    static e(a: List$1<AxisLabelPanelBase>, b: Rect): Rect;
    private static a;
    static b(a: AxisLabelPanelBase): AxisLabelsLocation;
    private static c;
    static d(a: List$1<AxisLabelPanelBase>, b: LabelPanelsArrangeState, c: Rect, d: (arg1: AxisLabelPanelBase, arg2: Rect) => void): void;
}
/**
 * @hidden
 */
export declare class ChartContentManager extends DependencyObject {
    static $t: Type;
    private l;
    private q;
    private s;
    private t;
    constructor(a: SeriesViewer);
    k(a: ChartContentType, b: DependencyObject, c: (arg1: boolean) => void): ContentInfo;
    ac(a: ChartContentType, b: DependencyObject): void;
    private m;
    private u;
    z(a: DomRenderer): void;
    y(): void;
    ab(a: ChartContentType, b: DependencyObject, c: ContentInfo, d: boolean): void;
    private p;
    private j;
    x(): void;
    private v;
    private _r;
    private r;
    w(a: Size): void;
    n: boolean;
    o: boolean;
    ad(a: ChartContentType, b: DependencyObject, c: ContentInfo, d: Rect): void;
    aa(a: Axis, b: ContentInfo): void;
}
/**
 * @hidden
 */
export declare class ContentInfo extends Base {
    static $t: Type;
    h: DependencyObject;
    a: (arg1: boolean) => void;
    b: boolean;
    c: boolean;
    i: Rect;
    readonly d: boolean;
    g(): void;
    f(): void;
    e: boolean;
}
/**
 * @hidden
 */
export declare abstract class Series extends Control implements INotifyPropertyChanged, IProvidesViewport, ILegendSeries, ILegendOwner, ILegendTemplateProvider {
    static $t: Type;
    bi: SeriesView;
    private static e5;
    fk: number;
    lo: Rect;
    private e3;
    e4: DomRenderer;
    provideRenderer(a: DomRenderer): void;
    gv(): string;
    constructor();
    private static readonly k1;
    protected ho(a: any, b: PropertyChangedEventArgs): void;
    private b1;
    readonly b2: SRProvider;
    private a1;
    readonly a2: ISeriesVisualDataManager;
    protected readonly dz: Dictionary$2<string, SeriesView>;
    private az;
    readonly a0: ISeriesInteractionManager;
    readonly cx: boolean;
    bt: DoubleAnimator;
    it(a: SeriesView): void;
    ir(): void;
    is(): void;
    bg(): SeriesView;
    protected bf(): SeriesView;
    jw: Canvas;
    dt(): boolean;
    fs(a: any, b: string): any;
    private dy;
    protected gu(a: string): string;
    private dx;
    protected ft(a: any, b: string, c: string): any;
    eb(a: Point): number;
    fa(a: Point): number;
    protected get_c1(): boolean;
    readonly c1: boolean;
    ap(): CategoryAxisBase;
    e8(a: Point): number;
    fp(a: Point): any;
    protected fu(a: Series, b: Point): any;
    e7(): number;
    fb(): number;
    fg(): number;
    readonly container: ILegendOwner;
    readonly hasSubItems: boolean;
    protected ci(): boolean;
    forSubItems(a: (arg1: any) => void): void;
    protected h6(a: (arg1: any) => void): void;
    h7(a: (arg1: Series) => boolean): void;
    k8(): Brush;
    resolveLegendIndex(): number;
    a6(): Series;
    protected get_cj(): boolean;
    readonly cj: boolean;
    protected get_isVertical(): boolean;
    readonly isVertical: boolean;
    protected get_cs(): boolean;
    readonly cs: boolean;
    protected get_ck(): boolean;
    readonly ck: boolean;
    protected get_c0(): boolean;
    readonly c0: boolean;
    protected get_c4(): boolean;
    readonly c4: boolean;
    protected get_c2(): boolean;
    readonly c2: boolean;
    protected get_isStacked(): boolean;
    readonly isStacked: boolean;
    protected get_cr(): boolean;
    readonly cr: boolean;
    protected get_c3(): boolean;
    readonly c3: boolean;
    protected get_cl(): boolean;
    readonly cl: boolean;
    protected get_ct(): boolean;
    readonly ct: boolean;
    protected get_c5(): boolean;
    readonly c5: boolean;
    protected get_c6(): boolean;
    readonly c6: boolean;
    a5(): Series;
    protected get_cm(): boolean;
    readonly cm: boolean;
    protected get_cn(): boolean;
    readonly cn: boolean;
    d9(a: Point, b: number, c: Axis, d: ScalerParams, e: number): number;
    protected ea(a: Point, b: number, c: Axis, d: ScalerParams, e: number, f: number, g: (arg1: Point) => number): number;
    protected get_dv(): boolean;
    readonly dv: boolean;
    protected ep(a: IList$1<number>, b: Point, c: Axis, d: ScalerParams, e: number, f: (arg1: Point) => number, g: boolean, h: boolean): number;
    ef(a: number, b: IList$1<number>, c: number, d: number, e: number, f: number, g: number, h: boolean): number;
    ff(a: Point, b: boolean, c: Axis, d: (arg1: Point) => number, e: IList$1<number>): number;
    ee(a: boolean): number;
    ah(a: Point): Point[][];
    ai(a: Point): Point[][];
    protected dg(a: Point, b: boolean): boolean;
    aj(a: CategoryAxisBase, b: List$1<number[]>, c: number, d: number, e: Point, f: boolean): number[][];
    protected di(a: Point, b: boolean, c: PathGeometry): boolean;
    protected dj(a: Point, b: PathGeometry): boolean;
    fd(a: Point, b: boolean, c: Axis, d: (arg1: Point) => number, e: IList$1<number>): number;
    ed(a: Point, b: Axis): number;
    fe(a: Point, b: boolean): number;
    fc(a: Point, b: boolean): number;
    en(a: Point, b: boolean, c: boolean): number;
    lk(a: Point, b: boolean, c: boolean): Point;
    lt(a: Point): Rect;
    ak(a: Point): Rect[];
    lu(a: Point): Rect;
    al(a: Point): Rect[];
    lv(a: Point): Rect;
    lw(a: Point): Rect;
    protected dk(a: Point, b: boolean): boolean;
    protected lm(a: Point, b: boolean, c: boolean, d: number, e: Axis, f: Axis, g: (arg1: Point, arg2: boolean, arg3: boolean) => number, h: (arg1: Point, arg2: boolean) => number, i: (arg1: Point, arg2: boolean) => number): Point;
    ej(a: Point, b: boolean, c: boolean): number;
    lg(a: Point, b: boolean, c: boolean): Point;
    el(a: Point, b: boolean, c: boolean): number;
    li(a: Point, b: boolean, c: boolean): Point;
    ll(a: Point, b: boolean, c: boolean): Point;
    eo(a: Point, b: boolean, c: boolean): number;
    lh(a: Point, b: boolean, c: boolean): Point;
    ek(a: Point, b: boolean, c: boolean): number;
    lj(a: Point, b: boolean, c: boolean): Point;
    em(a: Point, b: boolean, c: boolean): number;
    e9(a: Point): number;
    eg(): number;
    ec(a: Point): number;
    fq(a: Point): any;
    ch(a: List$1<SeriesPointOfInterest>, b: boolean, c: number): boolean;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected raisePropertyChanged(a: string, b: any, c: any): void;
    protected get_hasMarkers(): boolean;
    readonly hasMarkers: boolean;
    k5(): Brush;
    k6(): Brush;
    jy(): DataTemplate;
    ln(a: Point): Point;
    lf(a: Point): Point;
    fv(a: any, b: Point): any;
    c9(a: any): boolean;
    an(a: Axis): AxisRange;
    ao(): AxisRange;
    jc(a: boolean): void;
    renderRequested: (sender: any, e: RenderRequestedEventArgs) => void;
    private h1;
    jd(a: boolean): void;
    protected dm: boolean;
    protected hs(): void;
    protected hw(): void;
    bh: SeriesView;
    je(a: Rect, b: RenderSurface): void;
    jb(a: Rect, b: Rect, c: RenderSurface, d: string, e: number): void;
    getEffectiveViewport1(a: SeriesView): Rect;
    lp(a: SeriesView): Rect;
    ls(a: Rect): Rect;
    lr(a: SeriesView): Rect;
    getEffectiveViewport(): Rect;
    i6(): void;
    private i7;
    i8(a: string): void;
    getViewInfo(a: Rect, b: Rect): {
        p0: Rect;
        p1: Rect;
    };
    dw(a: Rect, b: Rect, c: SeriesView): boolean;
    hv(a: boolean, b: SeriesView): void;
    protected cb(): boolean;
    cc(a: SeriesView): boolean;
    iu(a: Rect, b: Rect): void;
    protected js(a: Rect, b: Rect): void;
    protected jr(a: Rect, b: Rect): void;
    aq: ContentInfo;
    private b6;
    dl: boolean;
    protected h5(a: Series): void;
    protected ik(): void;
    ij(): void;
    protected get_cw(): boolean;
    readonly cw: boolean;
    protected get_isUsableInLegend(): boolean;
    readonly isUsableInLegend: boolean;
    protected ip(): void;
    il(): void;
    protected iv(): void;
    iw(): void;
    protected de: boolean;
    protected df: boolean;
    protected c8(): boolean;
    protected ix(a: boolean): void;
    private b7;
    protected dn: boolean;
    protected readonly dp: boolean;
    protected iy(a: any, b: string, c: any, d: any): void;
    h3(): void;
    protected cg(): boolean;
    protected get_cv(): boolean;
    protected readonly cv: boolean;
    cd: boolean;
    protected h0(a: Series): void;
    bn: SyncLink;
    private bm;
    bs: SeriesViewer;
    private br;
    bq: XamDataChart;
    readonly d3: (sender: any, e: NotifyCollectionChangedEventArgs) => void;
    readonly a4: (sender: any, e: PropertyUpdatedEventArgs) => void;
    readonly b0: (sender: any, e: RectChangedEventArgs) => void;
    itemsSource: IEnumerable;
    static readonly kc: DependencyProperty;
    bz: IFastItemsSource;
    e0: (sender: any, e: FastItemsSourceEventArgs) => void;
    protected hy(a: FastItemsSourceEventAction, b: number, c: number, d: string): void;
    legend: IChartLegend;
    static readonly kg: DependencyProperty;
    jv: Control;
    private ju;
    fw(): any;
    protected jt(): Control;
    aw: IChartLegend;
    private av;
    ly: Visibility;
    legendItemBadgeTemplate: DataTemplate;
    static readonly kd: DependencyProperty;
    bl: StandardLegendItems;
    bj: StandardLegendBadges;
    bk: StandardLegendItems;
    legendItemTemplate: DataTemplate;
    static readonly ke: DependencyProperty;
    jx: DataTemplate;
    static readonly j6: DependencyProperty;
    fh: number;
    static readonly j9: DependencyProperty;
    jq(): void;
    h2(): void;
    protected jn(): void;
    bu: (time: number) => number;
    bv: (time: number) => number;
    cf: boolean;
    fi: number;
    ez: number;
    ca(): boolean;
    jk(): void;
    eu: number;
    fx: any;
    k4: Brush;
    k2: Brush;
    k7: Brush;
    k3: Brush;
    es: number;
    ey: number;
    lb: PenLineCap;
    la: DoubleCollection;
    toolTip: any;
    cu: boolean;
    cp: boolean;
    protected get_cq(): boolean;
    readonly cq: boolean;
    ev: number;
    k9: Color;
    du: boolean;
    ew: number;
    ex: number;
    b9: boolean;
    d7: number;
    d6: number;
    jm(): void;
    private b5;
    co: boolean;
    dd: boolean;
    as(a: any): DataContext;
    fj: number;
    bp: TransitionInSpeedType;
    protected bo(): TransitionInSpeedType;
    fn: any;
    ja(): void;
    jf(): void;
    i9(): void;
    ht(): void;
    ia(): void;
    private static _d1;
    static d1(a: (arg1: number) => number, b: number, c: number): IEnumerable$1<number>;
    static d0(a: (arg1: number) => number, b: number): IEnumerable$1<number>;
    ld: PenLineCap;
    lc: PenLineCap;
    private a7;
    a8(): SeriesComponentsForView;
    jg(a: Canvas): void;
    eq(): number;
    er(): number;
    private b8;
    protected get_dq(): boolean;
    protected set_dq(a: boolean): void;
    protected dq: boolean;
    readonly db: boolean;
    c7: boolean;
    at(a: any, b: Point): HighlightingInfo;
    au(a: any, b: Point): HighlightingInfo;
    iq(a: Point, b: any, c: any): void;
    jj(a: Point): void;
    private hq;
    private hu;
    hp(a: IChartLegend, b: IChartLegend): void;
    private hr;
    i5(a: IFastItemsSourceProvider): void;
    i4(a: IFastItemsSourceProvider): void;
    protected ax(): IChartLegend;
    protected dc(): boolean;
    da(a: boolean): boolean;
    protected hz(a: Axis): void;
    protected i3(a: Axis): void;
    a9(): SeriesComponentsFromView;
    jo(a: Canvas): void;
    ji(a: Point, b: (arg1: any) => void): void;
    protected get_ds(): boolean;
    readonly ds: boolean;
    iz(a: RenderingContext, b: RenderingContext): void;
    i1(a: Rect): void;
    h9(a: NotifyCollectionChangedEventArgs): void;
    ih(a: number, b: any, c: any): void;
    id(): void;
    ie(a: number, b: any): void;
    ig(a: number, b: any): void;
    jl(): void;
    fz: any;
    e2: (arg1: any) => any;
    dh(a: Point, b: boolean): boolean;
    protected _coercionMethods: any;
    protected get_coercionMethods(): any;
    protected set_coercionMethods(a: any): void;
    coercionMethods: any;
    private b4;
    protected get_expectFunctions(): boolean;
    protected set_expectFunctions(a: boolean): void;
    expectFunctions: boolean;
    ar(a: Point, b: boolean): DataContext;
    private bb;
    be: SeriesHitTestMode;
    protected bd(): SeriesHitTestMode;
    private ba;
    bc: SeriesHitTestMode;
    protected bw(a: string): IFastItemColumn$1<number>;
    protected bx(a: string): IFastItemColumn$1<number>;
    protected by(a: string): IFastItemColumn$1<any>;
    protected readonly lx: Rect;
    protected get_cz(): boolean;
    readonly cz: boolean;
    protected get_cy(): boolean;
    readonly cy: boolean;
    jh(a: Brush, b: Brush): void;
    b3: (arg1: SeriesViewer) => void;
    protected hx(a: any, b: any): void;
    fo(): any;
    protected h4(a: any): void;
    private le;
    ib(a: Point): void;
    protected io(a: Point): void;
    ic(): void;
    ii(): void;
    am(a: Axis): Axis;
    ag(): Axis[];
    eh(): number;
    static ei(a: IList$1<number>, b: ISortingAxis): number;
    im(): void;
    private d4;
    d8: number;
    private d5;
    et: number;
    protected jp(): void;
    fr(a: any): any;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class MarkerSeries extends Series {
    static $t: Type;
    lz: MarkerSeriesView;
    constructor();
    it(a: SeriesView): void;
    protected get_hasMarkers(): boolean;
    k5(): Brush;
    k6(): Brush;
    jy(): DataTemplate;
    l0: MarkerType;
    mj: DataTemplate;
    mh: DataTemplate;
    mi: DataTemplate;
    private static mg;
    static readonly mk: DataTemplate;
    mw: Brush;
    static readonly mo: DependencyProperty;
    mu: Brush;
    mx: Brush;
    mv: Brush;
    my: Style;
    l4: boolean;
    l2(): boolean;
    protected iy(a: any, b: string, c: any, d: any): void;
    static l9(a: MarkerType): string;
    static l1(a: Series, b: MarkerType): MarkerType;
    protected jn(): void;
    protected h4(a: any): void;
    protected l3(a: Point, b: boolean): boolean;
    ar(a: Point, b: boolean): DataContext;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class SyncLink extends FrameworkElement implements INotifyPropertyChanged, IFastItemsSourceProvider {
    static $t: Type;
    constructor();
    ai: string;
    protected am(a: any, b: string, c: any, d: any): void;
    releaseFastItemsSource(a: IEnumerable): IFastItemsSource;
    static ah: (arg1: IEnumerable) => IFastItemsSource;
    private static ad;
    getFastItemsSource(a: IEnumerable): IFastItemsSource;
    ae(a: IEnumerable): IFastItemsSource;
    private af;
    aq: Rect;
    private ar;
    private as;
    readonly ag: IList$1<SeriesViewer>;
    ab: ChartCollection;
    private aj;
    ak(a: SeriesViewer, b: Point): void;
    al(a: SeriesViewer, b: Rect): void;
    ao(a: SeriesViewer, b: Rect): void;
    ap(a: SeriesViewer, b: Rect, c: boolean): void;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected an(a: string, b: any, c: any): void;
}
/**
 * @hidden
 */
export declare class SyncLinkManager extends Base {
    static $t: Type;
    private static b;
    static instance(): SyncLinkManager;
    private d;
    readonly e: number;
    constructor();
    getLink(a: string): SyncLink;
    releaseLink(a: SyncLink): void;
}
/**
 * @hidden
 */
export declare class SyncManager extends Base {
    static $t: Type;
    static e(a: SeriesViewer): void;
    static c(a: SeriesViewer): void;
    static b(a: SeriesViewer, b: string, c: string): void;
    static d(a: DependencyObject, b: SyncSettings): void;
    static a(a: DependencyObject): SyncSettings;
}
/**
 * @hidden
 */
export declare class ChartCollection extends ObservableCollection$1<SeriesViewer> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class SeriesCollection extends ObservableCollection$1<Series> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class ChartCursorEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Series, c: any);
    toString(): string;
    private _item;
    item: any;
    private _series;
    series: Series;
    private _seriesViewer;
    seriesViewer: SeriesViewer;
    readonly chart: XamDataChart;
}
/**
 * @hidden
 */
export declare class DataChartMouseButtonEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Series, c: any, d: MouseButtonEventArgs);
    toString(): string;
    protected g: MouseButtonEventArgs;
    handled: boolean;
    getPosition(a: UIElement): Point;
    readonly originalSource: any;
    private _item;
    item: any;
    private _series;
    series: Series;
    private _chart;
    chart: SeriesViewer;
}
/**
 * @hidden
 */
export declare class ChartMouseEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Series, c: any, d: MouseEventArgs);
    toString(): string;
    private f;
    getPosition(a: UIElement): Point;
    readonly originalSource: any;
    private _item;
    item: any;
    private _series;
    series: Series;
    private _chart;
    chart: SeriesViewer;
}
/**
 * @hidden
 */
export declare class AxisComponentsForView extends Base {
    static $t: Type;
    a: AxisLabelPanelBase;
}
/**
 * @hidden
 */
export declare class AxisLabelPanelBaseView extends Base {
    static $t: Type;
    protected a: AxisLabelPanelBase;
    av: Path;
    constructor(a: AxisLabelPanelBase);
    aa(a: FrameworkElement, b: Rect, c: number, d: number, e: number, f: number): void;
    z(a: Rectangle, b: TextBlock, c: LabelPosition, d: Rect, e: number, f: number, g: number, h: number): void;
    ad(a: FrameworkElement): void;
    ag(a: any): void;
    ah(a: any, b: Size): void;
    ai(a: FrameworkElement, b: number): void;
    aq(a: Rectangle, b: TextBlock, c: LabelPosition, d: Rect, e: number, f: number, g: number, h: number, i: number): void;
    x(a: TextBlock, b: number, c: number, d: number): string;
    ae(): void;
    g(): IEnumerable$1<any>;
    l(a: any): number;
    n(a: any): number;
    am(): void;
    m(a: any): number;
    w(a: any): number;
    ac(): void;
    aj(): void;
    protected e: RenderingContext;
    f(): RenderingContext;
    ak(a: RenderingContext): void;
    y(): void;
    protected al(): void;
    private au;
    protected ao(a: TextBlock): void;
    an(): void;
    d(): FontInfo;
    as(): Brush;
    private c;
    af(): void;
    private h;
    private ar;
    private i;
    j(): number;
    k(): number;
    protected ap(): void;
    ab(a: Size): void;
    protected aw(): Thickness;
    v(): number;
    s(): number;
    t(): number;
    u(): number;
    at(): GeometryCollection;
    b(): PathRenderingInfo;
    r(): number;
    p(): number;
    q(): number;
    o(): number;
}
/**
 * @hidden
 */
export declare class AxisView extends Base implements ISchedulableRender {
    static $t: Type;
    protected a: Axis;
    constructor(a: Axis);
    ag(): void;
    ai(a: any): void;
    a7: Path;
    a8: Path;
    ba: Path;
    a9: Path;
    ax(): TextBlock;
    aq(a: TextBlock): void;
    as(a: TextBlock): void;
    ar(a: TextBlock): void;
    bc(): Rectangle;
    p(a: Rectangle): void;
    r(a: Rectangle): void;
    q(a: Rectangle): void;
    aj(): void;
    m(): boolean;
    readonly index: number;
    ad(): void;
    ab(): void;
    x(): void;
    av(a: Visibility): void;
    an(): void;
    w(a: AxisLabelSettings): void;
    private b;
    c(): AxisComponentsFromView;
    z(a: GeometryCollection): void;
    ay(): GeometryCollection;
    e(): PathRenderingInfo;
    a1(): GeometryCollection;
    az(): GeometryCollection;
    f(): PathRenderingInfo;
    a0(): GeometryCollection;
    g(): PathRenderingInfo;
    protected readonly d: AxisLabelPanelBase;
    at(a: Axis, b: Rect, c: Rect): void;
    y(): void;
    ap(a: number): void;
    au(a: List$1<any>, b: List$1<LabelPosition>): void;
    ao(a: number): void;
    v(): void;
    private h;
    o(a: number): string;
    n(dataItem_: any): any;
    protected k: RenderingContext;
    j: RenderingContext;
    af(a: RenderingContext, b: RenderingContext): void;
    private _isDirty;
    isDirty: boolean;
    protected ae(): void;
    undirty(a: boolean): void;
    private bb;
    protected al(a: boolean): void;
    postRender(): void;
    private a5;
    protected am(): void;
    ac(): void;
    aa(a: SeriesViewer): void;
    u(a: SeriesViewer): void;
    i(): FontInfo;
    l(): boolean;
    ak(): void;
    t(): void;
    aw(): void;
    s(a: AxisLabelSettings, b: string): void;
    preRender(): void;
    isValid(): boolean;
    a2(a: TextBlock): Point;
    a3(): Point;
    a6(): Rect;
    a4(a: TextBlock): Point;
    bd(a: TextBlock): Thickness;
    ah(): void;
}
/**
 * @hidden
 */
export declare class CategoryAxisBaseView extends AxisView {
    static $t: Type;
    protected be: CategoryAxisBase;
    constructor(a: CategoryAxisBase);
    o(a: number): string;
    bf(a: List$1<any>): number;
}
/**
 * @hidden
 */
export declare class HorizontalAxisLabelPanelBaseView extends AxisLabelPanelBaseView {
    static $t: Type;
    protected ax: HorizontalAxisLabelPanelBase;
    constructor(a: HorizontalAxisLabelPanelBase);
    az(): void;
    ay(): boolean;
    a0(a: List$1<Rect>): void;
}
/**
 * @hidden
 */
export declare class NumericAxisBaseView extends AxisView {
    static $t: Type;
    protected be: NumericAxisBase;
    constructor(a: NumericAxisBase);
    bf(): void;
    o(a: number): string;
}
/**
 * @hidden
 */
export declare class VerticalAxisLabelPanelView extends AxisLabelPanelBaseView {
    static $t: Type;
    protected ax: VerticalAxisLabelPanel;
    constructor(a: VerticalAxisLabelPanel);
    ay(): void;
    d(): FontInfo;
    protected aw(): Thickness;
    as(): Brush;
    az(a: List$1<Rect>, b: number): void;
}
/**
 * @hidden
 */
export declare class XamDataChartView extends SeriesViewerView {
    static $t: Type;
    constructor(a: XamDataChart);
    protected fa: XamDataChart;
    fe(a: any): void;
    protected dh(): void;
    du(): void;
    fj: Brush;
    ff: Brush;
    fg: Brush;
    fi: Brush;
    fh: Brush;
    fc: number;
    fd: number;
    protected dr(): void;
    fb: FontInfo;
}
/**
 * @hidden
 */
export declare class SeriesView extends Base implements ISchedulableRender, IProvidesViewport {
    static $t: Type;
    protected e: Series;
    p: boolean;
    constructor(a: Series);
    getDefaultTooltipTemplate(): string;
    am(): void;
    d: DataContext;
    ap(): void;
    getEffectiveViewport(): Rect;
    aw(): void;
    ag(): void;
    readonly t: DomRenderer;
    private _isDirty;
    isDirty: boolean;
    protected get_index(): number;
    readonly index: number;
    protected an(): void;
    undirty(a: boolean): void;
    private bt;
    ar(): void;
    private bk;
    bn(): Brush;
    s: number;
    private r;
    protected a1(a: boolean): void;
    private bo;
    protected ba(a: any, b: number, c: boolean): void;
    protected bd(a: any, b: number, c: boolean): void;
    protected x(a: number, b: boolean): any;
    protected y(a: number): any;
    protected z(a: number): any;
    protected bb(a: any, b: number): void;
    protected be(a: any, b: number): void;
    protected bc(a: any, b: number): void;
    protected bf(a: any, b: number): void;
    protected a7(a: boolean): void;
    protected a8(): void;
    protected a9(): void;
    private bj;
    protected bm(a: number): Brush;
    protected bl(): Brush;
    protected a3(a: RenderingContext, b: boolean): void;
    protected a2(a: RenderingContext, b: boolean): void;
    au(): void;
    aj(): void;
    ak(): void;
    private f;
    g(): SeriesComponentsFromView;
    a6(a: Canvas): void;
    q(): boolean;
    at(): void;
    as(): void;
    a4(): void;
    ae(): void;
    a5(): void;
    af(): void;
    c(a: any): DataContext;
    protected h: RenderingContext;
    protected i: RenderingContext;
    ao(a: RenderingContext, b: RenderingContext): void;
    private bp;
    br: Rect;
    bq: Rect;
    protected get_bs(): Rect;
    readonly bs: Rect;
    private j;
    n: boolean;
    ah(a: SeriesViewer): void;
    a: CanvasRenderScheduler;
    ad(a: SeriesViewer): void;
    postRender(): void;
    protected ax(): void;
    b(a: number): DataContext;
    az(a: RenderSurface): void;
    ai(a: any): void;
    bg(): void;
    aq(): void;
    av(): void;
    getViewInfo(a: Rect, b: Rect): {
        p0: Rect;
        p1: Rect;
    };
    l(): boolean;
    protected o: boolean;
    bh(): void;
    a0(): void;
    protected ac(): void;
    al(): void;
    preRender(): void;
    isValid(): boolean;
    k: boolean;
    m: boolean;
    ay(a: RenderSurface): void;
    aa: string;
    bi(type_: StandardLegendItems): DataTemplate;
}
/**
 * @hidden
 */
export declare abstract class MarkerSeriesView extends SeriesView {
    static $t: Type;
    protected by: MarkerSeries;
    private b2;
    private b4;
    private b3;
    constructor(a: MarkerSeries);
    ap(): void;
    cd(): void;
    ck(a: boolean): void;
    protected b1: List$1<Marker>;
    bx(): Marker;
    abstract cc(a: (arg1: Marker) => void): void;
    cg(a: Marker): void;
    ci(a: Marker): void;
    ch(a: Marker): void;
    bz(): boolean;
    cb(): void;
    b5(): void;
    cm(a: Marker): Rect;
    b8(a: string): void;
    b9(): void;
    b6(): void;
    ca(): void;
    b7(): void;
    cj(): void;
    b0: boolean;
    protected be(a: any, b: number): void;
    private bu;
    protected bf(a: any, b: number): void;
    b(a: number): DataContext;
    private cl;
    protected a2(a: RenderingContext, b: boolean): void;
    ce(a: HashPool$2<any, Marker>): void;
    cf(a: Pool$1<Marker>): void;
    bv(a: Point): Marker;
    private bw;
}
/**
 * @hidden
 */
export declare class ChartAxisRangeChangedEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Axis, c: number, d: number, e: number, f: number);
    private _chart;
    chart: SeriesViewer;
    private _axis;
    axis: Axis;
    private _oldMinimumValue;
    oldMinimumValue: number;
    private _minimumValue;
    minimumValue: number;
    private _oldMaximumValue;
    oldMaximumValue: number;
    private _maximumValue;
    maximumValue: number;
}
