/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, EnumUtil, fromEnum, markType, getInstanceType } from "igniteui-react-core/ES2015/type";
import { IAxisVisualDataManager_$type } from "./IAxisVisualDataManager";
import { TextBlock } from "igniteui-react-core/ES2015/TextBlock";
import { VisualExportHelper } from "./VisualExportHelper";
import { ChartTitleVisualData } from "./ChartTitleVisualData";
import { HorizontalAlignment_$type } from "igniteui-react-core/ES2015/HorizontalAlignment";
import { VerticalAlignment_$type } from "igniteui-react-core/ES2015/VerticalAlignment";
import { AxisTitlePosition_$type } from "./AxisTitlePosition";
import { RectData } from "igniteui-react-core/ES2015/RectData";
import { AppearanceHelper } from "igniteui-react-core/ES2015/AppearanceHelper";
import { AxisVisualData } from "./AxisVisualData";
import { PathVisualData } from "igniteui-react-core/ES2015/PathVisualData";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { RectangleVisualData } from "igniteui-react-core/ES2015/RectangleVisualData";
import { AxisLabelVisualData } from "./AxisLabelVisualData";
import { PointData } from "igniteui-react-core/ES2015/PointData";
import { Size } from "igniteui-react-core/ES2015/Size";
import { SizeData } from "igniteui-react-core/ES2015/SizeData";
import { FontUtil } from "igniteui-react-core/ES2015/FontUtil";
/**
 * @hidden
 */
export class AxisVisualDataManager extends Base {
    c(a) {
        return a;
    }
    d(a, b) {
        let c = VisualExportHelper.a(b);
        return c;
    }
    a(a, b, c, d) {
        let e = new ChartTitleVisualData();
        let f = a.a2;
        let g = f.a6();
        e.viewport = RectData.b(g);
        let h = this.d(a, d);
        e.textPlotArea = RectData.b(h);
        let i = d._visibility == 0 && d.x != null;
        let j = a.at.ae.d();
        let k = f.bd(d);
        let l = this.b(a, d, j);
        let m = AppearanceHelper.c(d, l);
        m.marginLeft = k.c;
        m.marginRight = k.d;
        m.marginTop = k.e;
        m.marginBottom = k.b;
        m.fontStretch = "Normal";
        m.textWrapping = "Wrap";
        m.visibility = i;
        if (a.bc != null) {
            m.horizontalAlignment = EnumUtil.getName(HorizontalAlignment_$type, a.bc.horizontalAlignment);
            m.verticalAlignment = EnumUtil.getName(VerticalAlignment_$type, a.bc.verticalAlignment);
            m.textPosition = EnumUtil.getName(AxisTitlePosition_$type, a.bc.position);
        }
        else {
            m.horizontalAlignment = EnumUtil.getName(HorizontalAlignment_$type, (0));
            m.verticalAlignment = EnumUtil.getName(VerticalAlignment_$type, (1));
            m.textPosition = EnumUtil.getName(AxisTitlePosition_$type, (0));
        }
        e.appearance = m;
        return e;
    }
    exportVisualData(a) {
        let b = new AxisVisualData();
        b.viewport = RectData.b(a.i0);
        b.labelsViewport = RectData.b(a.a2.a6());
        b.type = this.c(getInstanceType(a).typeName);
        b.name = a.name;
        let c = new PathVisualData(1, "axisLine", a.a2.a7);
        b.axisLine = c;
        b.tickMarks = new PathVisualData(1, "tickMarks", a.at.ae.av);
        if (!a.at.ab.contains(a.at.ae.av)) {
            b.tickMarks.data.clear();
        }
        b.minorLines = new PathVisualData(1, "minorLines", a.a2.a9);
        b.majorLines = new PathVisualData(1, "majorLines", a.a2.a8);
        b.strips = new PathVisualData(1, "strips", a.a2.ba);
        if (a.f6 != null) {
            let d = this.a(a, a.bf, b.type, a.hj);
            b.title = d;
        }
        else {
            b.title = null;
        }
        let e = a.bf.getFontInfo();
        if (a.aw != null && a.aw.textStyle != null) {
            e = a.aw.g(a.bf.bn.i.af);
        }
        let f, g, h, i;
        let j = a.at.ae.av.aj.c;
        for (let k = 1; k < j.count; k++) {
            let l = j._inner[k];
            let m = j._inner[k - 1];
            f = l.c.x - l.b.x;
            g = l.c.y - l.b.y;
            h = m.c.x - m.b.x;
            i = m.c.y - m.b.y;
            if (1 == k) {
                b.tickMarksLength = Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2));
            }
        }
        let n = a.at.a2;
        let o = a.at.ae.g();
        for (let p = 0; p < n.count; p++) {
            let q = a.at.a2._inner[p];
            let r = a.at.a1._inner[p];
            let s = ((() => {
                let $ret = new AxisLabelVisualData();
                $ret.labelPosition = q.c;
                $ret.labelValue = r;
                $ret.panelPosition = PointData.b(a.a2.a3());
                return $ret;
            })());
            let t = new List$1(TextBlock.$, 0);
            for (let u of fromEnum(o)) {
                t.add(u);
            }
            if (p < t.count) {
                let v = this.b(a, t._inner[p], e);
                s.appearance = AppearanceHelper.c(t._inner[p], v);
                s.position = PointData.b(a.a2.a2(t._inner[p]));
                s.size = SizeData.b(new Size(1, t._inner[p].m, t._inner[p].l));
            }
            b.labels.add(s);
        }
        let w = null;
        for (let x = 0; x < a.bm.a.count; x++) {
            if (w == null) {
                w = new List$1(RectangleVisualData.$, 0);
            }
            let y = new RectangleVisualData(1, "annotationBacking_" + x, a.bm.item(x));
            y.appearance.canvasLeft = a.bm.item(x).n;
            y.appearance.canvasTop = a.bm.item(x).o;
            w.add(y);
        }
        b.annotationBackings = w;
        return b;
    }
    b(a, b, c) {
        return FontUtil.getFontInfo(a.bf.bn.i.af, b, c);
    }
}
AxisVisualDataManager.$t = markType(AxisVisualDataManager, 'AxisVisualDataManager', Base.$, [IAxisVisualDataManager_$type]);
