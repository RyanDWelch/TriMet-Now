/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { FastItemDateTimeColumn } from "igniteui-react-core/ES2015/FastItemDateTimeColumn";
import { CategoryXAxis } from "./CategoryXAxis";
import { ITimeRangeSelectorAxis_$type } from "./ITimeRangeSelectorAxis";
import { TimeAxisLabelFormatCollection } from "./TimeAxisLabelFormatCollection";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { ScalerParams } from "./ScalerParams";
import { EventArgs, runOn, delegateCombine, typeCast, Date_$type, markType } from "igniteui-react-core/ES2015/type";
import { IFastItemsSource_$type } from "igniteui-react-core/ES2015/IFastItemsSource";
import { TimeAxisBase } from "./TimeAxisBase";
import { TimeXAxis } from "./TimeXAxis";
import { AxisRangeChangedEventArgs } from "./AxisRangeChangedEventArgs";
import { truncate } from "igniteui-react-core/ES2015/number";
import { dateMaxValue, dateMinValue } from "igniteui-react-core/ES2015/date";
/**
 * @hidden
 */
export class OrdinalTimeXAxis extends CategoryXAxis {
    constructor() {
        super();
        this.lo = dateMaxValue();
        this.ln = dateMinValue();
        this.ls = dateMaxValue();
        this.lr = dateMinValue();
        this.lx = null;
        this.ll = null;
        this.lj = null;
        this.l4 = 0;
        this.lq = dateMinValue();
        this.lp = dateMaxValue();
        this.visibleRangeChanged = null;
        FastItemDateTimeColumn.o();
        this.lj = new TimeAxisLabelFormatCollection();
        let a = this.lk;
        a.collectionChanged = delegateCombine(a.collectionChanged, runOn(this, this.l6));
        this.la = 0;
    }
    dx(a, b, c) {
        return this.dv(a, new ScalerParams(0, b, c, this.b8, this.iv()));
    }
    dw(a, b, c) {
        return this.dv(a, b);
    }
    dv(a, b) {
        let c = this.k9;
        let d = this.la;
        let e = this.k9 - this.la;
        let f = e >= 1 ? (a - d) / (c - d) : e == 0 ? 0.5 : NaN;
        if (this.b9) {
            f = 1 - f;
        }
        let g = b.d;
        let h = b.e;
        return g.left + g.width * (f - h.left) / h.width;
    }
    gl(a, b, c, d, e) {
        let f = this.kv(a);
        let g = f != null;
        for (let h = 0; h < b.count; h++) {
            for (let i = c; i < d; i++) {
                let j = g ? f[i] : a.item(i);
                j[h] = this.dv(j[h], e);
            }
        }
    }
    gm(a, b, c, d) {
        for (let e = b; e < c; e++) {
            a.item(e, this.dv(a.item(e), d));
        }
    }
    d0(a, b, c) {
        return this.dy(a, new ScalerParams(0, b, this.i0, this.b8, this.iv()));
    }
    getUnscaledValue3(a, b, c, d) {
        return this.dy(a, new ScalerParams(0, b, this.i0, this.b8, this.iv()));
    }
    dy(a, b) {
        let c = b.e;
        let d = b.d;
        let e = c.left + (a - d.left) * c.width / d.width;
        if (this.b9) {
            e = 1 - e;
        }
        return this.la + e * (this.k9 - this.la);
    }
    dz(a, b, c) {
        return this.dy(a, b);
    }
    gn(a, b, c, d) {
        for (let e = b; e < c; e++) {
            a.item(e, this.dy(a.item(e), d));
        }
    }
    gt(a, b, c, d) {
        super.gt(a, b, c, d);
        switch (b) {
            case "FastItemsSource":
                let e = typeCast(IFastItemsSource_$type, c);
                if (e != null) {
                    e.deregisterColumn(this.lm);
                    this.lm = null;
                }
                if (this.je != null) {
                    this.lm = TimeAxisBase.ky(this.dateTimeMemberPath, this);
                }
                break;
            case "DateTimeMemberPath":
                if (this.je != null) {
                    this.je.deregisterColumn(this.lm);
                    this.lm = TimeAxisBase.ky(this.dateTimeMemberPath, this);
                }
                break;
            case "DateTimeColumn":
                this.ck();
                this.l4 = this.l3();
                break;
            case "MinimumValue":
            case "MaximumValue":
                this.ck();
                this.g4();
                break;
        }
    }
    get actualMinimumValue() {
        return this.lo;
    }
    set actualMinimumValue(a) {
        this.lo = a;
    }
    get actualMaximumValue() {
        return this.ln;
    }
    set actualMaximumValue(a) {
        this.ln = a;
    }
    get visibleMinimum() {
        return this.ls;
    }
    set visibleMinimum(a) {
        this.ls = a;
    }
    get visibleMaximum() {
        return this.lr;
    }
    set visibleMaximum(a) {
        this.lr = a;
    }
    l7() {
        if (this.lm == null || this.lm.count == 0 || this.lm.count < this.la - 1) {
            this.actualMinimumValue = dateMinValue();
            this.actualMaximumValue = dateMaxValue();
            return;
        }
        let a = Math.max(0, Math.min(this.la, this.lm.count - 1));
        let b = Math.max(0, Math.min(this.k9, this.lm.count - 1));
        let c = +(this.actualMinimumValue) != +(this.lm.item(a)) || +(this.actualMaximumValue) != +(this.lm.item(b));
        if (c) {
            let d = this.actualMinimumValue;
            let e = this.actualMaximumValue;
            this.actualMinimumValue = this.lm.item(a);
            this.actualMaximumValue = this.lm.item(b);
            this.l8();
        }
    }
    l8() {
        if (this.lm == null || this.lm.count == 0 || this.bf == null) {
            let a = +(this.visibleMinimum) != +(this.actualMinimumValue) || +(this.visibleMaximum) != +(this.actualMaximumValue);
            this.visibleMinimum = this.actualMinimumValue;
            this.visibleMaximum = this.actualMaximumValue;
            if (a && this.visibleRangeChanged != null) {
                this.visibleRangeChanged(this, EventArgs.empty);
            }
            return;
        }
        let b = new ScalerParams(1, this.bf.m4, this.bf.m3, this.b8);
        let c = truncate(Math.ceil(this.dy(this.bf.m3.left, b)));
        let d = truncate(Math.ceil(this.dy(this.bf.m3.right, b)));
        let e = c >= 0 && c < this.lm.count ? this.lm.item(c) : this.actualMinimumValue;
        let f = d >= 0 && d < this.lm.count ? this.lm.item(d) : this.actualMaximumValue;
        let g = +(this.visibleMinimum) != +e || +(this.visibleMaximum) != +f;
        this.visibleMinimum = e;
        this.visibleMaximum = f;
        if (g && this.visibleRangeChanged != null) {
            this.visibleRangeChanged(this, EventArgs.empty);
        }
    }
    get dateTimeMemberPath() {
        return this.lx;
    }
    set dateTimeMemberPath(a) {
        let b = this.dateTimeMemberPath;
        if (a != b) {
            this.lx = a;
            this.gz("DateTimeMemberPath", b, this.dateTimeMemberPath);
        }
    }
    get lm() {
        return this.ll;
    }
    set lm(a) {
        if (this.ll != a) {
            let b = this.ll;
            this.ll = a;
            this.gz("DateTimeColumn", b, this.ll);
        }
    }
    hh(a, b) {
        super.hh(a, b);
        this.l8();
    }
    getWindowRectForSelection(a, b) {
        if (this.lm == null) {
            return Rect.empty;
        }
        let c = a > b;
        let d = c ? b : a;
        let e = c ? a : b;
        let f = -1;
        while (++f < this.lm.count && this.lm.item(f) < d) {
            ;
        }
        let g = this.lm.count;
        while (--g >= 0 && this.lm.item(g) > e) {
            ;
        }
        let h = new ScalerParams(0, new Rect(0, 0, 0, 1, 1), new Rect(0, 0, 0, 1, 1), this.b8, this.bf.mu);
        let i = this.dv(f, h);
        let j = this.dv(g + 1, h);
        return new Rect(0, i, NaN, Math.max(0, j - i), NaN);
    }
    get lk() {
        return this.lj;
    }
    l6(a, b) {
        this.g5(false);
    }
    gv(a) {
        super.gv(a);
        this.dateTimeMemberPath = a;
    }
    e5(a) {
        if (this.ar != null) {
            return this.ar(a);
        }
        if (!(typeCast(Date_$type, a) !== null)) {
            return super.e5(a);
        }
        let b = TimeXAxis.mm(a, this.l5, this.lk, this.eq);
        return b == null ? super.e5(a) : b;
    }
    fi(a) {
        let b = 0;
        if (this.categoryMode == 0) {
            b = truncate(Math.round(a));
        }
        else {
            b = truncate(Math.floor(a));
        }
        if (b < 0 || b > this.jy - 1) {
            return super.fi(a);
        }
        let c = this.lm.item(b);
        let d = this.e5(c);
        if (d == null) {
            return null;
        }
        return d.toString();
    }
    get l5() {
        return +(this.visibleMaximum) - +(this.visibleMinimum);
    }
    kx() {
        return this.lm;
    }
    hg(a, b) {
        super.hg(a, b);
        this.l8();
    }
    k3(a, b) {
        let c = this.categoryMode == 0 ? 0 : 0.5;
        return super.k3(a + c, b);
    }
    k2(a, b, c, d) {
        return b;
    }
    l3() {
        if (this.lm == null || this.lm.count < 2) {
            return (0);
        }
        return TimeXAxis.mu((a) => this.lm.item(a), this.lm.count);
    }
    itemLabelFormat() {
        return TimeXAxis.mr(this.l4);
    }
    get minimumValue() {
        return this.lq;
    }
    set minimumValue(a) {
        let b = this.minimumValue;
        if (+a != +b) {
            this.lq = a;
            this.gt(this, "MinimumValue", b, this.minimumValue);
        }
    }
    get maximumValue() {
        return this.lp;
    }
    set maximumValue(a) {
        let b = this.maximumValue;
        if (+a != +b) {
            this.lp = a;
            this.gt(this, "MaximumValue", b, this.maximumValue);
        }
    }
    cm() {
        if (+(this.minimumValue) == +(dateMaxValue()) || +(this.maximumValue) == +(dateMinValue())) {
            return super.cm();
        }
        if (this.cf && this.cn) {
            this.a9 = this.a8();
        }
        if (this.je == null || this.lm == null) {
            return false;
        }
        let a = this.la;
        if (+(this.minimumValue) != +(dateMinValue())) {
            let b = -1;
            while (b++ <= this.lm.count) {
                if (this.lm.item(b) >= this.minimumValue) {
                    break;
                }
            }
            a = b;
        }
        let c = this.categoryMode == 0 ? this.je.count - 1 : this.je.count;
        if (+(this.maximumValue) != +(dateMaxValue())) {
            let d = this.je.count;
            while (d-- > 0) {
                if (this.lm.item(d) <= this.maximumValue) {
                    break;
                }
            }
            c = d;
        }
        if (a != this.la || c != this.k9) {
            let e = new AxisRangeChangedEventArgs(0, this.la, a, this.k9, c);
            this.la = a;
            this.k9 = c;
            this.g0(e);
            this.l7();
            this.ka();
            return true;
        }
        return false;
    }
    kj(a) {
        super.kj(a);
        this.cl(true);
    }
    get isVertical() {
        return this.ce;
    }
    j$c(a, b) {
        return this.dy.apply(this, arguments);
    }
    j$b(a, b) {
        return this.dv.apply(this, arguments);
    }
    j$d(a, b, c, d, e) {
        this.gl.apply(this, arguments);
    }
    j$e(a, b, c, d) {
        this.gm.apply(this, arguments);
    }
    j$f(a, b, c, d) {
        this.gn.apply(this, arguments);
    }
    get j$a() {
        return this.b8;
    }
}
OrdinalTimeXAxis.$t = markType(OrdinalTimeXAxis, 'OrdinalTimeXAxis', CategoryXAxis.$, [ITimeRangeSelectorAxis_$type]);
