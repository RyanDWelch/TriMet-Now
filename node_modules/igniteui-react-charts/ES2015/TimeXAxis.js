/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { TimeAxisBase } from "./TimeAxisBase";
import { ITimeRangeSelectorAxis_$type } from "./ITimeRangeSelectorAxis";
import { TimeAxisBreakCollection } from "./TimeAxisBreakCollection";
import { TimeAxisLabelFormatCollection } from "./TimeAxisLabelFormatCollection";
import { OrderedDictionary$2 } from "./OrderedDictionary$2";
import { TimeAxisBreak } from "./TimeAxisBreak";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { TimeAxisInterval } from "./TimeAxisInterval";
import { TimeAxisIntervalCollection } from "./TimeAxisIntervalCollection";
import { EventArgs, runOn, delegateCombine, Number_$type, fromEnum, fromEn, typeCast, Date_$type, markType } from "igniteui-react-core/ES2015/type";
import { ScalerParams } from "./ScalerParams";
import { KeyValuePair$2 } from "igniteui-react-core/ES2015/KeyValuePair$2";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { NumericYAxis } from "./NumericYAxis";
import { LabelPosition } from "./LabelPosition";
import { Extensions } from "igniteui-react-core/ES2015/Extensions";
import { SortedListView$1 } from "./SortedListView$1";
import { Dictionary$2 } from "igniteui-react-core/ES2015/Dictionary$2";
import { truncate, intDivide, isNaN_ } from "igniteui-react-core/ES2015/number";
import { dateFromTicks, dateMaxValue, dateAdd, dateSubtract, dateAddMonths, dateFromValues, dateGetMonth, dateGetTimeOfDay, dateAddDays, dateAddHours, dateMinValue } from "igniteui-react-core/ES2015/date";
import { timeSpanTicks, timeSpanInit3, timeSpanInit1, timeSpanFromMilliseconds, timeSpanFromSeconds, timeSpanFromMinutes, timeSpanFromHours, timeSpanFromDays, timeSpanFromTicks, timeSpanTotalMilliseconds } from "igniteui-react-core/ES2015/timespan";
import { dateToStringFormat } from "igniteui-react-core/ES2015/dateExtended";
/**
 * @hidden
 */
export class TimeXAxis extends TimeAxisBase {
    constructor() {
        super();
        this.ml = 0;
        this.l5 = null;
        this.mb = null;
        this._omission = 0;
        this.l3 = null;
        this.l9 = null;
        this.mx = 0;
        this.mh = dateMaxValue();
        this.mg = dateMinValue();
        this.mv = 0;
        this.visibleRangeChanged = null;
        this.ab = TimeXAxis.$;
        this.omission = (0);
        this.ml = -2147483648;
        this.l5 = new TimeAxisBreakCollection();
        let a = this.breaks;
        a.collectionChanged = delegateCombine(a.collectionChanged, runOn(this, this.m0));
        this.l9 = new TimeAxisIntervalCollection();
        let b = this.intervals;
        b.collectionChanged = delegateCombine(b.collectionChanged, runOn(this, this.m1));
        this.mb = new TimeAxisLabelFormatCollection();
        let c = this.labelFormats;
        c.collectionChanged = delegateCombine(c.collectionChanged, runOn(this, this.m2));
        this.mx = (0);
    }
    dv(a, b) {
        let c = new KeyValuePair$2(TimeAxisBreak.$, Number_$type);
        let d = this.ml != -2147483648 ? this.ml : 0;
        let e = this.l3 != null ? this.l3.count : 0;
        while (d < e) {
            let f = this.l3.item1(d);
            if (f.d.getTime() <= a && f.c.getTime() >= a) {
                return NaN;
            }
            if (f.c.getTime() <= a) {
                c = new KeyValuePair$2(TimeAxisBreak.$, Number_$type, 1, f, this.l3.item(f));
                d++;
            }
            else {
                break;
            }
        }
        if (d > 0) {
            d -= 1;
        }
        if (this.ml != -2147483648) {
            this.ml = d;
        }
        let g;
        let h;
        if (c.key != null) {
            g = c.value;
            h = c.key.c;
        }
        else {
            g = 0;
            h = this.actualMinimumValue;
        }
        let fromPrecedingBreak_ = +(dateFromTicks(truncate(a))) - +h;
        let i = (fromPrecedingBreak_ / ((this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime()) - this.omission));
        let j = g + i;
        j -= b.e.left;
        j /= b.e.width;
        let k = b.d.left;
        let l = b.d.right;
        let m = b.d.width;
        if (this.categoryMode != 0) {
            let n = this.getCategorySize(b.e, b.d, b.c);
            k += n / 2;
            l -= n / 2;
            m -= n;
        }
        if (this.b8) {
            return l - m * j;
        }
        return k + m * j;
    }
    gm(a, b, c, d) {
        this.ml = 0;
        for (let e = b; e < c; e++) {
            a.item(e, this.dv(a.item(e), d));
        }
        this.ml = -2147483648;
    }
    startCursor() {
        this.ml = 0;
    }
    resetCursor() {
        this.ml = -2147483648;
    }
    dy(a, b) {
        let c = b.d.left;
        let d = b.d.width;
        if (this.categoryMode != 0) {
            let e = this.getCategorySize(b.e, b.d, b.c);
            c += e / 2;
            d -= e;
        }
        let f = b.e.left + b.e.width * (a - c) / d;
        if (this.b8) {
            f = 1 - f;
        }
        let g = new KeyValuePair$2(TimeAxisBreak.$, Number_$type);
        if (this.l3 != null) {
            for (let h of fromEnum(this.l3)) {
                if (h.value >= f && h.value <= f) {
                    return h.key.d.getTime();
                }
                if (h.value < f && h.value > g.value) {
                    g = h;
                }
            }
        }
        let precedingBreakEnd_;
        let i;
        if (g.key != null) {
            i = g.value;
            precedingBreakEnd_ = g.key.c;
        }
        else {
            i = 0;
            precedingBreakEnd_ = this.actualMinimumValue;
        }
        let portionFromPrecedingBreak_ = f - i;
        let actualRange_ = +(this.actualMaximumValue) - +(this.actualMinimumValue) - this.omission;
        return (precedingBreakEnd_.getTime() + portionFromPrecedingBreak_ * actualRange_);
    }
    get breaks() {
        return this.l5;
    }
    get labelFormats() {
        return this.mb;
    }
    gt(a, b, c, d) {
        super.gt(a, b, c, d);
        switch (b) {
            case "ActualMaximumValue":
                this.mz();
                break;
            case "DateTimeColumn":
                this.mv = this.mt();
                break;
        }
    }
    hh(a, b) {
        super.hh(a, b);
        this.my();
        this.lx();
    }
    hg(a, b) {
        super.hg(a, b);
        this.my();
        this.lx();
    }
    cm() {
        let a = super.cm();
        this.my();
        return a;
    }
    get omission() {
        return this._omission;
    }
    set omission(a) {
        this._omission = a;
    }
    mz() {
        let a = this.me(this.breaks);
        let b = (0);
        for (let c of fromEnum(a)) {
            b += (+(c.c) - +(c.d));
        }
        this.omission = b;
    }
    me(a) {
        let b = new List$1(TimeAxisBreak.$, 0);
        if (a == null || +(this.actualMaximumValue) == +(dateMaxValue())) {
            return b;
        }
        for (let c of fromEn(a)) {
            if (c.c >= this.actualMinimumValue && c.d <= this.actualMaximumValue) {
                b.add(c);
            }
            if (c.i != (0)) {
                let d = +(c.c) - +(c.d);
                let e = dateAdd(+(c.d), +(c.i));
                while (e <= this.actualMaximumValue) {
                    let f = this.mi(e, d);
                    let g = ((() => {
                        let $ret = new TimeAxisBreak();
                        $ret.d = e;
                        $ret.c = f;
                        return $ret;
                    })());
                    if (g.c >= this.actualMinimumValue && g.d <= this.actualMaximumValue) {
                        b.add(g);
                    }
                    if (dateSubtract(+(dateMaxValue()), +(c.i)) < g.d) {
                        break;
                    }
                    e = this.mi(g.d, c.i);
                }
            }
        }
        return b;
    }
    mi(a, b) {
        let c = dateFromTicks(a.getTime());
        c.setMilliseconds(c.getMilliseconds() + b);
        return c;
    }
    my() {
        this.l3 = new OrderedDictionary$2(TimeAxisBreak.$, Number_$type);
        if (+(this.actualMaximumValue) == +(dateMaxValue()) || this.breaks == null || this.breaks.count == 0 || this.bf == null) {
            return;
        }
        let a = new List$1(TimeAxisBreak.$, 1, this.me(this.breaks));
        a.aa((b, c) => b.d < c.d ? -1 : b.d > c.d ? 1 : 0);
        let b = this.bf.mq;
        let c = new ScalerParams(0, this.bf.mq, this.bf.m3, this.b8, this.bf.mu);
        let d = +(this.actualMaximumValue) - +(this.actualMinimumValue) - this.omission;
        let e = 0;
        for (let f of fromEnum(a)) {
            let g = timeSpanTicks((+(f.d) - +(this.actualMinimumValue))) / timeSpanTicks(d);
            let h = timeSpanTicks((+(f.c) - +(this.actualMinimumValue))) / timeSpanTicks(d);
            if (h < 0 || g - e > 1) {
                continue;
            }
            this.l3.addItem(f, g - e);
            e += (h - g);
        }
    }
    fi(a) {
        if (isNaN_(a)) {
            return null;
        }
        let ticks_ = truncate(a);
        let b = (new Date(ticks_));
        let c = this.e5(b);
        if (c == null) {
            return null;
        }
        return c.toString();
    }
    e5(a) {
        if (!(typeCast(Date_$type, a) !== null)) {
            return super.e5(a);
        }
        let b = TimeXAxis.mm(a, this.mx, this.labelFormats, this.eq);
        return b == null ? super.e5(a) : b;
    }
    static mm(a, b, c, d) {
        let e = null;
        if (b == (0)) {
            return null;
        }
        let f;
        if (c == null || c.count == 0) {
            f = TimeXAxis.mp(b);
        }
        else {
            for (let g of fromEnum(c)) {
                if (g.f > b) {
                    continue;
                }
                if (e == null || g.f > e.f) {
                    e = g;
                }
            }
            if (e == null) {
                return null;
            }
            f = e.b;
        }
        return dateToStringFormat(a, f, d);
    }
    get_k0() {
        return super.get_k0() || (this.intervals != null && this.intervals.count > 0);
    }
    set_k0(a) {
        super.set_k0(a);
    }
    get intervals() {
        return this.l9;
    }
    mo() {
        return TimeXAxis.mp(this.mx);
    }
    static mp(a) {
        a = Math.abs(a);
        if (a > timeSpanInit3(1825, 0, 0, 0)) {
            return "yyyy";
        }
        if (a > timeSpanInit3(365, 0, 0, 0)) {
            return "MMM yyyy";
        }
        if (a > timeSpanInit3(4, 0, 0, 0)) {
            return "MMM dd";
        }
        if (a > timeSpanInit3(1, 0, 0, 0)) {
            return "MMM dd hh:mmtt";
        }
        if (a > timeSpanInit1(0, 10, 0)) {
            return "hh:mm";
        }
        return "hh:mm:ss";
    }
    static l4() {
        if (TimeXAxis.l2 == null) {
            TimeXAxis.l2 = ((() => {
                let $ret = new OrderedDictionary$2(Number_$type, TimeAxisInterval.$);
                $ret.addItem((0), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 0;
                    $ret.f = 1;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromMilliseconds(1), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 1;
                    $ret.f = 1;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromSeconds(1), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 2;
                    $ret.f = 1;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromSeconds(30), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 2;
                    $ret.f = 30;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromMinutes(2), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 3;
                    $ret.f = 2;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromMinutes(5), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 3;
                    $ret.f = 5;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromHours(1), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 4;
                    $ret.f = 1;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromDays(1), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 5;
                    $ret.f = 1;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromDays(2), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 5;
                    $ret.f = 2;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromDays(5), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 5;
                    $ret.f = 5;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromDays(10), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 5;
                    $ret.f = 10;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromDays(30), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 7;
                    $ret.f = 1;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromDays(60), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 7;
                    $ret.f = 3;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromDays(365), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 8;
                    $ret.f = 1;
                    return $ret;
                })()));
                $ret.addItem(timeSpanFromDays(365 * 10), ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 8;
                    $ret.f = 10;
                    return $ret;
                })()));
                return $ret;
            })());
        }
        return TimeXAxis.l2;
    }
    l7() {
        if (this.cn && (this.aw == null || this.aw.angle == 0)) {
            let a = this.d7();
            let b = this.i0.width;
            let c = truncate(Math.floor(b / a));
            let d = Number.MAX_VALUE;
            let e = c == 0 ? d : timeSpanFromTicks((intDivide(timeSpanTicks(this.mx), c)));
            let f = null;
            for (let g of fromEnum(TimeXAxis.l4())) {
                f = g.value;
                if (g.key > e) {
                    break;
                }
            }
            return f;
        }
        let h = this.mx;
        if (h == (0)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 8;
                $ret.f = 1;
                return $ret;
            })());
        }
        if (h >= timeSpanFromDays(365 * 100)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 8;
                $ret.f = 10;
                return $ret;
            })());
        }
        if (h >= timeSpanFromDays(365 * 5)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 8;
                $ret.f = 1;
                return $ret;
            })());
        }
        if (h >= timeSpanFromDays(365 * 2)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 7;
                $ret.f = 3;
                return $ret;
            })());
        }
        if (h >= timeSpanFromDays(150)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 7;
                $ret.f = 1;
                return $ret;
            })());
        }
        if (h >= timeSpanFromDays(60)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 5;
                $ret.f = 10;
                return $ret;
            })());
        }
        if (h >= timeSpanFromDays(30)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 5;
                $ret.f = 5;
                return $ret;
            })());
        }
        if (h >= timeSpanFromDays(20)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 5;
                $ret.f = 2;
                return $ret;
            })());
        }
        if (h >= timeSpanFromDays(4)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 5;
                $ret.f = 1;
                return $ret;
            })());
        }
        if (h >= timeSpanFromDays(1)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 4;
                $ret.f = 12;
                return $ret;
            })());
        }
        if (h >= timeSpanFromHours(6)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 4;
                $ret.f = 1;
                return $ret;
            })());
        }
        if (h >= timeSpanFromMinutes(30)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 3;
                $ret.f = 5;
                return $ret;
            })());
        }
        if (h >= timeSpanFromMinutes(10)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 3;
                $ret.f = 2;
                return $ret;
            })());
        }
        return ((() => {
            let $ret = new TimeAxisInterval();
            $ret.b = 2;
            $ret.f = 30;
            return $ret;
        })());
    }
    l8() {
        if (this.intervals == null || this.intervals.count == 0) {
            return this.l7();
        }
        if (this.mx == (0)) {
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 8;
                $ret.f = 1;
                return $ret;
            })());
        }
        let a = null;
        for (let b of fromEnum(this.intervals)) {
            if (b.k > this.mx) {
                continue;
            }
            if (a == null || b.k > a.k) {
                a = b;
            }
        }
        return a == null ? this.l7() : a;
    }
    g6(a) {
        super.g6(a);
        let b = this.bf != null ? this.bf.mq : Rect.empty;
        let c = !b.isEmpty ? this.i0 : Rect.empty;
        let d = this.iv();
        let e = this.iu();
        let f = new ScalerParams(0, b, c, this.b8, d);
        if (this.kw == null && !this.k2() && !this.k3()) {
            return;
        }
        if (!b.isEmpty && !c.isEmpty) {
            let g = c.bottom;
            let h = g - c.top;
            if (this.ag != null) {
                let i = typeCast(NumericYAxis.$, this.ag);
                if (i != null) {
                    let j = this.g9(g, h, b, c, d, c.top, c.bottom);
                    g = j.p0;
                    h = j.p1;
                }
            }
            if (isNaN_(g)) {
                g = 0;
            }
            this.gp(this.a2.ay(), g, c, this.a2.e(), true);
            this.at.a8 = h;
            let k = truncate(Math.ceil(e.right));
            let l = truncate(Math.floor(e.left));
            let m = this.a2.a1();
            let n = this.a2.f();
            let o = this.a2.az();
            this.lx();
            let p = new List$1(Date_$type, 1, this.md());
            let q = new List$1(Number_$type, 0);
            for (let r = 0; r < p.count; r++) {
                q.add(p._inner[r].getTime());
            }
            this.gm(q, 0, q.count, f);
            for (let s = 0; s < p.count; s++) {
                let t = p._inner[s];
                let u = q._inner[s];
                let v = truncate(Math.round(u));
                if (v <= k) {
                    if (s % 2 == 0) {
                        let w = s < q.count - 1 ? q._inner[s + 1] : e.right;
                        this.hf(m, u, w, c);
                    }
                    this.he(o, u, c, n, false);
                    this.jl.add(u);
                }
                if (v >= l && v <= k) {
                    let x = this.e5(t);
                    if (x != null) {
                        this.cu.add1(x);
                        this.cv.add(new LabelPosition(u));
                    }
                }
            }
        }
        if ((this.aw == null || this.aw.visibility == 0) && this.ag != null) {
            if (this.aw != null && (this.aw.location == 4 || this.aw.location == 5)) {
                this.bf.ht();
            }
        }
        this.at.a1 = this.cu;
        this.at.a2 = this.cv;
        this.kl();
    }
    md() {
        let a = this.bf != null ? this.bf.mq : Rect.empty;
        let b = !a.isEmpty ? this.i0 : Rect.empty;
        let c = this.iv();
        let d = this.iu();
        let e = new ScalerParams(0, a, b, this.b8, c);
        let f = this.l8();
        let g = this.visibleMinimum;
        if (!this.k3() && f != null) {
            if (f.b == 7 && g.getDate() != 1) {
                g = dateAddMonths(g, 1);
                g = dateFromValues(g.getFullYear(), dateGetMonth(g), 1, 0, 0, 0, 0);
            }
            else if (f.b == 5 && dateGetTimeOfDay(g) != (0)) {
                g = dateAddDays(g, 1);
                g = dateFromValues(g.getFullYear(), dateGetMonth(g), g.getDate(), 0, 0, 0, 0);
            }
            else if (f.b == 4 && g.getMinutes() != 0) {
                g = dateAddHours(g, 1);
                g = dateFromValues(g.getFullYear(), dateGetMonth(g), g.getDate(), g.getHours(), 0, 0, 0);
            }
        }
        let h = new List$1(Date_$type, 0);
        let i = 0;
        let j = 10000;
        if (f.f == 0) {
            return h;
        }
        while (g <= this.visibleMaximum && i++ < j) {
            let k = this.mf(g);
            let l = g;
            if (k.key != null) {
                l = f.d(k.key.c);
            }
            h.add(l);
            while (g <= l) {
                g = f.c(g);
            }
        }
        return h;
    }
    mf(a) {
        if (this.l3 == null) {
            return new KeyValuePair$2(TimeAxisBreak.$, Number_$type);
        }
        for (let b of fromEnum(this.l3)) {
            if (b.key.d <= a && b.key.c >= a) {
                return b;
            }
        }
        return new KeyValuePair$2(TimeAxisBreak.$, Number_$type);
    }
    get visibleMinimum() {
        return this.mh;
    }
    set visibleMinimum(a) {
        this.mh = a;
    }
    get visibleMaximum() {
        return this.mg;
    }
    set visibleMaximum(a) {
        this.mg = a;
    }
    lx() {
        super.lx();
        if (this.bf == null || !Extensions.b(this.bf.m3)) {
            return;
        }
        let a = new ScalerParams(0, this.bf.mq, this.bf.m3, this.b8, this.bf.mu);
        let b = this.bf.m3.left;
        let c = this.bf.m3.right;
        if (this.categoryMode != 0) {
            let d = this.getCategorySize(a.e, a.d, a.c);
            b += d / 2;
            c -= d / 2;
        }
        let e = truncate(this.dy(b, a));
        let f = truncate(this.dy(c, a));
        if (e < 0 || f < 0) {
            this.mx = (0);
            return;
        }
        e = Math.min(dateMaxValue().getTime(), e);
        f = Math.min(dateMaxValue().getTime(), f);
        let g = dateFromTicks(Math.min(e, f));
        let h = dateFromTicks(Math.max(e, f));
        let i = +(this.visibleMinimum) != +g || +(this.visibleMaximum) != +h;
        this.visibleMinimum = g;
        this.visibleMaximum = h;
        if (i && this.visibleRangeChanged != null) {
            this.visibleRangeChanged(this, EventArgs.empty);
        }
        this.mx = +(this.visibleMaximum) - +(this.visibleMinimum);
    }
    js(a, b, c, d, e) {
        return 0;
    }
    i$f(a) {
        let b = this;
        if (b.i$b == null) {
            return -1;
        }
        let c = new SortedListView$1(Date_$type, this.kw, b.i$b);
        let ticks_ = a;
        let d = (new Date(ticks_));
        let e = this.lg(d, c);
        e = Math.max(0, Math.min(b.i$b.count - 1, e));
        let f = c.item(e);
        let g;
        let h;
        if (f < d) {
            g = e;
            h = g + 1;
        }
        else {
            h = e;
            g = e - 1;
        }
        if (g < 0) {
            return h;
        }
        if (h >= b.i$b.count) {
            return g;
        }
        let i = c.item(g);
        let j = c.item(h);
        let k = new ScalerParams(0, this.bf.m4, this.i0, this.b8, this.bf.mu);
        this.startCursor();
        let l = this.dv(i.getTime(), k);
        let m = this.dv(a, k);
        let n = this.dv(j.getTime(), k);
        this.resetCursor();
        if (i < this.visibleMinimum && j <= this.visibleMaximum) {
            return this.k5._inner[h];
        }
        if (j > this.visibleMaximum && i >= this.visibleMinimum) {
            return this.k5._inner[g];
        }
        if (Math.abs(l - m) < Math.abs(n - m)) {
            return this.k5._inner[g];
        }
        else {
            return this.k5._inner[h];
        }
    }
    m0(a, b) {
        this.mz();
        this.my();
        if (this.at != null) {
            this.at.ak = this.breaks.count > 0;
        }
        this.g5(false);
        for (let c of fromEnum(this.ct())) {
            c.jc(false);
        }
    }
    m2(a, b) {
        this.g5(false);
    }
    m1(a, b) {
        this.g5(false);
    }
    get_b3() {
        return false;
    }
    getWindowRectForSelection(a, b) {
        let c = +(this.actualMaximumValue) - +(this.actualMinimumValue);
        let d = timeSpanTotalMilliseconds((+a - +(this.actualMinimumValue))) / timeSpanTotalMilliseconds(c);
        let e = 1 - (timeSpanTotalMilliseconds((+(this.actualMaximumValue) - +b)) / timeSpanTotalMilliseconds(c));
        e = Math.min(1, e);
        return new Rect(0, d, NaN, Math.max(0, e - d), NaN);
    }
    getCategorySize(a, b, c) {
        if (this.mx != (0)) {
            let d = timeSpanFromTicks(truncate((timeSpanTicks(this.mx) * (a.width / (this.bf != null ? this.bf.mq.width : 1)))));
            let e = timeSpanTicks(d) / timeSpanTicks(this.mv);
            let f = b.width / 4;
            return Math.min(f, b.width / (e + 1));
        }
        return super.getCategorySize(a, b, c);
    }
    static mu(a, b) {
        let c = Math.min(5, b);
        let d = a(0);
        let e = new Dictionary$2(Number_$type, Number_$type, 0);
        let f = 0;
        let g = (0);
        for (let h = 0; h < c; h++) {
            let i = a(h);
            let j = +i - +d;
            if (!e.containsKey(j)) {
                e.addItem(j, 0);
            }
            e.item(j, e.item(j) + 1);
            if (e.item(j) > f) {
                f = e.item(j);
                g = j;
            }
            d = i;
        }
        return g;
    }
    mt() {
        if (this.kw == null || this.kw.count < 2 || this.k5 == null) {
            return (0);
        }
        return TimeXAxis.mu((a) => this.kw.item(this.k5._inner[a]), this.kw.count);
    }
    lt() {
        super.lt();
        this.mv = this.mt();
    }
    static mr(a) {
        if (a >= timeSpanFromDays(1)) {
            return "D";
        }
        return "g";
    }
    itemLabelFormat() {
        return TimeXAxis.mr(this.mv);
    }
    lf(a, b, c, d) {
        return this.le(this.visibleMinimum);
    }
    li(a, b, c, d) {
        return this.lh(this.visibleMaximum);
    }
    get isVertical() {
        return this.ce;
    }
    j$c(a, b) {
        return this.dy.apply(this, arguments);
    }
    j$b(a, b) {
        return this.dv.apply(this, arguments);
    }
    j$d(a, b, c, d, e) {
        this.gl.apply(this, arguments);
    }
    j$e(a, b, c, d) {
        this.gm.apply(this, arguments);
    }
    j$f(a, b, c, d) {
        this.gn.apply(this, arguments);
    }
    get j$a() {
        return this.b8;
    }
    get i$a() {
        return this.b5;
    }
}
TimeXAxis.$t = markType(TimeXAxis, 'TimeXAxis', TimeAxisBase.$, [ITimeRangeSelectorAxis_$type]);
TimeXAxis.l2 = null;
