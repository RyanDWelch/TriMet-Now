/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AxisLabelPanelBase } from "./AxisLabelPanelBase";
import { Boolean_$type, typeCast, Type, markType, Point_$type, typeGetValue, fromEnum, runOn, Number_$type } from "igniteui-react-core/ES2015/type";
import { AxisLabelPanelBaseView } from "./AxisLabelPanelBaseView";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { Extensions } from "igniteui-react-core/ES2015/Extensions";
import { Axis } from "./Axis";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { LabelPosition } from "./LabelPosition";
import { XamDataChart } from "./XamDataChart";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { IAngleScaler_$type } from "./IAngleScaler";
import { CategoryAxisRenderer } from "./CategoryAxisRenderer";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { PolarAxisRenderingManager } from "./PolarAxisRenderingManager";
import { AxisLabelManager } from "./AxisLabelManager";
import { ViewportUtils } from "./ViewportUtils";
import { RadialAxisRenderingParameters } from "./RadialAxisRenderingParameters";
import { CategoryTickmarkValues } from "./CategoryTickmarkValues";
import { MathUtil } from "igniteui-react-core/ES2015/MathUtil";
import { SeriesViewer } from "./SeriesViewer";
import { ScalerParams } from "./ScalerParams";
import { AxisRangeChangedEventArgs } from "./AxisRangeChangedEventArgs";
import { LineGeometry } from "igniteui-react-core/ES2015/LineGeometry";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { RangeInfo } from "./RangeInfo";
import { isNaN_, isInfinity } from "igniteui-react-core/ES2015/number";
import { NumericAxisBase } from "./NumericAxisBase";
import { LogarithmicTickmarkValues } from "./LogarithmicTickmarkValues";
import { PolarAxisRenderingParameters } from "./PolarAxisRenderingParameters";
import { RadialAxisLabelPanel } from "./RadialAxisLabelPanel";
import { LinearTickmarkValues } from "./LinearTickmarkValues";
import { IPolarRadialRenderingParameters_$type } from "./IPolarRadialRenderingParameters";
import { PathGeometry } from "igniteui-react-core/ES2015/PathGeometry";
import { PathFigure } from "igniteui-react-core/ES2015/PathFigure";
import { ArcSegment } from "igniteui-react-core/ES2015/ArcSegment";
import { Size } from "igniteui-react-core/ES2015/Size";
import { CategoryAxisBaseView } from "./CategoryAxisBaseView";
import { NumericAxisBaseView } from "./NumericAxisBaseView";
/**
 * @hidden
 */
export class AngleAxisLabelPanel extends AxisLabelPanelBase {
    constructor() {
        super();
        this.ct = false;
        this.cz = null;
        this.cx = 0;
        this.cu = 0;
        this.cw = 0;
        this.cv = 0;
    }
    ad() {
        return new AngleAxisLabelPanelView(this);
    }
    b8(a) {
        super.b8(a);
        this.cs = a;
    }
    ao(a, b) {
        if (!Extensions.b(b)) {
            return false;
        }
        if (this.ac == null || this.ac.i0.isEmpty) {
            return super.ao(a, b);
        }
        return true;
    }
    ay() {
        let a = new List$1(Rect.$, 0);
        let b = new List$1(Boolean_$type, 0);
        if (this.a3.count != this.a2.count) {
            return a;
        }
        this.cs.ay(a, b);
        let c = false;
        this.am = this.al(a, b);
        if (!this.ac.bz()) {
            c = true;
            this.a9 = this.cx / 2;
            this.a9 = this.a9 + this.cy();
        }
        else {
            c = true;
            this.cs.ac();
        }
        if (c) {
            for (let d = 0; d < a.count; d++) {
                let e = this.a3._inner[d];
                let f = this.a2._inner[d];
                let g = a._inner[d];
                let h = this.cz(f.c);
                let i = h.x - this.bc(e) / 2;
                let j = h.y - this.bb(e) / 2;
                g.x = i;
                g.y = j;
                a._inner[d] = g;
            }
        }
        return a;
    }
    cy() {
        let a;
        let b;
        b = this.ac;
        a = null;
        if (b != null) {
            a = typeCast(XamDataChart.$, b.bf);
        }
        if (a == null || b == null) {
            return 0;
        }
        let c = new List$1(Axis.$, 0);
        for (let d = 0; d < a.axes.count; d++) {
            let e = a.axes._inner[d];
            if ((typeCast(NumericAngleAxis.$, e) !== null || typeCast(CategoryAngleAxis.$, e) !== null) && typeCast(AngleAxisLabelPanel.$, e.at) !== null && e.at.a3.count > 0 && (!e.bz()) && !e.by() && (e.ag == null || this.ac.ag == null || e.ag.li == b.ag.li)) {
                c.add(e);
            }
        }
        let f = c.indexOf(b);
        if (f == -1) {
            return 0;
        }
        let g = 0;
        let h = 5;
        if (f == 0) {
            g += h;
        }
        else {
            g += c._inner[f - 1].at.a9;
            g += c._inner[f].at.a9 * 2 + h;
        }
        return g;
    }
    ah() {
        return 4;
    }
    as(a) {
        return a == 4 || a == 5;
    }
}
AngleAxisLabelPanel.$t = markType(AngleAxisLabelPanel, 'AngleAxisLabelPanel', AxisLabelPanelBase.$);
/**
 * @hidden
 */
export class CategoryAngleAxis extends CategoryAxisBase {
    constructor() {
        super();
        this.k1 = null;
        this.ky = null;
        this.k2 = false;
        this.k6 = NaN;
        this.kz = null;
        this.k7 = 0;
        this.k4 = 0;
        this.k5 = 0;
        this.li = 1;
        this.ab = CategoryAngleAxis.$;
        this.ky = this.kx();
        this.k1 = new PolarAxisRenderingManager();
    }
    a1() {
        return new CategoryAngleAxisView(this);
    }
    gr(a) {
        super.gr(a);
        this.kw = a;
    }
    get_b0() {
        return true;
    }
    as() {
        let a = new AngleAxisLabelPanel();
        a.cz = (b) => {
            let c = this.bf != null ? this.bf.mq : Rect.empty;
            let d = !c.isEmpty ? this.i0 : Rect.empty;
            return this.lv(b, { $type: Point_$type, x: 0.5, y: 0.5 }, c, d, this.at.a9);
        };
        return a;
    }
    lg(a) {
        return Math.round(a * Math.pow(10, 10)) / Math.pow(10, 10);
    }
    kx() {
        let a = ((() => {
            let $ret = new AxisLabelManager();
            $ret.a = this;
            $ret.f = this.cv;
            $ret.e = this.cu;
            $ret.b = this.at;
            return $ret;
        })());
        if (this.aw != null) {
            this.aw.registerAxis(this);
        }
        let b = new CategoryAxisRenderer(a);
        b.u = () => {
            let c = this.a2.ay();
            let d = this.a2.a1();
            let e = this.a2.az();
            let f = this.a2.a0();
            this.hd();
            this.gh(c);
            this.gh(d);
            this.gh(e);
            this.gh(f);
        };
        b.o = (c, d) => !d.isEmpty && !c.isEmpty && this.k0 != null;
        b.d = (c, d, e, f) => this.kv(c, d, e, f);
        b.v = () => {
            if (!this.k2) {
                this.k2 = true;
                this.k0.ck();
                this.k2 = false;
            }
        };
        b.g = (c) => {
            let d = typeGetValue(c);
            if (d > this.je.count - 1) {
                d -= this.je.count;
            }
            let e = this.je.item(d);
            return this.e5(e);
        };
        b.b.c = (c) => {
            if ((this.aw == null || this.aw.visibility == 0) && this.k0 != null && this.k6 != c) {
                let d = typeCast(XamDataChart.$, this.bf);
                if (d == null) {
                    return;
                }
                this.k6 = c;
                this.at.a8 = c;
                d.ht();
                for (let e of fromEnum(d.axes)) {
                    if (e != this && typeCast(AngleAxisLabelPanel.$, e.at) !== null) {
                        e.a2.ad();
                    }
                }
            }
        };
        b.k = (c, d, e) => {
            let f = typeCast(RadialAxisRenderingParameters.$, c);
            this.k1.m(d, e, c.z, c.aa, f.minLength, f.maxLength, f.center);
        };
        b.l = (c, d, e, f) => {
            let g = typeCast(RadialAxisRenderingParameters.$, c);
            this.k1.n(d, e, f, g.z, c.aa, g.minLength, g.maxLength, g.center);
        };
        b.m = (c, d) => this.getScaledAngle(d);
        b.q = (c, d) => {
            if (this.lg(d - this.k7) < 0) {
                return false;
            }
            if (this.lg(d - this.k7 - (2 * Math.PI)) > 0) {
                return false;
            }
            return true;
        };
        b.j = (c) => {
            let d = typeCast(RadialAxisRenderingParameters.$, c);
            if (d.e == d.k._inner[0]) {
                this.k1.i(c.t, c.n, c.z, c.aa, d.center, d.minAngle, d.maxAngle);
            }
        };
        b.e = (c) => {
            c.n = this.la();
            c.r = c.n;
        };
        b.p = (c, d, e) => {
            let f = typeCast(RadialAxisRenderingParameters.$, c);
            if (e) {
                return false;
            }
            let g = this.lv(d, f.center, c.aa, c.z, 0);
            if (g.x < c.z.right && g.x >= c.z.left && g.y < c.z.bottom && g.y >= c.z.top) {
                return true;
            }
            return false;
        };
        b.a = (c, d, e, f) => {
            let g = c.y;
            let h = new ScalerParams(0, c.aa, c.z, this.b8, g);
            let i = d;
            if (this.categoryMode != 0) {
                let j = (e * f) + 1;
                j = Math.min(j, this.jx);
                let k = this.dv(j, h);
                i = (d + k) / 2;
            }
            return i;
        };
        b.f = runOn(this, this.getGroupCenter);
        b.i = runOn(this, this.ld);
        return b;
    }
    lv(a, b, c, d, e) {
        let f = this.la();
        let g = ViewportUtils.b(e, c, d);
        if (this.aw != null && (this.aw.c == 5 || this.aw.c == 1)) {
            g *= -1;
        }
        let h = b.x + (f + g) * Math.cos(a);
        let i = b.y + (f + g) * Math.sin(a);
        h = ViewportUtils.c(h, c, d);
        i = ViewportUtils.f(i, c, d);
        return { $type: Point_$type, x: h, y: i };
    }
    la() {
        if (this.k0 == null) {
            return 0;
        }
        if (!this.by()) {
            return this.k0.ln();
        }
        else {
            return this.k0.lo((this.e1));
        }
    }
    kv(a, b, c, d) {
        if (this.je == null) {
            return null;
        }
        let e = new RadialAxisRenderingParameters();
        let f = this.je.count - 1;
        let g = this.a2.ay();
        let h = this.a2.a1();
        let i = this.a2.az();
        let j = this.a2.a0();
        e.t = g;
        e.w = h;
        e.u = i;
        e.v = j;
        e.l = f;
        e.m = 0;
        e.h = false;
        e.z = a;
        e.y = c;
        e.x = d;
        e.aa = b;
        e.g = this.k3();
        e.p = this.le;
        e.o = this.d8();
        e.q = this.lf;
        e.s = this.e6;
        let k = this.k1.f(b);
        let l = this.k1.g(b);
        let m = 0.5 * this.k0.li;
        let n = 0.5 * this.k0.lh;
        let o = k;
        let p = l;
        let q = this.k0.ln();
        if (isNaN_(q) || isInfinity(q)) {
            return null;
        }
        if (p >= m) {
            p = q;
        }
        if (o < n) {
            o = n;
        }
        let r = a.width;
        this.k1.k(b, e, 0, this.je.count, this.b8, runOn(this, this.getUnscaledAngle), r);
        let s = { $type: Point_$type, x: 0.5, y: 0.5 };
        e.center = s;
        e.maxLength = p;
        e.minLength = o;
        e.effectiveMaximum = q;
        e.ae = this.je.count;
        e.ab = this.categoryMode;
        e.ad = true;
        e.ac = this.b8;
        e.af = this.j0;
        e.f = new CategoryTickmarkValues();
        e.j = this.ci;
        return e;
    }
    getMinMaxAngle(a, b, c) {
        let d = this.k1.l(a, b, c);
        b = d.p1;
        c = d.p2;
        return {
            p1: b,
            p2: c
        };
    }
    ac() {
        super.ac();
        this.g5(false);
    }
    get k0() {
        if (this.kz != null) {
            return this.kz;
        }
        let a = typeCast(XamDataChart.$, this.bf);
        if (a != null) {
            for (let b = 0; b < a.axes.count; b++) {
                if (typeCast(NumericRadiusAxis.$, a.axes._inner[b]) !== null) {
                    return a.axes._inner[b];
                }
            }
        }
        return this.kz;
    }
    set k0(a) {
        this.kz = a;
    }
    ah() {
        return this.k0;
    }
    getCategorySize(a, b, c) {
        return 2 * Math.PI / this.jx;
    }
    jq(a, b, c) {
        let d = !isNaN_(this.jn) ? MathUtil.b(this.jn, 0, 1) : 0;
        let e = 0;
        if (!isNaN_(this.ju)) {
            e = Math.min(this.ju, 1);
        }
        let f = 1 - 0.5 * d;
        return this.getCategorySize(a, b, c) * f / (this.j0 - (this.j0 - 1) * e);
    }
    getGroupCenter(a, b, c, d) {
        let e = 0.5;
        if (this.j0 > 1) {
            let f = !isNaN_(this.jn) ? MathUtil.b(this.jn, 0, 1) : 0;
            let g = 0;
            if (!isNaN_(this.ju)) {
                g = Math.min(this.ju, 1);
            }
            let h = 1 - 0.5 * f;
            let i = h / (this.j0 - (this.j0 - 1) * g);
            let j = (h - i) / (this.j0 - 1);
            e = 0.25 * f + 0.5 * i + a * j;
        }
        return this.getCategorySize(b, c, d) * e;
    }
    ld(a) {
        let b = 0.5;
        if (this.j0 > 1) {
            let c = !isNaN_(this.jn) ? MathUtil.b(this.jn, 0, 1) : 0;
            let d = 0;
            if (!isNaN_(this.ju)) {
                d = Math.min(this.ju, 1);
            }
            let e = 1 - 0.5 * c;
            let f = e / (this.j0 - (this.j0 - 1) * d);
            let g = (e - f) / (this.j0 - 1);
            b = 0.25 * c + 0.5 * f + a * g;
        }
        return b;
    }
    g6(a) {
        super.g6(a);
        let b = this.bf != null ? this.bf.mq : Rect.empty;
        let c = !b.isEmpty ? this.i0 : Rect.empty;
        let d = this.iv();
        let e = this.iu();
        let f = this.ky.c(a, c, b, d, e);
        if (f != null) {
            this.k8 = f.f.m;
            this.k9 = f.f.l;
        }
    }
    lc(a, b) {
        let c;
        let d;
        let e = this.k1.l(b, c, d);
        c = e.p1;
        d = e.p2;
        if (c == 0) {
            if (this.b8) {
                return this.jx;
            }
            else {
                return 0;
            }
        }
        let f = this.getUnscaledAngle(c);
        if (f < 0 || f > this.jx) {
            f = this.getUnscaledAngle(c + Math.PI * 2);
        }
        return f;
    }
    lb(a, b) {
        let c;
        let d;
        let e = this.k1.l(b, c, d);
        c = e.p1;
        d = e.p2;
        if (d > Math.PI * 2) {
            d = d - Math.PI * 2;
        }
        if (d == Math.PI * 2) {
            if (this.b8) {
                return 0;
            }
            else {
                return this.jx;
            }
        }
        let f = this.getUnscaledAngle(d);
        if (f < 0 || f > this.jx) {
            f = this.getUnscaledAngle(d + Math.PI * 2);
        }
        return f;
    }
    getScaledAngle(a) {
        let b = this.jx;
        let c = b >= 2 ? (a) / (b) : b == 1 ? 0.5 : NaN;
        if (this.b9) {
            c = 1 - c;
        }
        return (c * 2 * Math.PI) + this.k7;
    }
    getUnscaledAngle(a) {
        if (a < this.k7) {
            a += 2 * Math.PI;
        }
        let b = (a - this.k7) / (2 * Math.PI);
        if (this.b8) {
            b = 1 - b;
        }
        return b * (this.jx);
    }
    dv(a, b) {
        return this.getScaledAngle(a);
    }
    dy(a, b) {
        return this.getUnscaledAngle(a);
    }
    gt(a, b, c, d) {
        super.gt(a, b, c, d);
        let e = typeCast(XamDataChart.$, this.bf);
        switch (b) {
            case "CrossingAxis":
                let f = typeCast(NumericRadiusAxis.$, d);
                this.lr(f);
                if (f != null) {
                    f.lx(this);
                }
                this.cf = true;
                this.g5(false);
                break;
            case CategoryAngleAxis.$$p[0]:
                this.k7 = this.lh;
                while (this.k7 < 0) {
                    this.k7 += 360;
                }
                while (this.k7 >= 360) {
                    this.k7 -= 360;
                }
                this.k7 = (this.k7 * Math.PI) / 180;
                this.cf = true;
                this.g5(false);
                for (let g of fromEnum(this.cw)) {
                    g.jc(false);
                    g.ij();
                }
                break;
            case "Label":
                if (e != null) {
                    for (let h of fromEnum(e.axes)) {
                        h.cf = true;
                        h.g4();
                    }
                }
                break;
            case "CrossingValue":
                if (e != null) {
                    for (let i of fromEnum(e.axes)) {
                        if (typeCast(NumericAngleAxis.$, i) !== null || typeCast(CategoryAngleAxis.$, i) !== null) {
                            i.cf = true;
                            i.g4();
                        }
                    }
                }
                break;
            case "LabelSettings":
                this.ky = this.kx();
                this.lp();
                this.cf = true;
                this.g5(false);
                break;
        }
    }
    lp() {
        this.k6 = NaN;
    }
    lr(a) {
        this.k0 = a;
    }
    get le() {
        return this.c(CategoryAngleAxis.ls);
    }
    set le(a) {
        this.h(CategoryAngleAxis.ls, a);
    }
    get k8() {
        return this.k4;
    }
    set k8(a) {
        if (this.k8 != a) {
            let b = this.k4;
            this.k4 = a;
            this.gz("ActualInterval", b, this.k8);
        }
    }
    d6() {
        return this.k8;
    }
    get lf() {
        return this.c(CategoryAngleAxis.lt);
    }
    set lf(a) {
        this.h(CategoryAngleAxis.lt, a);
    }
    get k9() {
        return this.k5;
    }
    set k9(a) {
        if (this.k9 != a) {
            let b = this.k5;
            this.k5 = a;
            this.gz("ActualMinorInterval", b, this.k9);
        }
    }
    k3() {
        return false;
    }
    get_az() {
        return 2;
    }
    get az() {
        return this.get_az();
    }
    cm() {
        if (this.cf && this.cn) {
            this.a9 = this.a8();
        }
        if (this.je == null) {
            return false;
        }
        let a = this.je.count;
        if (a != this.lj) {
            let b = new AxisRangeChangedEventArgs(0, 1, 1, this.lj, a);
            this.lj = a;
            this.g0(b);
            return true;
        }
        return false;
    }
    get lj() {
        return this.li;
    }
    set lj(a) {
        this.li = a;
    }
    is(a, b, c, d = null, e = null) {
        let f = typeCast(RadialAxisRenderingParameters.$, this.ky.d(c, b, d, e));
        if (f == null) {
            return null;
        }
        let g = Math.cos(a);
        let h = Math.sin(a);
        let i = f.center.x + g * f.minLength;
        let j = f.center.y + h * f.minLength;
        let k = f.center.x + g * f.maxLength;
        let l = f.center.y + h * f.maxLength;
        i = ViewportUtils.c(i, b, c);
        j = ViewportUtils.f(j, b, c);
        k = ViewportUtils.c(k, b, c);
        l = ViewportUtils.f(l, b, c);
        let m = new LineGeometry();
        m.c = { $type: Point_$type, x: i, y: j };
        m.b = { $type: Point_$type, x: k, y: l };
        return m;
    }
    get isVertical() {
        return this.ce;
    }
    j$c(a, b) {
        return this.dy.apply(this, arguments);
    }
    j$b(a, b) {
        return this.dv.apply(this, arguments);
    }
    j$d(a, b, c, d, e) {
        this.gl.apply(this, arguments);
    }
    j$e(a, b, c, d) {
        this.gm.apply(this, arguments);
    }
    j$f(a, b, c, d) {
        this.gn.apply(this, arguments);
    }
    get j$a() {
        return this.b8;
    }
}
CategoryAngleAxis.$t = markType(CategoryAngleAxis, 'CategoryAngleAxis', CategoryAxisBase.$, [IAngleScaler_$type]);
CategoryAngleAxis.ls = DependencyProperty.i("Interval", Number_$type, CategoryAngleAxis.$, new PropertyMetadata(2, NaN, (a, b) => {
    a.gz("Interval", b.oldValue, b.newValue);
    a.g5(false);
}));
CategoryAngleAxis.lt = DependencyProperty.i("MinorInterval", Number_$type, CategoryAngleAxis.$, new PropertyMetadata(2, NaN, (a, b) => {
    (typeCast(CategoryAngleAxis.$, a)).gz("MinorInterval", b.oldValue, b.newValue);
    (typeCast(CategoryAngleAxis.$, a)).g5(false);
}));
Type.dep(DependencyProperty, PropertyMetadata, CategoryAngleAxis, 'gz', ['StartAngleOffset:lh:lu', [1, 0]]);
/**
 * @hidden
 */
export class NumericAngleAxis extends NumericAxisBase {
    constructor() {
        super();
        this.le = null;
        this.lf = false;
        this.lg = NaN;
        this.lh = 0;
        this.lc = null;
        this.ab = NumericAngleAxis.$;
        this.le = new PolarAxisRenderingManager();
        this.je = this.jc();
    }
    a1() {
        return new NumericAngleAxisView(this);
    }
    gr(a) {
        super.gr(a);
        this.lb = a;
    }
    get_b0() {
        return true;
    }
    as() {
        let a = new AngleAxisLabelPanel();
        a.cz = (b) => {
            let c = this.bf != null ? this.bf.mq : Rect.empty;
            let d = !c.isEmpty ? this.i0 : Rect.empty;
            return this.lr(b, { $type: Point_$type, x: 0.5, y: 0.5 }, c, d, this.at.a9);
        };
        return a;
    }
    li() {
        if (this.ld == null) {
            return 0;
        }
        if (!this.by()) {
            return this.ld.ln();
        }
        else {
            return this.ld.lo((this.e1));
        }
    }
    lk(a) {
        return Math.round(a * Math.pow(10, 10)) / Math.pow(10, 10);
    }
    jc() {
        let a = super.jc();
        a.b.c = (b) => {
            if ((this.aw == null || this.aw.visibility == 0) && this.ld != null && this.lg != b) {
                let c = typeCast(XamDataChart.$, this.bf);
                if (c == null) {
                    return;
                }
                this.lg = b;
                this.at.a8 = b;
                c.ht();
                for (let d of fromEnum(c.axes)) {
                    if (d != this && typeCast(AngleAxisLabelPanel.$, d.at) !== null) {
                        d.a2.ad();
                    }
                }
            }
        };
        a.e = (b) => {
            b.n = this.li();
            b.r = b.n;
        };
        a.j = (b) => {
            let c = typeCast(PolarAxisRenderingParameters.$, b);
            if (c.e == c.k._inner[0]) {
                this.le.i(b.t, b.n, b.z, b.aa, c.center, c.minAngle, c.maxAngle);
            }
        };
        a.k = (b, c, d) => {
            let e = typeCast(PolarAxisRenderingParameters.$, b);
            this.le.m(c, d, b.z, b.aa, e.minLength, e.maxLength, e.center);
        };
        a.l = (b, c, d, e) => {
            let f = typeCast(PolarAxisRenderingParameters.$, b);
            this.le.n(c, d, e, f.z, b.aa, f.minLength, f.maxLength, f.center);
        };
        a.d = (b, c, d, e) => {
            let f = typeCast(PolarAxisRenderingParameters.$, this.jf(b, c, d, e));
            return f;
        };
        a.v = () => {
            if (!this.lf) {
                this.lf = true;
                this.ld.ck();
                this.lf = false;
            }
        };
        a.m = (b, c) => this.getScaledAngle(c);
        a.o = (b, c) => !c.isEmpty && !b.isEmpty && this.ld != null;
        a.q = (b, c) => {
            if (this.lk(c - this.lh) < 0) {
                return false;
            }
            if (this.lk(c - this.lh - (2 * Math.PI)) > 0) {
                return false;
            }
            return true;
        };
        a.p = (b, c, d) => {
            let e = typeCast(PolarAxisRenderingParameters.$, b);
            let f = this.lr(this.getScaledAngle(e.l), e.center, b.aa, b.z, 0);
            let g = this.lr(c, e.center, b.aa, b.z, 0);
            if (d && MathUtil.e(f.x - g.x, f.y - g.y) < 2) {
                return false;
            }
            if (g.x < b.z.right && g.x >= b.z.left && g.y < b.z.bottom && g.y >= b.z.top) {
                return true;
            }
            return false;
        };
        a.r = (b, c, d, e) => {
            if (c < b.m && typeCast(LogarithmicTickmarkValues.$, b.f) !== null) {
                return b.m;
            }
            else if (c > b.l && (typeCast(LogarithmicTickmarkValues.$, b.f) !== null || b.h)) {
                return b.l;
            }
            return c;
        };
        return a;
    }
    lr(a, b, c, d, e) {
        let f = this.li();
        let g = ViewportUtils.b(e, c, d);
        if (this.aw != null && (this.aw.c == 5 || this.aw.c == 1)) {
            g *= -1;
        }
        let h = b.x + (f + g) * Math.cos(a);
        let i = b.y + (f + g) * Math.sin(a);
        h = ViewportUtils.c(h, c, d);
        i = ViewportUtils.f(i, c, d);
        return { $type: Point_$type, x: h, y: i };
    }
    dv(a, b) {
        return this.getScaledAngle(a);
    }
    getScaledAngle1(a, b, c) {
        let d = 0;
        if (b) {
            d = (Math.log(a) - this.j9) / (this.j8 - this.j9);
        }
        else {
            d = (a - this.j3) / (this.j2 - this.j3);
        }
        if (c) {
            d = 1 - d;
        }
        return (d * 2 * Math.PI) + this.lh;
    }
    getScaledAngle(a) {
        return this.getScaledAngle1(a, this.jt, this.b9);
    }
    dy(a, b) {
        return this.getUnscaledAngle(a);
    }
    getUnscaledAngle(a) {
        let b = (a - this.lh) / (2 * Math.PI);
        if (this.b8) {
            b = 1 - b;
        }
        if (this.jt) {
            return Math.exp(b * (this.j8 - this.j9) + this.j9);
        }
        else {
            return this.j3 + b * (this.j2 - this.j3);
        }
    }
    gt(a, b, c, d) {
        super.gt(a, b, c, d);
        let e = typeCast(XamDataChart.$, this.bf);
        switch (b) {
            case "CrossingAxis":
                let f = typeCast(NumericRadiusAxis.$, d);
                this.lp(f);
                if (f != null) {
                    f.lx(this);
                }
                this.g5(false);
                break;
            case NumericAngleAxis.$$p[0]:
                this.lh = this.ll;
                while (this.lh < 0) {
                    this.lh += 360;
                }
                while (this.lh >= 360) {
                    this.lh -= 360;
                }
                this.lh = (this.ll * Math.PI) / 180;
                this.g5(false);
                for (let g of fromEnum(this.ct())) {
                    g.jc(false);
                    g.ij();
                }
                break;
            case "Label":
                if (e != null) {
                    for (let h of fromEnum(e.axes)) {
                        h.g4();
                    }
                }
                break;
            case "CrossingValue":
                if (e != null) {
                    for (let i of fromEnum(e.axes)) {
                        if (typeCast(NumericAngleAxis.$, i) !== null || typeCast(CategoryAngleAxis.$, i) !== null) {
                            i.g4();
                        }
                    }
                }
                break;
            case "LabelSettings":
                this.je = this.jc();
                this.ln();
                this.cf = true;
                this.g5(false);
                break;
        }
    }
    ln() {
        this.lg = NaN;
    }
    jg() {
        return new PolarAxisRenderingParameters();
    }
    jf(a, b, c, d) {
        let e = typeCast(PolarAxisRenderingParameters.$, super.jf(a, b, c, d));
        let f = this.le.f(b);
        let g = this.le.g(b);
        let h = 0.5 * this.ld.li;
        let i = 0.5 * this.ld.lh;
        let j = f;
        let k = g;
        let l = this.ld.ln();
        if (isNaN_(l) || isInfinity(l)) {
            return null;
        }
        if (k >= h) {
            k = l;
        }
        if (j < i) {
            j = i;
        }
        let m = a.width;
        this.le.k(b, e, this.j3, this.j2, this.b8, runOn(this, this.getUnscaledAngle), m);
        let n = { $type: Point_$type, x: 0.5, y: 0.5 };
        e.center = n;
        e.maxLength = k;
        e.minLength = j;
        e.effectiveMaximum = l;
        return e;
    }
    getMinMaxAngle(a, b, c) {
        let d = this.le.l(a, b, c);
        b = d.p1;
        c = d.p2;
        return {
            p1: b,
            p2: c
        };
    }
    g6(a) {
        super.g6(a);
        let b = this.bf != null ? this.bf.mq : Rect.empty;
        let c = !b.isEmpty ? this.i0 : Rect.empty;
        let d = this.iv();
        let e = this.iu();
        let f = this.je.c(a, c, b, d, e);
        if (f != null) {
            this.j1 = f.f.m;
            this.j4 = f.f.l;
        }
    }
    get ld() {
        if (this.lc != null) {
            return this.lc;
        }
        let a = typeCast(XamDataChart.$, this.bf);
        if (a != null) {
            for (let b = 0; b < a.axes.count; b++) {
                if (a.axes._inner[b].cb) {
                    return a.axes._inner[b];
                }
            }
        }
        return this.lc;
    }
    set ld(a) {
        this.lc = a;
    }
    ah() {
        return this.ld;
    }
    lp(a) {
        this.ld = a;
    }
    hg(a, b) {
        super.hg(a, b);
        if (b.height != a.height || b.width != a.width) {
            this.ck();
        }
    }
    get_az() {
        return 2;
    }
    get az() {
        return this.get_az();
    }
    is(a, b, c, d = null, e = null) {
        if (this.ld == null) {
            return null;
        }
        let f = typeCast(PolarAxisRenderingParameters.$, this.jf(c, b, d, e));
        if (f == null) {
            return null;
        }
        let g = Math.cos(a);
        let h = Math.sin(a);
        let i = f.center.x + g * f.minLength;
        let j = f.center.y + h * f.minLength;
        let k = f.center.x + g * f.maxLength;
        let l = f.center.y + h * f.maxLength;
        i = ViewportUtils.c(i, b, c);
        j = ViewportUtils.f(j, b, c);
        k = ViewportUtils.c(k, b, c);
        l = ViewportUtils.f(l, b, c);
        let m = new LineGeometry();
        m.c = { $type: Point_$type, x: i, y: j };
        m.b = { $type: Point_$type, x: k, y: l };
        return m;
    }
}
NumericAngleAxis.$t = markType(NumericAngleAxis, 'NumericAngleAxis', NumericAxisBase.$, [IAngleScaler_$type]);
Type.dep(DependencyProperty, PropertyMetadata, NumericAngleAxis, 'gz', ['StartAngleOffset:ll:lq', [1, 0]]);
/**
 * @hidden
 */
export class NumericRadiusAxis extends NumericAxisBase {
    constructor() {
        super();
        this.le = null;
        this.lf = false;
        this.lg = NaN;
        this.li = 0;
        this.lh = 0;
        this.lk = 0;
        this.lb = null;
        this.ab = NumericRadiusAxis.$;
        this.li = this.ls;
        this.lh = this.lr;
        this.le = new PolarAxisRenderingManager();
        this.je = this.jc();
    }
    a1() {
        return new NumericRadiusAxisView(this);
    }
    gr(a) {
        super.gr(a);
        this.ld = a;
    }
    get_cb() {
        return true;
    }
    du() {
        let a = this.li;
        let b = this.lh;
        let c = Math.min(this.lm(), this.ll()) * (a - b) / 2;
        c = Math.max(c, 14);
        return c;
    }
    lm() {
        return this.i0.width;
    }
    ll() {
        return this.i0.height;
    }
    as() {
        return new RadialAxisLabelPanel();
    }
    lj(a) {
        if (a == null) {
            return 0;
        }
        return a;
    }
    jc() {
        let a = super.jc();
        a.b.c = (b) => {
            if ((this.aw == null || this.aw.visibility == 0) && this.lc != null) {
                if ((this.aw == null || (this.aw.c == 4 || this.aw.c == 5)) && this.lg != b) {
                    this.lg = b;
                    this.at.a8 = b;
                    this.bf.ht();
                }
            }
        };
        a.k = (b, c, d) => {
            let e = typeCast(PolarAxisRenderingParameters.$, b);
            this.le.i(c, d, e.z, e.aa, e.center, e.minAngle, e.maxAngle);
        };
        a.l = (b, c, d, e) => {
            if (d == e) {
                return;
            }
            let f = typeCast(PolarAxisRenderingParameters.$, b);
            this.le.j(c, d, e, f.z, f.aa, f.center, f.minAngle, f.maxAngle);
        };
        a.m = (b, c) => this.lo(c);
        a.q = (b, c) => {
            let d = typeCast(PolarAxisRenderingParameters.$, b);
            return c <= d.effectiveMaximum;
        };
        a.n = (b, c) => {
            let d = typeCast(PolarAxisRenderingParameters.$, b);
            return c <= d.effectiveMaximum;
        };
        a.j = (b) => {
            let c = typeCast(PolarAxisRenderingParameters.$, b);
            this.le.m(b.t, c.crossingAngleRadians, b.z, b.aa, c.minLength, c.maxLength, c.center);
        };
        a.e = (b) => {
            b.n = this.aw == null || (this.aw.c == 4 || this.aw.c == 0) ? b.z.top : b.z.bottom;
            b.r = b.n;
            let c = typeCast(PolarAxisRenderingParameters.$, b);
            c.crossingAngleRadians = (this.lj(this.e1) * Math.PI) / 180;
            if (this.aw == null || (this.aw.c == 4 || this.aw.c == 5)) {
                c.n = ViewportUtils.f(0.5, c.aa, c.z) - b.z.top;
                c.r = c.n;
                let d = typeCast(RadialAxisLabelPanel.$, this.at);
                if (d != null) {
                    let e = 0;
                    if (this.aw != null && this.aw.c == 4) {
                        e = 1;
                    }
                    d.dh = { $type: Point_$type, x: ViewportUtils.c(0.5, c.aa, c.z), y: e };
                    d.de = c.crossingAngleRadians;
                }
            }
        };
        a.p = (b, c, d) => {
            let e = typeCast(PolarAxisRenderingParameters.$, b);
            if (this.lc == null) {
                return false;
            }
            if (c > e.effectiveMaximum) {
                return false;
            }
            let f = false;
            f = this.aw == null || (this.aw.c == 4 || this.aw.c == 5);
            let g = 0;
            if (f) {
                g = this.lk;
            }
            let h = e.center.x + c * Math.cos(g);
            let i = e.center.y + c * Math.sin(g);
            h = ViewportUtils.c(h, e.aa, e.z);
            i = ViewportUtils.f(i, e.aa, e.z);
            if (h <= b.z.right && h >= b.z.left && ((i <= b.z.bottom && i >= b.z.top) || !f)) {
                return true;
            }
            return false;
        };
        a.h = (b, c) => {
            let d = typeCast(PolarAxisRenderingParameters.$, b);
            return new LabelPosition(ViewportUtils.c(d.center.x + c, d.aa, d.z));
        };
        a.r = (b, c, d, e) => {
            if (c < b.m) {
                return b.m;
            }
            else if (c > b.l) {
                return b.l;
            }
            return c;
        };
        return a;
    }
    dv(a, b) {
        return this.lo(a);
    }
    lp(a, b, c, d, e) {
        let f = 0;
        if (b) {
            if (a <= 0) {
                f = (Math.log(this.j3) - this.j9) / (this.j8 - this.j9);
            }
            else {
                f = (Math.log(a) - this.j9) / (this.j8 - this.j9);
            }
        }
        else {
            f = (a - this.j3) / (this.j2 - this.j3);
        }
        if (c) {
            f = 1 - f;
        }
        f = e + (f * (d - e));
        f /= 2;
        return f;
    }
    lo(a) {
        return this.lp(a, this.jt, this.b9, this.li, this.lh);
    }
    lq(a) {
        let b = a * 2;
        b = (b - this.lh) / (this.li - this.lh);
        if (this.b8) {
            b = 1 - b;
        }
        if (this.jt) {
            return Math.exp(b * (this.j8 - this.j9) + this.j9);
        }
        else {
            return this.j3 + b * (this.j2 - this.j3);
        }
    }
    dy(a, b) {
        return this.lq(a);
    }
    gt(a, b, c, d) {
        switch (b) {
            case "CrossingValue":
                this.lk = this.lj(this.e1) * Math.PI / 180;
                break;
        }
        super.gt(a, b, c, d);
        switch (b) {
            case NumericRadiusAxis.$$p[1]:
                this.li = this.ls;
                if (this.li < 0) {
                    this.li = 0.1;
                }
                if (this.li > 1) {
                    this.li = 1;
                }
                if (this.lh >= this.li) {
                    this.lh = this.li - 0.01;
                    if (this.lh < 0) {
                        this.lh = 0;
                        this.li = 0.01;
                    }
                }
                this.cf = true;
                this.g5(false);
                if (this.lc != null) {
                    this.lc.g4();
                }
                for (let e of fromEnum(this.ct())) {
                    e.jc(false);
                }
                break;
            case NumericRadiusAxis.$$p[0]:
                this.lh = this.lr;
                if (this.lh < 0) {
                    this.lh = 0.1;
                }
                if (this.lh > 1) {
                    this.lh = 1;
                }
                if (this.lh >= this.li) {
                    this.lh = this.li - 0.01;
                    if (this.lh < 0) {
                        this.lh = 0;
                        this.li = 0.01;
                    }
                }
                this.cf = true;
                this.g5(false);
                if (this.lc != null) {
                    this.lc.g4();
                }
                for (let f of fromEnum(this.ct())) {
                    f.dl = true;
                    f.jc(false);
                }
                if (this.bf != null) {
                    this.bf.h1();
                }
                break;
            case "CrossingAxis":
                let g = typeCast(NumericAngleAxis.$, d);
                let h = typeCast(CategoryAngleAxis.$, d);
                if (g == null && h == null) {
                    this.lx(null);
                }
                if (g != null) {
                    this.lx(g);
                    g.lp(this);
                }
                if (h != null) {
                    this.lx(h);
                    h.lr(this);
                }
                this.cf = true;
                this.g5(false);
                break;
            case "IsInverted":
                if (this.lc != null) {
                    this.lc.cf = true;
                    this.lc.g5(false);
                }
                break;
        }
    }
    lx(a) {
        this.lc = a;
    }
    get lc() {
        if (this.lb != null) {
            return this.lb;
        }
        let a = typeCast(XamDataChart.$, this.bf);
        if (a != null) {
            for (let b = 0; b < a.axes.count; b++) {
                if (typeCast(NumericAngleAxis.$, a.axes._inner[b]) !== null || typeCast(CategoryAngleAxis.$, a.axes._inner[b]) !== null) {
                    return a.axes._inner[b];
                }
            }
        }
        return this.lb;
    }
    set lc(a) {
        this.lb = a;
    }
    ah() {
        return this.lc;
    }
    jg() {
        return new PolarAxisRenderingParameters();
    }
    jf(a, b, c, d) {
        let e = typeCast(PolarAxisRenderingParameters.$, super.jf(a, b, c, d));
        let f = this.le.f(b);
        let g = this.le.g(b);
        let h = 0.5 * this.li;
        let i = 0.5 * this.lh;
        let j, k;
        if (Rect.l_op_Equality(b, SeriesViewer.m0)) {
            k = this.j2;
            j = this.j3;
        }
        else {
            k = Math.min(g, h);
            j = this.lq(f);
            k = this.lq(k);
            let l = this.ly(a, b, j, k);
            j = l.p2;
            k = l.p3;
        }
        let m = { $type: Point_$type, x: 0.5, y: 0.5 };
        let n = f;
        let o = g;
        let p = Math.min(a.width, a.height) * (this.li - this.lh) / 2;
        e.center = m;
        let q = Math.max(o, n);
        let r = Math.min(n, o);
        e.maxLength = q;
        e.minLength = r;
        let s = Math.min(j, k);
        let t = Math.max(j, k);
        if (s < this.j3) {
            s = this.j3;
        }
        if (t > this.j2) {
            t = this.j2;
        }
        this.j6 = s;
        this.j5 = t;
        e.k.add(((() => {
            let $ret = new RangeInfo();
            $ret.d = s;
            $ret.c = t;
            $ret.b = p;
            return $ret;
        })()));
        let u = typeCast(IAngleScaler_$type, this.lc);
        if (u != null) {
            let v;
            let w;
            let x = u.getMinMaxAngle(b, v, w);
            v = x.p1;
            w = x.p2;
            e.minAngle = Math.min(v, w);
            e.maxAngle = Math.max(v, w);
        }
        let y = this.ln();
        if (o >= h) {
            o = y;
        }
        if (n < i) {
            n = i;
        }
        e.minLength = n;
        e.maxLength = o;
        e.effectiveMaximum = y;
        e.f = this.jj;
        let z = typeCast(LinearTickmarkValues.$, e.f);
        if (z != null) {
            z.y = this.lt(m, e.minLength, e.maxLength, b, a);
        }
        return e;
    }
    ly(a, b, c, d) {
        let e = { $type: Point_$type, x: 0.5, y: 0.5 };
        let f = 0;
        if (this.b8) {
            f = this.lo(this.j3);
        }
        else {
            f = this.lo(this.j2);
        }
        let g = 0;
        if (this.e1 != null) {
            g = this.lk;
        }
        let h = e.x + f * Math.cos(g);
        let i = e.y + f * Math.sin(g);
        e.x = ViewportUtils.c(e.x, b, a);
        e.y = ViewportUtils.f(e.y, b, a);
        h = ViewportUtils.c(h, b, a);
        i = ViewportUtils.f(i, b, a);
        if (h >= a.left && h <= a.right && i >= a.top && i <= a.bottom) {
            if (this.b8) {
                d = this.j3;
            }
            else {
                d = this.j2;
            }
        }
        if (e.x >= a.left && e.x <= a.right && e.y >= a.top && e.y <= a.bottom) {
            if (this.b8) {
                c = this.j2;
            }
            else {
                c = this.j3;
            }
        }
        return {
            p2: c,
            p3: d
        };
    }
    lt(a, b, c, d, e) {
        let f = ViewportUtils.d(c - b, d, e);
        let g = f / Math.min(e.width, e.height);
        if (g > 0.7) {
            return 10;
        }
        return 5;
    }
    ln() {
        let a = 0;
        if (!this.b8) {
            a = this.lo(this.j2);
        }
        else {
            a = this.lo(this.j3);
        }
        return a;
    }
    k1(a) {
        if (this.lc != null) {
            this.lc.g4();
        }
    }
    g6(a) {
        super.g6(a);
        let b = this.bf != null ? this.bf.mq : Rect.empty;
        let c = !b.isEmpty ? this.i0 : Rect.empty;
        let d = this.iv();
        let e = this.iu();
        let f = this.je.c(a, c, b, d, e);
        if (f != null) {
            this.j1 = f.f.m;
            this.j4 = f.f.l;
        }
    }
    hg(a, b) {
        super.hg(a, b);
        if (b.height != a.height || b.width != a.width) {
            this.ck();
        }
    }
    lw(a, b, c, d, e) {
        let f = typeCast(IPolarRadialRenderingParameters_$type, this.jf(b, c, d, e));
        if (f == null) {
            return;
        }
        this.le.j(a.c, f.minLength, f.maxLength, b, c, f.center, f.minAngle, f.maxAngle);
    }
    get_az() {
        return 3;
    }
    get az() {
        return this.get_az();
    }
    is(a, b, c, d = null, e = null) {
        let f = typeCast(PolarAxisRenderingParameters.$, this.jf(c, b, d, e));
        let g = a;
        let h = new PathGeometry();
        let i = ViewportUtils.d(g, b, c);
        let j = ViewportUtils.g(g, b, c);
        if (i <= 0 || j <= 0) {
            return null;
        }
        let k = ViewportUtils.c(f.center.x, b, c);
        let l = ViewportUtils.f(f.center.y, b, c);
        if (f.maxAngle - f.minAngle < Math.PI && f.maxAngle - f.minAngle > 0) {
            let m = { $type: Point_$type, x: ViewportUtils.c(f.center.x + g * Math.cos(f.minAngle), b, c), y: ViewportUtils.f(f.center.y + g * Math.sin(f.minAngle), b, c) };
            let n = { $type: Point_$type, x: ViewportUtils.c(f.center.x + g * Math.cos(f.maxAngle), b, c), y: ViewportUtils.f(f.center.y + g * Math.sin(f.maxAngle), b, c) };
            let o = new PathFigure();
            o._startPoint = m;
            o._isClosed = false;
            o._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.b = false;
                $ret.e = n;
                $ret.f = new Size(1, i, j);
                $ret.d = 1;
                return $ret;
            })()));
            h.b.add(o);
        }
        else {
            let p = new PathFigure();
            p._startPoint = { $type: Point_$type, x: k, y: l - j };
            p._isClosed = true;
            p._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: k, y: l + j };
                $ret.f = new Size(1, i, j);
                $ret.d = 1;
                return $ret;
            })()));
            p._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: k, y: l - j };
                $ret.f = new Size(1, i, j);
                $ret.d = 1;
                return $ret;
            })()));
            h.b.add(p);
        }
        return h;
    }
}
NumericRadiusAxis.$t = markType(NumericRadiusAxis, 'NumericRadiusAxis', NumericAxisBase.$);
Type.dep(DependencyProperty, PropertyMetadata, NumericRadiusAxis, 'gz', ['InnerRadiusExtentScale:lr:lz', [1, 0], 'RadiusExtentScale:ls:l0', [1, 0.75]]);
/**
 * @hidden
 */
export class AngleAxisLabelPanelView extends AxisLabelPanelBaseView {
    constructor(a) {
        super(a);
        this.ax = null;
        this.ax = a;
    }
    am() {
        super.am();
        this.ax.ct = true;
    }
    ay(a, b) {
        this.ax.cx = -1.7976931348623157E+308;
        this.ax.cu = -1.7976931348623157E+308;
        this.ax.cw = -1.7976931348623157E+308;
        this.ax.cv = -1.7976931348623157E+308;
        for (let c = 0; c < this.a.a3.count; c++) {
            let d = this.a.a3._inner[c];
            let e = this.a.a2._inner[c];
            let f = e.a;
            let g = this.ax.cz(e.c);
            let h = this.m(d);
            let i = this.l(d);
            let j = h + this.p() + this.q();
            let k = i + this.r() + this.o();
            let l = g.x - j / 2;
            let m = g.y - k / 2;
            this.ax.cw = Math.max(h, this.ax.cw);
            this.ax.cv = Math.max(i, this.ax.cv);
            this.ax.cx = Math.max(j, this.ax.cx);
            this.ax.cu = Math.max(k, this.ax.cu);
            let n = new Rect(0, l, m, j, k);
            a.add(n);
            b.add(f);
        }
    }
    o() {
        return 0;
    }
    p() {
        return 0;
    }
    q() {
        return 0;
    }
    r() {
        return 0;
    }
}
AngleAxisLabelPanelView.$t = markType(AngleAxisLabelPanelView, 'AngleAxisLabelPanelView', AxisLabelPanelBaseView.$);
/**
 * @hidden
 */
export class CategoryAngleAxisView extends CategoryAxisBaseView {
    constructor(a) {
        super(a);
        this.bg = null;
        this.bg = a;
    }
}
CategoryAngleAxisView.$t = markType(CategoryAngleAxisView, 'CategoryAngleAxisView', CategoryAxisBaseView.$);
/**
 * @hidden
 */
export class NumericAngleAxisView extends NumericAxisBaseView {
    constructor(a) {
        super(a);
        this.bg = null;
        this.bg = a;
    }
}
NumericAngleAxisView.$t = markType(NumericAngleAxisView, 'NumericAngleAxisView', NumericAxisBaseView.$);
/**
 * @hidden
 */
export class NumericRadiusAxisView extends NumericAxisBaseView {
    constructor(a) {
        super(a);
        this.bg = null;
        this.bg = a;
    }
}
NumericRadiusAxisView.$t = markType(NumericRadiusAxisView, 'NumericRadiusAxisView', NumericAxisBaseView.$);
