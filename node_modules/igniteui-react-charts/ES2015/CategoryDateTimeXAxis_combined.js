/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { TimeAxisBase } from "./TimeAxisBase";
import { TimeAxisDisplayType_$type } from "./TimeAxisDisplayType";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { Type, Base, enumGetBox, Number_$type, typeGetValue, typeCast, markType } from "igniteui-react-core/ES2015/type";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { ScalerParams } from "./ScalerParams";
import { NumericYAxis } from "./NumericYAxis";
import { LinearNumericSnapper } from "./LinearNumericSnapper";
import { LabelPosition } from "./LabelPosition";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { truncate, intDivide, isNaN_, isInfinity } from "igniteui-react-core/ES2015/number";
import { dateMinValue, dateFromTicks } from "igniteui-react-core/ES2015/date";
import { timeSpanFromMilliseconds } from "igniteui-react-core/ES2015/timespan";
import { CategoryAxisBaseView } from "./CategoryAxisBaseView";
/**
 * @hidden
 */
export class CategoryDateTimeXAxis extends TimeAxisBase {
    constructor() {
        super();
        this.l8 = 0;
        this.l9 = 0;
        this.ab = CategoryDateTimeXAxis.$;
        this.actualMinimumValue = (new Date());
        this.actualMaximumValue = (new Date());
    }
    get_b4() {
        return this.l3 == 0;
    }
    a1() {
        return new CategoryDateTimeXAxisView(this);
    }
    gr(a) {
        super.gr(a);
        this.l2 = a;
    }
    get ma() {
        return this.l8;
    }
    set ma(a) {
        if (this.ma != a) {
            let b = this.l8;
            this.l8 = a;
            this.gz("ActualInterval", b, this.ma);
        }
    }
    d6() {
        return this.ma;
    }
    get me() {
        return typeGetValue(this.c(CategoryDateTimeXAxis.mp));
    }
    set me(a) {
        this.h(CategoryDateTimeXAxis.mp, a);
    }
    get mb() {
        return this.l9;
    }
    set mb(a) {
        if (this.mb != a) {
            let b = this.l9;
            this.l9 = a;
            this.gz("ActualMinorInterval", b, this.mb);
        }
    }
    cq(a, b, c) {
        let d = super.cq(a, b, c);
        if (!d) {
            return false;
        }
        return +(this.actualMinimumValue) != +(this.actualMaximumValue);
    }
    di() {
        return this.ma;
    }
    g6(a) {
        super.g6(a);
        let b = this.bf != null ? this.bf.mq : Rect.empty;
        let c = !b.isEmpty ? this.i0 : Rect.empty;
        let d = this.iv();
        let e = this.iu();
        let f = new ScalerParams(0, b, c, this.b8, d);
        if (this.kw == null && !this.k2() && !this.k3()) {
            return;
        }
        if (!b.isEmpty && !c.isEmpty && (this.l3 != 1 || this.kw != null)) {
            let g = c.bottom;
            let h = g - c.top;
            if (this.ag != null) {
                let i = typeCast(NumericYAxis.$, this.ag);
                if (i != null) {
                    let j = this.g9(g, h, b, c, d, c.top, c.bottom);
                    g = j.p0;
                    h = j.p1;
                }
            }
            if (isNaN_(g)) {
                g = 0;
            }
            this.gp(this.a2.ay(), g, c, this.a2.e(), true);
            this.at.a8 = h;
            let k = this.a2.a1();
            let l = this.a2.f();
            let m = this.a2.az();
            let n = this.a2.a0();
            let o = this.a2.g();
            if (this.l3 == 1) {
                let p = this.i$e(b, c, d, e);
                let q = this.i$g(b, c, d, e);
                if (p < 0 || q < 0) {
                    return;
                }
                let r = NaN;
                for (let s = p; s <= q; s++) {
                    let t = this.k5 == null ? s : this.k5._inner[s];
                    let u = this.dv(this.kw.item(t).getTime(), f);
                    if (u == r) {
                        continue;
                    }
                    r = u;
                    if (this.categoryMode == 2) {
                        u += this.b8 ? -this.getGroupCenter(s, b, c, d) : this.getGroupCenter(s, b, c, d);
                    }
                    if (u < e.left || u > e.right) {
                        continue;
                    }
                    this.he(m, u, c, l, false);
                    this.jl.add(u);
                    if (this.je != null && s < this.je.count) {
                        let v = this.je.item(t);
                        let w = super.e5(v);
                        if (!isNaN_(u) && !isInfinity(u) && w != null) {
                            if ((typeof w === 'string') && Base.equalsStatic(w, "")) {
                            }
                            else {
                                this.cu.add1(w);
                                this.cv.add(new LabelPosition(u));
                            }
                        }
                    }
                }
            }
            else {
                let x = this.dy(e.left, f);
                let y = this.dy(e.right, f);
                let z = Math.min(x, y);
                let aa = Math.max(x, y);
                let ab = new LinearNumericSnapper(0, z, aa, e.width, this.d8());
                let ac = this.k0 ? this.l7() : ab.g;
                this.ml(truncate(ac));
                let ad = truncate(Math.floor((z - this.actualMinimumValue.getTime()) / ac));
                let ae = truncate(Math.ceil((aa - this.actualMinimumValue.getTime()) / ac));
                let af = 0;
                if (this.categoryMode == 2) {
                    af = this.getGroupCenter(0, b, c, d);
                    af = this.b8 ? -af : af;
                }
                let ag = truncate(Math.ceil(e.right));
                let ah = truncate(Math.floor(e.left));
                let ai = this.dv(this.actualMinimumValue.getTime() + ad * ac, f) + af;
                for (let aj = ad; aj <= ae; aj++) {
                    let ak = this.dv(this.actualMinimumValue.getTime() + (aj + 1) * ac, f) + af;
                    if (!isNaN_(ai) && !isInfinity(ai)) {
                        let al = truncate(Math.round(ai));
                        if (al <= ag) {
                            if (aj % 2 == 0) {
                                this.hf(k, ai, ak, c);
                            }
                            this.he(m, ai, c, l, false);
                            this.jl.add(ai);
                            if (this.ci) {
                                let am = this.mc();
                                if (am > 0 && am < ac) {
                                    if (ac / am < 20) {
                                        let an = ai;
                                        let ao = Math.abs(this.dv(this.actualMinimumValue.getTime() + am, f) - this.dv(this.actualMinimumValue.getTime(), f));
                                        while (an + ao < ak) {
                                            if (Math.abs(an + ao - ak) < 0.0001) {
                                                break;
                                            }
                                            an += ao;
                                            if (an > 0) {
                                                this.he(n, an, c, o, false);
                                            }
                                        }
                                        this.mm(am);
                                    }
                                }
                                else {
                                    for (let ap = 1; ap < ab.i; ++ap) {
                                        let aq = this.dv(this.actualMinimumValue.getTime() + aj * ac + (ap * ac) / ab.i, f) + af;
                                        this.he(n, aq, c, o, false);
                                    }
                                    if (ab.i > 0) {
                                        this.mm(truncate((ac / ab.i)));
                                    }
                                }
                            }
                        }
                        if (al >= ah && al <= ag) {
                            let ar = this.actualMinimumValue.getTime() + aj * ac;
                            let ticks_ = truncate(Math.floor(ar));
                            let as = (new Date(ticks_));
                            let at = this.e5(as);
                            if (at != null) {
                                this.cu.add1(at);
                                this.cv.add(new LabelPosition(ai));
                            }
                        }
                    }
                    ai = ak;
                }
            }
            if ((this.aw == null || this.aw.visibility == 0) && this.ag != null) {
                if (this.aw != null && (this.aw.location == 4 || this.aw.location == 5)) {
                    this.bf.ht();
                }
            }
            this.at.a1 = this.cu;
            this.at.a2 = this.cv;
            this.kl();
        }
    }
    l7() {
        return this.ma;
    }
    mc() {
        return this.me;
    }
    ml(a) {
        this.ma = a;
    }
    mm(a) {
        this.mb = a;
    }
    l5() {
        return this.md != 0;
    }
    l4() {
        return this.ma == 0;
    }
    l6(a) {
        return this.kw == null ? dateMinValue() : this.kw.item(a);
    }
    mk(a, b) {
        if (a > b || this.je == null || this.je.count == 0) {
            return;
        }
        let c = (a.getTime() - this.actualMinimumValue.getTime()) / (this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime());
        let d = (b.getTime() - this.actualMinimumValue.getTime()) / (this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime());
        this.bf.m4 = new Rect(0, c, this.bf.m4.y, d - c, this.bf.m4.height);
    }
    gt(a, b, c, d) {
        super.gt(a, b, c, d);
        switch (b) {
            case CategoryDateTimeXAxis.$$p[0]:
                this.cf = true;
                this.at.ak = this.l3 == 1;
                this.g5(false);
                break;
            case CategoryDateTimeXAxis.$$p[1]:
                this.cf = true;
                this.g5(false);
                break;
        }
    }
    ls() {
        super.ls();
        if (this.l5()) {
            this.ma = this.md;
            let a = this.bf != null ? this.bf.mq : Rect.empty;
            let b = !a.isEmpty ? this.i0 : Rect.empty;
            let c = Math.abs(this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime());
            this.k0 = this.l4() || (this.l3 == 1) || (1 * c / this.l7() > (b.width / a.width)) ? false : true;
        }
        else {
            this.k0 = false;
        }
    }
    lq(a, b) {
        let c = b.getTime() - a.getTime();
        let timeOffset_ = truncate(Math.round(intDivide(c, this.jx) / 2));
        return timeOffset_ == 0 ? timeSpanFromMilliseconds(1) : timeSpanFromMilliseconds(timeOffset_);
    }
    get_b3() {
        return true;
    }
    get isVertical() {
        return this.ce;
    }
    j$c(a, b) {
        return this.dy.apply(this, arguments);
    }
    j$b(a, b) {
        return this.dv.apply(this, arguments);
    }
    j$d(a, b, c, d, e) {
        this.gl.apply(this, arguments);
    }
    j$e(a, b, c, d) {
        this.gm.apply(this, arguments);
    }
    j$f(a, b, c, d) {
        this.gn.apply(this, arguments);
    }
    get j$a() {
        return this.b8;
    }
    get i$a() {
        return this.b5;
    }
}
CategoryDateTimeXAxis.$t = markType(CategoryDateTimeXAxis, 'CategoryDateTimeXAxis', TimeAxisBase.$);
CategoryDateTimeXAxis.mp = DependencyProperty.i("MinorInterval", Number_$type, CategoryDateTimeXAxis.$, new PropertyMetadata(2, 0, (a, b) => {
    (typeCast(CategoryDateTimeXAxis.$, a)).gz("MinorInterval", b.oldValue, b.newValue);
    (typeCast(CategoryDateTimeXAxis.$, a)).g5(false);
}));
Type.dep(DependencyProperty, PropertyMetadata, CategoryDateTimeXAxis, 'gz', ['DisplayType:l3:mn', [TimeAxisDisplayType_$type, enumGetBox(TimeAxisDisplayType_$type, 0)], 'Interval:md:mo', [1, 0]]);
/**
 * @hidden
 */
export class CategoryDateTimeXAxisView extends CategoryAxisBaseView {
    constructor(a) {
        super(a);
        this.bg = null;
        this.bg = a;
    }
    o(a) {
        let b = this.n(dateFromTicks(truncate(a)));
        return b;
    }
}
CategoryDateTimeXAxisView.$t = markType(CategoryDateTimeXAxisView, 'CategoryDateTimeXAxisView', CategoryAxisBaseView.$);
