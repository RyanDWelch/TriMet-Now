/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { SplineType_$type } from "./SplineType";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { ScalerParams } from "./ScalerParams";
import { Type, typeCast, Point_$type, enumGetBox, markType } from "igniteui-react-core/ES2015/type";
import { CollisionAvoider } from "./CollisionAvoider";
import { ISortingAxis_$type } from "./ISortingAxis";
import { AnchoredCategorySeriesView } from "./AnchoredCategorySeriesView";
import { SafeSortedReadOnlyDoubleCollection } from "./SafeSortedReadOnlyDoubleCollection";
import { Numeric } from "igniteui-react-core/ES2015/Numeric";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { truncate, isNaN_ } from "igniteui-react-core/ES2015/number";
import { Color } from "igniteui-react-core/ES2015/Color";
/**
 * @hidden
 */
export class SplineSeriesBase extends HorizontalAnchoredCategorySeries {
    constructor() {
        super(...arguments);
        this.qg = null;
    }
    bf() {
        return new SplineSeriesBaseView(this);
    }
    it(a) {
        super.it(a);
        this.qh = a;
    }
    get_ck() {
        return true;
    }
    qn(a, b, c, d, e, f) {
        let g = typeCast(ISortingAxis_$type, d);
        let h = this.getEffectiveViewport1(f);
        if (g == null) {
            return;
        }
        let i = new ScalerParams(0, b, c, d.b8, h);
        let j = new ScalerParams(0, b, c, e.b8, h);
        j.b = this.eh();
        let k = this.l2();
        let l = 0;
        let m = this.ql(d, b, c, h);
        let n = (o) => o;
        let o = (p) => this.valueColumn.item(g.i$b._inner[p]);
        let p = this.ne.cn.f;
        let q = this.ne.cn.e;
        let r = truncate(Math.ceil(c.width / (p - q)));
        let s = new CollisionAvoider();
        let t = this.ne.cn.d;
        if (t <= 0 || (q <= 0 && p <= 0)) {
            this.ne.cq.count = l;
            return;
        }
        let u = 0;
        let v = 0;
        for (let w = q; w < p + 1; ++w) {
            let x = null;
            let y = w * t;
            if (g != null && g.i$b != null && y >= 0 && y < g.i$b.count) {
                y = g.i$b._inner[y];
            }
            if (w >= (this.valueColumn.count - 1)) {
                if (k && this.qj(a, a.f._inner[a.f.count - 1], s, Math.min(y, this.bz.count - 1), l, f, u - 1)) {
                    ++l;
                }
                break;
            }
            let z = n(w);
            let aa = o(w);
            let ab = n(w + 1);
            let ac = o(w + 1);
            let ad = ab - z;
            let ae = this.qg[w];
            let af = this.qg[w + 1];
            let ag = g.i$d(g.i$b._inner[w]);
            let ah = d.dv(ag, i) + m;
            let ai = e.dv(aa, j);
            a.f.add([ah, ai, ai]);
            u++;
            v = u;
            for (let aj = 1; aj < r; ++aj) {
                let ak = aj / r;
                let al = z + ad * ak;
                let am = (ab - al) / ad;
                let an = (al - z) / ad;
                let ao = am * aa + an * ac + ((am * am * am - am) * ae + (an * an * an - an) * af) * (ad * ad) / 6;
                let ap = g.i$d(g.i$b._inner[w]);
                let aq = g.i$d(g.i$b._inner[w + 1]);
                let ar = ap + (aq - ap) * ak;
                al = d.dv(ar, i) + m;
                ao = e.dv(ao, j);
                a.f.add([al, ao, ao]);
                u++;
            }
            if (k) {
                x = [ah, ai, ai];
            }
            if (k && this.qj(a, x, s, Math.min(y, this.bz.count - 1), l, f, v - 1)) {
                ++l;
            }
        }
        f.cq.count = l;
    }
    qj(a, b, c, d, e, f, g) {
        let h = b[0];
        let i = b[1];
        let j = new Rect(0, h - 5, i - 5, 11, 11);
        if (!isNaN_(h) && !isNaN_(i) && c.tryAdd(j)) {
            a.m.add({ $type: Point_$type, x: h, y: i });
            let k = f.cq.item(e);
            k.content.item = this.bz.item(d);
            k.al = g;
            return true;
        }
        return false;
    }
    aj(a, b, c, d, e, f) {
        if (a == null || a.cc || this.n6(this.bi) > 1 || this.n6(this.bi) == 0) {
            return super.aj(this.m5(), this.m6.f, this.n6(this.bi), this.n7(this.bi), e, f);
        }
        if (this.m6.f.count == 0) {
            return null;
        }
        let g = this.qh.cn.f;
        let h = this.bi.br;
        let i = truncate(Math.ceil(h.width / (g - d)));
        let j = -1;
        let k = -1;
        let l = this.eb(e);
        let m = this.fe(e, f);
        let n = this.fc(e, f);
        let o = truncate(Math.floor(m / this.n6(this.bi)));
        let p = truncate(Math.floor(n / this.n6(this.bi)));
        j = o - this.n7(this.bi);
        k = p - this.n7(this.bi);
        let q = j * i;
        let r = k * i;
        let s = 0;
        if (m != n) {
            s = (l - m) / (n - m);
        }
        let t = truncate(Math.floor(q + s * (r - q)));
        j = t;
        k = t + 1;
        if (j < 0) {
            j = 0;
        }
        if (j > this.m6.f.count - 1) {
            j = this.m6.f.count - 1;
        }
        if (k < 0) {
            k = 0;
        }
        if (k > this.m6.f.count - 1) {
            k = this.m6.f.count - 1;
        }
        let u = this.m6.f._inner[j];
        let v = this.m6.f._inner[k];
        let w = new Array(2);
        w[0] = u;
        w[1] = v;
        return w;
    }
    ok(a, b) {
        super.ok(a, b);
        if (a.f.count <= 1) {
            return;
        }
        if (b.cn.d == 0) {
            return;
        }
        let c = b.bs;
        let d = b.br;
        let e = this.getEffectiveViewport1(b);
        let f = this.px;
        let g = this.p3;
        let h = new ScalerParams(0, c, d, f.b8, e);
        let i = ((() => {
            let $ret = new ScalerParams(0, c, d, g.b8, e);
            $ret.b = this.eh();
            return $ret;
        })());
        a.f.clear();
        a.m.clear();
        let j = this.l2();
        let k = 0;
        let l = typeCast(ISortingAxis_$type, this.px);
        if (l != null && l.i$b.count != this.bz.count) {
            return;
        }
        let m = this.ql(f, c, d, e);
        let n = (o) => o;
        let o = (p) => this.valueColumn.item(p);
        let p = b.cn.d;
        if ((this.qg == null || this.qg.length != this.valueColumn.count) && p == 1) {
            let q = this.qi == 0 ? NaN : 0;
            if (this.px != null && typeCast(ISortingAxis_$type, this.px) !== null && this.px.i$b != null) {
                let r = new SafeSortedReadOnlyDoubleCollection(1, this.valueColumn, this.px.i$b, NaN);
                o = (s) => r.item(s);
            }
            this.qg = Numeric.c(this.valueColumn.count, n, o, q, q);
        }
        let s = b.cn.f;
        let t = b.cn.e;
        let u = truncate(Math.ceil(d.width / (s - t)));
        let v = new CollisionAvoider();
        if (l != null) {
            this.qn(a, c, d, f, g, b);
            return;
        }
        let w = b;
        w.c2();
        let x = 0;
        let y = 0;
        for (let z = t; z <= s; ++z) {
            let aa = null;
            if (p == 1) {
                if (z >= (this.valueColumn.count - 1)) {
                    if (j && this.qj(a, a.f._inner[a.f.count - 1], v, Math.min(z * p, this.bz.count - 1), k, b, x - 1)) {
                        ++k;
                    }
                    break;
                }
                let ab = n(z);
                let ac = o(z);
                let ad = n(z + 1);
                let ae = o(z + 1);
                let af = ad - ab;
                let ag = this.qg[z];
                let ah = this.qg[z + 1];
                let ai = f.dv(ab, h) + m;
                let aj = g.dv(ac, i);
                a.f.add([ai, aj, aj]);
                x++;
                y = x;
                for (let ak = 1; ak < u; ++ak) {
                    let al = ab + af * ak / u;
                    let am = (ad - al) / af;
                    let an = (al - ab) / af;
                    let ao = am * ac + an * ae + ((am * am * am - am) * ag + (an * an * an - an) * ah) * (af * af) / 6;
                    al = f.dv(al, h) + m;
                    ao = g.dv(ao, i);
                    a.f.add([al, ao, ao]);
                    x++;
                }
                if (j) {
                    aa = b.cn.getBucket(z);
                    aa[0] = (f.dv(aa[0], h) + m);
                    aa[1] = g.dv(aa[1], i);
                    aa[2] = g.dv(aa[2], i);
                }
            }
            else {
                aa = b.cn.getBucket(z);
                if (!isNaN_(aa[0])) {
                    aa[0] = (f.dv(aa[0], h) + m);
                    aa[1] = g.dv(aa[1], i);
                    aa[2] = g.dv(aa[2], i);
                    a.f.add(aa);
                    x++;
                }
            }
            if (j && this.qj(a, aa, v, Math.min(z * p, this.bz.count - 1), k, b, y - 1)) {
                ++k;
            }
        }
        w.c4();
        b.cq.count = k;
    }
    qk(a, b, c, d, e, f, g) {
        let h = d - b;
        let i = b + h * a;
        let j = (d - i) / h;
        let k = (i - b) / h;
        let l = j * c + k * e + ((j * j * j - j) * f + (k * k * k - k) * g) * (h * h) / 6;
        return l;
    }
    ef(a, b, c, d, e, f, g, h) {
        let i = NaN;
        if (c >= 0 && c < b.count) {
            i = b.item(c);
        }
        let j = NaN;
        if (d >= 0 && d < b.count) {
            j = b.item(d);
        }
        if (f == 0) {
            return j;
        }
        if (e == b.count - 1) {
            return i;
        }
        if (isNaN_(j) && g != 0 && a <= 0.5 && !h) {
            return i;
        }
        if (isNaN_(i) && g != 0 && a >= 0.5 && !h) {
            return j;
        }
        let k = e;
        let l = f;
        let m = i;
        let n = j;
        let o = NaN;
        let p = NaN;
        if (this.qg != null && e >= 0 && e < this.qg.length) {
            o = this.qg[e];
        }
        if (this.qg != null && f >= 0 && f < this.qg.length) {
            p = this.qg[f];
        }
        return this.qk(a, k, m, l, n, o, p);
    }
    ql(a, b, c, d) {
        let e = this.preferredCategoryMode(a);
        if (e == 0 && a.categoryMode != 0) {
            e = 1;
        }
        let f = 0;
        switch (e) {
            case 0:
                f = 0;
                break;
            case 1:
                f = 0.5 * a.getCategorySize(b, c, d);
                break;
            case 2:
                f = a.getGroupCenter(this.fh, b, c, d);
                break;
        }
        if (a.b8) {
            f = -f;
        }
        return f;
    }
    qo() {
        this.qg = null;
    }
    iy(a, b, c, d) {
        switch (b) {
            case "ValueColumn":
            case "FastItemsSource":
                this.qo();
                break;
        }
        super.iy(a, b, c, d);
        switch (b) {
            case SplineSeriesBase.$$p[0]:
                this.qo();
                this.jc(false);
                this.ij();
                break;
        }
    }
    hy(a, b, c, d) {
        this.qo();
        super.hy(a, b, c, d);
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
SplineSeriesBase.$t = markType(SplineSeriesBase, 'SplineSeriesBase', HorizontalAnchoredCategorySeries.$);
Type.dep(DependencyProperty, PropertyMetadata, SplineSeriesBase, 'raisePropertyChanged', ['SplineType:qi:qp', [SplineType_$type, enumGetBox(SplineType_$type, 0)]]);
/**
 * @hidden
 */
export class SplineSeriesBaseView extends AnchoredCategorySeriesView {
    constructor(a) {
        super(a);
        this.c6 = null;
        this.c6 = a;
    }
    ac() {
        let a = new Color();
        a.colorString = "rgba(95,95,95,0.5)";
        this.e.k9 = a;
        this.e.ev = 3;
        this.e.ew = 1;
        this.e.ex = 4;
        this.e.du = false;
    }
}
SplineSeriesBaseView.$t = markType(SplineSeriesBaseView, 'SplineSeriesBaseView', AnchoredCategorySeriesView.$);
