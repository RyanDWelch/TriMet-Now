/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { FinancialSeries } from "./FinancialSeries";
import { ITrendLineSeries_$type } from "./ITrendLineSeries";
import { TrendLineType_$type } from "igniteui-react-core/ES2015/TrendLineType";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { Brush } from "igniteui-react-core/ES2015/Brush";
import { PenLineCap_$type } from "igniteui-react-core/ES2015/PenLineCap";
import { DoubleCollection } from "igniteui-react-core/ES2015/DoubleCollection";
import { PriceDisplayType_$type } from "./PriceDisplayType";
import { Type, enumGetBox, EnumUtil, typeCast, fromEnum, runOn, Point_$type, markType } from "igniteui-react-core/ES2015/type";
import { CategoryFrame } from "./CategoryFrame";
import { ISortingAxis_$type } from "./ISortingAxis";
import { FinancialSeriesView } from "./FinancialSeriesView";
import { Series } from "./Series";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { RectUtil } from "igniteui-react-core/ES2015/RectUtil";
import { CategoryTrendLineManagerFactory } from "./CategoryTrendLineManagerFactory";
import { AxisRange } from "./AxisRange";
import { ScalerParams } from "./ScalerParams";
import { TrendResolutionParams } from "./TrendResolutionParams";
import { Pool$1 } from "igniteui-react-core/ES2015/Pool$1";
import { Path } from "igniteui-react-core/ES2015/Path";
import { PathGeometry } from "igniteui-react-core/ES2015/PathGeometry";
import { PathFigure } from "igniteui-react-core/ES2015/PathFigure";
import { LineSegment } from "igniteui-react-core/ES2015/LineSegment";
import { GeometryGroup } from "igniteui-react-core/ES2015/GeometryGroup";
import { LineGeometry } from "igniteui-react-core/ES2015/LineGeometry";
import { RectangleGeometry } from "igniteui-react-core/ES2015/RectangleGeometry";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { truncate, isNaN_ } from "igniteui-react-core/ES2015/number";
import { boxArray$1 } from "igniteui-react-core/ES2015/array";
import { FinancialPriceBucketCalculator } from "./FinancialPriceBucketCalculator";
import { Extensions } from "igniteui-react-core/ES2015/Extensions";
/**
 * @hidden
 */
export class FinancialPriceSeries extends FinancialSeries {
    constructor() {
        super();
        this.ab = FinancialPriceSeries.$;
        this.ma = new CategoryFrame(5);
        this.mc = new CategoryFrame(5);
        this.l9 = new CategoryFrame(5);
    }
    bf() {
        return new FinancialPriceSeriesView(this);
    }
    it(a) {
        super.it(a);
        this.pi = a;
    }
    get p2() {
        return this.c(FinancialPriceSeries.ps);
    }
    set p2(a) {
        this.h(FinancialPriceSeries.ps, a);
    }
    hy(a, b, c, d) {
        super.hy(a, b, c, d);
        if (this.l7 != null && typeCast(ISortingAxis_$type, this.l7) !== null) {
            this.l7.i$i();
        }
        this.pi.bu.e(this.eu);
        if (this.pi.b4) {
            this.pi.b2.g$e(a, b, c, d);
        }
        if (this.ms != null) {
            this.ms.ck();
        }
        this.jc(true);
    }
    bd() {
        if (this.be == 0) {
            return 1;
        }
        else {
            return super.bd();
        }
    }
    lt(a) {
        if (this.l9 == null || this.l9.f.count == 0) {
            return Rect.empty;
        }
        let b = this.lf(a);
        let c = this.bi.bs;
        let d = this.bi.br;
        let e = this.getEffectiveViewport1(this.bi);
        let f = this.aj(this.l7, this.l9.f, this.n4(this.bi), this.n6(this.bi), a, true);
        let g = f[0];
        let h = f[1];
        let i = Math.abs(b.x - g[0]);
        let j = Math.abs(b.x - h[0]);
        let k = this.pk(this.mn, e);
        k = Math.max(k, 3);
        let l = (k - 1) / 2;
        if (i < j) {
            let m = g[0] - l;
            let n = g[0];
            let o = g[0] + l;
            let p = g[1];
            let q = g[2];
            let r = g[3];
            let s = g[4];
            let t = Math.min(Math.min(Math.min(p, q), r), s);
            let u = Math.max(Math.max(Math.max(p, q), r), s);
            return new Rect(0, m, t, Math.abs(o - m), u - t);
        }
        else {
            let v = h[0] - l;
            let w = h[0];
            let x = h[0] + l;
            let y = h[1];
            let z = h[2];
            let aa = h[3];
            let ab = h[4];
            let ac = Math.min(Math.min(Math.min(y, z), aa), ab);
            let ad = Math.max(Math.max(Math.max(y, z), aa), ab);
            return new Rect(0, v, ac, Math.abs(x - v), ad - ac);
        }
    }
    ph(a, b) {
        let c = a[0] - b;
        let d = a[0];
        let e = a[0] + b;
        let f = a[1];
        let g = a[2];
        let h = a[3];
        let i = a[4];
        let j = Math.min(Math.min(Math.min(f, g), h), i);
        let k = Math.max(Math.max(Math.max(f, g), h), i);
        let l = Math.min(g, h);
        let m = Math.max(g, h);
        let n = Math.min(f, i);
        let o = Math.max(f, i);
        if (this.pj == 1) {
            let p = new Array(3);
            let q = new Rect(0, c, f, b, 0);
            let r = new Rect(0, d, i, b, 0);
            let s = new Rect(0, d, l, 0, m - l);
            p[0] = q;
            p[1] = r;
            p[2] = s;
            return p;
        }
        else {
            let t = new Array(2);
            let u = new Rect(0, d, l, 0, m - l);
            let v = new Rect(0, c, n, b * 2, o - n);
            t[0] = u;
            t[1] = v;
            return t;
        }
    }
    ak(a) {
        let b = new List$1(Rect.$, 0);
        let c = this.lf(a);
        let d = this.bi.bs;
        let e = this.bi.br;
        let f = this.getEffectiveViewport1(this.bi);
        let g = this.aj(this.l7, this.l9.f, this.n4(this.bi), this.n6(this.bi), a, true);
        let h = g[0];
        let i = g[1];
        let j = Math.abs(c.x - h[0]);
        let k = Math.abs(c.x - i[0]);
        let l = this.pk(this.mn, f);
        l = Math.max(l, 3);
        let m = (l - 1) / 2;
        if (j < k) {
            return this.ph(h, m);
        }
        else {
            return this.ph(i, m);
        }
    }
    dh(a, b) {
        if (this.dk(a, b)) {
            return true;
        }
        return false;
    }
    dk(a, b) {
        let c = this.lu(a);
        if (c.isEmpty) {
            return false;
        }
        let d = RectUtil.r(c, (this.ey / 2) + this.ee(b));
        if (d.containsPoint(a)) {
            let e = this.al(a);
            if (e != null) {
                for (let f = 0; f < e.length; f++) {
                    let g = e[f];
                    let h = RectUtil.r(g, (this.ey / 2) + this.ee(b));
                    if (h.containsPoint(a)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    iy(a, b, c, d) {
        switch (b) {
            case FinancialSeries.$$p[9]:
                this.pi.ca();
                break;
            case "TrendLineType":
                let e = EnumUtil.getEnumValue(TrendLineType_$type, d);
                if (e != 0) {
                    this.pi.b2 = CategoryTrendLineManagerFactory.a(this.pi.b2, this.l7, this.jw, this, this.b2);
                }
                break;
        }
        super.iy(a, b, c, d);
        if (this.pi.b4 && this.pi.b2 != null && this.pi.b2.g$b(a, b, c, d)) {
            this.jc(false);
            this.ij();
        }
        switch (b) {
            case FinancialPriceSeries.$$p[0]:
                if (this.jw != null) {
                    this.pr();
                    this.l9.w();
                    this.o0(this.l9, this.pi);
                }
                this.ij();
                break;
            case "TrendLineBrush":
                this.jn();
                break;
            case "TrendLineType":
                this.ij();
                break;
            case FinancialSeries.$$p[5]:
            case FinancialPriceSeries.$$p[1]:
                this.iv();
                break;
        }
    }
    pr() {
        this.pi.ce();
        if (this.bh != null) {
            this.bh.ce();
        }
    }
    an(a) {
        if (a != null && a == this.ms && this.mz != null && !isNaN_(this.mz.minimum) && this.mx != null && !isNaN_(this.mx.maximum)) {
            return new AxisRange(this.mz.minimum, this.mx.maximum);
        }
        return null;
    }
    ao() {
        if (this.mz == null || this.mx == null) {
            return null;
        }
        let a = new ScalerParams(0, this.bs.mq, this.bs.m3, this.l7.b8, this.getEffectiveViewport());
        let b = (this.l7.dy(this.bs.m3.left, a));
        let c = (this.l7.dy(this.bs.m3.right, a));
        let d = null;
        if (this.l7.cc) {
            d = this.l7;
            b = d.i$f(b);
            c = d.i$f(c);
        }
        else {
            b = Math.floor(b);
            c = Math.ceil(c);
        }
        b = Math.max(0, Math.min(this.mz.count - 1, b));
        c = Math.max(0, Math.min(this.mz.count - 1, c));
        let e = 1.7976931348623157E+308;
        let f = -1.7976931348623157E+308;
        for (let g = truncate(b); g <= truncate(c); g++) {
            let h = g;
            if (d != null) {
                h = d.i$b._inner[g];
            }
            e = Math.min(e, this.mz.item(h));
            f = Math.max(f, this.mx.item(h));
        }
        return new AxisRange(e, f);
    }
    eh() {
        return Series.ei(this.m1, typeCast(ISortingAxis_$type, this.l7));
    }
    c9(a) {
        let b = this.bz != null ? this.bz.indexOf(a) : -1;
        let c = this.bi.bs;
        c = c.copy();
        let d = this.bi.br;
        let e = new Rect(0, 0, 0, 1, 1);
        let f = this.lr(this.bi);
        if (b >= 0 && Rect.l_op_Inequality(c, null) && Rect.l_op_Inequality(d, null)) {
            if (this.l7 != null) {
                let g = new ScalerParams(0, e, e, this.l7.b8, f);
                let h = this.l7.dv(b, g);
                if (h < c.left + 0.1 * c.width) {
                    h = h + 0.4 * c.width;
                }
                if (h > c.right - 0.1 * c.width) {
                    h = h - 0.4 * c.width;
                }
                c.x = h - 0.5 * c.width;
            }
            if (this.ms != null && this.mz != null && this.mx != null && b < this.mz.count && b < this.mx.count) {
                let i = new ScalerParams(0, e, e, this.ms.b8, f);
                i.b = this.eh();
                let j = this.ms.dv(this.mz.item(b), i);
                let k = this.ms.dv(this.mx.item(b), i);
                if (!isNaN_(j) && !isNaN_(k)) {
                    let l = Math.abs(j - k);
                    if (c.height < l) {
                        c.height = l;
                        c.y = Math.min(j, k);
                    }
                    else {
                        if (j < c.top + 0.1 * c.height) {
                            j = j + 0.4 * c.height;
                        }
                        if (j > c.bottom - 0.1 * c.height) {
                            j = j - 0.4 * c.height;
                        }
                        c.y = j - 0.5 * c.height;
                    }
                }
            }
            this.bn.ap(this.bs, c, true);
        }
        return b >= 0;
    }
    dw(a, b, c) {
        let d = super.dw(a, b, c);
        if (this.m1 == null || this.mv == null || this.mx == null || this.mz == null) {
            d = false;
        }
        return d;
    }
    oy(a, b) {
        super.oy(a, b);
        let c = b.bs;
        let d = b.br;
        let e = this.getEffectiveViewport1(b);
        let f = this.l7;
        let g = this.ms;
        let h = new ScalerParams(0, c, d, f.b8, e);
        let i = ((() => {
            let $ret = new ScalerParams(0, c, d, g.b8, e);
            $ret.b = this.eh();
            return $ret;
        })());
        a.f.clear();
        a.m.clear();
        a.p.clear();
        let j = 0;
        let k = typeCast(ISortingAxis_$type, this.l7);
        if (k != null && (k.i$b == null || k.i$b.count != this.bz.count)) {
            return;
        }
        j = this.ny(c, d, e);
        let l = typeCast(FinancialPriceSeriesView.$, b);
        let m = this.eu;
        if (this.trendLineType != 0) {
            let n = new Array(this.bz.count);
            let o = 0;
            for (let p of fromEnum(this.np)) {
                n[o] = p;
                o++;
            }
            if (this.pi.b4) {
                this.pi.b2.prepareLineCore(a.p, this.trendLineType, boxArray$1(n), this.trendLinePeriod, (q) => this.l7.dv(q, h), (q) => this.ms.dv(q, i), ((() => {
                    let $ret = new TrendResolutionParams();
                    $ret.c = b.bu.b;
                    $ret.d = b.bu.c;
                    $ret.e = b.bu.d;
                    $ret.a = j;
                    $ret.b = m;
                    $ret.f = d;
                    return $ret;
                })()));
            }
        }
        let q = this.l7.dy(2, h) - this.l7.dy(1, h);
        for (let r = b.bu.c; r <= b.bu.d; ++r) {
            let s;
            if (k == null) {
                s = b.bu.getBucket(r);
            }
            else {
                let t = k.i$b._inner[r];
                let u = k.i$d(t);
                let v = this.m1.item(t);
                let w = this.mx.item(t);
                let x = this.mz.item(t);
                let y = this.mv.item(t);
                let z = v;
                let aa = w;
                let ab = x;
                let ac = y;
                let ad = u;
                while (r < b.bu.d) {
                    t = k.i$b._inner[r + 1];
                    ad = k.i$d(t);
                    if (ad - u > q * m) {
                        break;
                    }
                    r++;
                    aa = Math.max(aa, this.mx.item(t));
                    ab = Math.min(ab, this.mz.item(t));
                    ac = this.mv.item(t);
                }
                let ae = NaN;
                if (!isNaN_(u)) {
                    ae = this.l7.dv(u, h);
                }
                s = [ae, z, aa, ab, ac];
            }
            if (!isNaN_(s[0])) {
                if (k != null) {
                    s[0] = s[0] + j;
                }
                else {
                    s[0] = f.dv(s[0], h) + j;
                }
                s[1] = g.dv(s[1], i);
                s[2] = g.dv(s[2], i);
                s[3] = g.dv(s[3], i);
                s[4] = g.dv(s[4], i);
                a.f.add(s);
            }
        }
        return;
    }
    hv(a, b) {
        super.hv(a, b);
        let c = typeCast(FinancialPriceSeriesView.$, b);
        c.b8();
        if (a) {
            c.b3.count = 0;
        }
        if (c.b4 && c.b2 != null) {
            c.b2.g$d();
        }
    }
    get_nb() {
        return true;
    }
    o0(a, b) {
        super.o0(a, b);
        if (this.l7 == null || this.ms == null) {
            return;
        }
        let c = false;
        if (b.bx(a)) {
            c = true;
            b.bz(a);
        }
        this.mf.x(this, this.nf(), this.l7, runOn(this, this.lz), this.n4(b), this.n6(b));
        let d = false;
        let e = this.mf.c;
        if (e != null) {
            d = true;
        }
        let f = typeCast(FinancialPriceSeriesView.$, b);
        f.b7();
        f.b5 = false;
        if (f.b4) {
            f.b2.g$d();
        }
        if (this.trendLineType != 0) {
            f.b2.g$g(a.p);
        }
        if (d) {
            this.pq(a, b, c);
        }
        else {
            f.b3.count = 0;
            this.pp(a, b);
        }
    }
    eg() {
        let a = this.getEffectiveViewport1(this.bi);
        return this.pk(this.mn, a);
    }
    pq(a, b, c) {
        let d = this.pj;
        let e = this.getEffectiveViewport1(b);
        let f = this.pk(b, e);
        let g = (f - 1) / 2;
        let h = typeCast(FinancialPriceSeriesView.$, b);
        h.b5 = true;
        let i = a.f;
        let j = 0;
        let k = this.bz.count;
        let l = this.l7;
        let m = new ScalerParams(0, b.bs, b.br, l.b8, e);
        let n = this.k2;
        let o = this.pd;
        if (o == null) {
            o = n;
        }
        let p = this.k3;
        let q = this.p3;
        if (q == null) {
            q = p;
        }
        for (let r = 0; r < i.count; ++r) {
            let s = i._inner[r][0] - g;
            let t = i._inner[r][0];
            let u = i._inner[r][0] + g;
            let v = i._inner[r][1];
            let w = i._inner[r][2];
            let x = i._inner[r][3];
            let y = i._inner[r][4];
            if (isNaN_(v) || isNaN_(w) || isNaN_(x) || isNaN_(y)) {
                continue;
            }
            let z = h.b3.item(j);
            j++;
            let aa = v < y;
            let ab = new PathGeometry();
            if (c) {
                switch (d) {
                    case 0:
                        if (aa) {
                            let ac = v;
                            v = y;
                            y = ac;
                        }
                        let ad = new PathFigure();
                        ad._startPoint = { $type: Point_$type, x: t, y: x };
                        ad._segments.add(((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = { $type: Point_$type, x: t, y: v };
                            return $ret;
                        })()));
                        let ae = new PathFigure();
                        ae._startPoint = { $type: Point_$type, x: s, y: y };
                        ae._segments.add(((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = { $type: Point_$type, x: u, y: y };
                            return $ret;
                        })()));
                        ae._segments.add(((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = { $type: Point_$type, x: u, y: v };
                            return $ret;
                        })()));
                        ae._segments.add(((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = { $type: Point_$type, x: s, y: v };
                            return $ret;
                        })()));
                        ae._segments.add(((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = { $type: Point_$type, x: s, y: y };
                            return $ret;
                        })()));
                        let af = new PathFigure();
                        af._startPoint = { $type: Point_$type, x: t, y: y };
                        af._segments.add(((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = { $type: Point_$type, x: t, y: w };
                            return $ret;
                        })()));
                        ab.b.add(ad);
                        ab.b.add(ae);
                        ab.b.add(af);
                        break;
                    case 1:
                        let ag = new PathFigure();
                        ag._startPoint = { $type: Point_$type, x: s, y: v };
                        ag._segments.add(((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = { $type: Point_$type, x: t, y: v };
                            return $ret;
                        })()));
                        let ah = new PathFigure();
                        ah._startPoint = { $type: Point_$type, x: t, y: x };
                        ah._segments.add(((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = { $type: Point_$type, x: t, y: w };
                            return $ret;
                        })()));
                        let ai = new PathFigure();
                        ai._startPoint = { $type: Point_$type, x: t, y: y };
                        ai._segments.add(((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = { $type: Point_$type, x: u, y: y };
                            return $ret;
                        })()));
                        ab.b.add(ag);
                        ab.b.add(ah);
                        ab.b.add(ai);
                        break;
                }
            }
            if (aa) {
                this.mf.al = o;
                this.mf.ah = o;
                this.mf.am = this.mf.ai = q;
                this.mf.f = true;
            }
            else {
                this.mf.al = n;
                this.mf.ah = n;
                this.mf.am = this.mf.ai = p;
                this.mf.f = false;
            }
            this.ox(i, r, k, l, m, b.n);
            if (d == 1) {
                this.mf.ae(z, true, false, false, false);
            }
            else {
                this.mf.ae(z, false, false, false, false);
            }
            if (c) {
                z.aj = ab;
            }
        }
        h.b3.count = j;
        h.b9();
    }
    pk(a, b) {
        let c = this.l7.jq(a.bs, a.br, b);
        c = Math.max(c, this.eu * 0.9);
        c = Math.max(c, 3);
        return c;
    }
    pp(a, b) {
        let c = this.pj;
        let d = this.getEffectiveViewport1(b);
        let e = this.pk(b, d);
        let f = (e - 1) / 2;
        let g = typeCast(FinancialPriceSeriesView.$, b);
        let h = g.ch();
        let i = g.cg();
        let j = a.f;
        for (let k = 0; k < j.count; ++k) {
            let l = j._inner[k][0] - f;
            let m = j._inner[k][0];
            let n = j._inner[k][0] + f;
            let o = j._inner[k][1];
            let p = j._inner[k][2];
            let q = j._inner[k][3];
            let r = j._inner[k][4];
            if (isNaN_(o) || isNaN_(p) || isNaN_(q) || isNaN_(r)) {
                continue;
            }
            let s = o < r;
            let t = s ? i : h;
            switch (c) {
                case 0:
                    if (s) {
                        let u = o;
                        o = r;
                        r = u;
                    }
                    t.c.add(((() => {
                        let $ret = new LineGeometry();
                        $ret.c = { $type: Point_$type, x: m, y: q };
                        $ret.b = { $type: Point_$type, x: m, y: o };
                        return $ret;
                    })()));
                    t.c.add(((() => {
                        let $ret = new RectangleGeometry();
                        $ret.d = new Rect(0, l, r, n - l, o - r);
                        return $ret;
                    })()));
                    t.c.add(((() => {
                        let $ret = new LineGeometry();
                        $ret.c = { $type: Point_$type, x: m, y: r };
                        $ret.b = { $type: Point_$type, x: m, y: p };
                        return $ret;
                    })()));
                    break;
                case 1:
                    t.c.add(((() => {
                        let $ret = new LineGeometry();
                        $ret.c = { $type: Point_$type, x: l, y: o };
                        $ret.b = { $type: Point_$type, x: m, y: o };
                        return $ret;
                    })()));
                    t.c.add(((() => {
                        let $ret = new LineGeometry();
                        $ret.c = { $type: Point_$type, x: m, y: q };
                        $ret.b = { $type: Point_$type, x: m, y: p };
                        return $ret;
                    })()));
                    t.c.add(((() => {
                        let $ret = new LineGeometry();
                        $ret.c = { $type: Point_$type, x: m, y: r };
                        $ret.b = { $type: Point_$type, x: n, y: r };
                        return $ret;
                    })()));
                    break;
            }
        }
    }
    fv(a, b) {
        if (this.pi.b4 && a == this.pi.b2.g$j) {
            return null;
        }
        return super.fv(a, b);
    }
    jn() {
        super.jn();
        if (this.fh < 0) {
            return;
        }
        this.pi.cf();
    }
    h4(a) {
        super.h4(a);
        if (this.pi.b4) {
            this.a2.exportTrendlineData(this, a, this.pi.b2.g$j);
        }
    }
    jh(a, b) {
        super.jh(a, b);
        this.p3 = b;
    }
}
FinancialPriceSeries.$t = markType(FinancialPriceSeries, 'FinancialPriceSeries', FinancialSeries.$, [ITrendLineSeries_$type]);
FinancialPriceSeries.ps = DependencyProperty.i("ActualTrendLineBrush", Brush.$, FinancialPriceSeries.$, new PropertyMetadata(2, null, (a, b) => a.raisePropertyChanged("ActualTrendLineBrush", b.oldValue, b.newValue)));
Type.dep(DependencyProperty, PropertyMetadata, FinancialPriceSeries, 'raisePropertyChanged', ['DisplayType:pj:pt', [PriceDisplayType_$type, enumGetBox(PriceDisplayType_$type, 0)], 'NegativeOutline:p3:pu', [Brush.$, null], 'TrendLineType::p0', [TrendLineType_$type, enumGetBox(TrendLineType_$type, 0)], 'TrendLineThickness::pz', [1, 1.5], 'TrendLinePeriod::py', [1, 7], 'TrendLineBrush::pv', [Brush.$, null], 'TrendLineZIndex:pm:p1', [1, 1001], 'TrendLineDashArray:p4:pw', [DoubleCollection.$], 'TrendLineDashCap:p5:px', [PenLineCap_$type, enumGetBox(PenLineCap_$type, 0)]]);
/**
 * @hidden
 */
export class FinancialPriceSeriesView extends FinancialSeriesView {
    constructor(a) {
        super(a);
        this.b0 = null;
        this.b3 = null;
        this.b6 = null;
        this.ck = ((() => {
            let $ret = new Path();
            $ret.aj = new GeometryGroup();
            return $ret;
        })());
        this.cj = ((() => {
            let $ret = new Path();
            $ret.aj = new GeometryGroup();
            return $ret;
        })());
        this.b1 = null;
        this.ci = new Path();
        this.b5 = false;
        this.b0 = a;
        this.b6 = new List$1(Path.$, 0);
        this.b3 = ((() => {
            let $ret = new Pool$1(Path.$);
            $ret.create = runOn(this, this.cl);
            $ret.activate = runOn(this, this.cb);
            $ret.disactivate = runOn(this, this.cd);
            $ret.destroy = runOn(this, this.cc);
            return $ret;
        })());
    }
    cl() {
        let a = new Path();
        this.b6.add(a);
        a._visibility = 1;
        return a;
    }
    cb(a) {
        a._visibility = 0;
    }
    cd(a) {
        a._visibility = 1;
    }
    cc(a) {
        this.b6.remove(a);
    }
    bv() {
        return new FinancialPriceBucketCalculator(this);
    }
    ap() {
        super.ap();
        if (!this.n) {
            this.bw.pd = ((() => {
                let $ret = new Brush();
                $ret.fill = "#C62828";
                return $ret;
            })());
            this.b0.p3 = this.bw.pd;
            this.bw.eu = 5;
            this.bw.ey = 1;
        }
    }
    get b2() {
        if (this.b1 == null) {
            this.b1 = CategoryTrendLineManagerFactory.a(this.b1, this.e.ap(), this.e.jw, this.e, this.e.b2);
        }
        return this.b1;
    }
    set b2(a) {
        this.b1 = a;
    }
    get b4() {
        return this.b1 != null;
    }
    ce() {
        if (this.b0.pj == 1) {
            this.ck._stroke = this.e.k2;
        }
        else {
            this.ck._stroke = this.e.k3;
        }
        if (this.b0.pj == 1) {
            this.cj._stroke = this.bw.pd;
        }
        else {
            this.cj._stroke = this.b0.p3;
        }
    }
    b8() {
        this.an();
        this.b3.count = 0;
        this.b7();
    }
    b7() {
        let a = typeCast(GeometryGroup.$, this.ck.aj);
        let b = typeCast(GeometryGroup.$, this.cj.aj);
        Extensions.d(a);
        Extensions.d(b);
    }
    ch() {
        this.an();
        return typeCast(GeometryGroup.$, this.ck.aj);
    }
    cg() {
        this.an();
        return typeCast(GeometryGroup.$, this.cj.aj);
    }
    cf() {
        this.b0.p2 = null;
        if (this.b0.trendLineBrush != null) {
            this.b0.p2 = this.b0.trendLineBrush;
        }
        else {
            this.b0.p2 = this.b0.k2;
        }
    }
    a8() {
        super.a8();
        this.ck.ac = this.e.ey;
        this.ck.ai = this.e.la;
        this.ck.ad = this.e.lb;
        if (this.b0.pj == 1) {
            this.ck._stroke = this.e.k2;
        }
        else {
            this.ck._stroke = this.e.k3;
            this.ck._fill = this.e.k2;
        }
        this.cj.ac = this.e.ey;
        this.cj.ai = this.e.la;
        this.cj.ad = this.e.lb;
        if (this.b0.pj == 1) {
            this.cj._stroke = this.bw.pd;
        }
        else {
            this.cj._stroke = this.b0.p3;
            this.cj._fill = this.bw.pd;
        }
    }
    a9() {
        super.a9();
        let a = this.bl();
        this.ck.ac = this.e.ey + 3;
        if (this.b0.pj == 1) {
            this.ck._stroke = a;
        }
        else {
            this.ck._stroke = a;
            this.ck._fill = a;
        }
        this.cj.ac = this.e.ey + 3;
        if (this.b0.pj == 1) {
            this.cj._stroke = a;
        }
        else {
            this.cj._stroke = a;
            this.cj._fill = a;
        }
    }
    z(a) {
        return this.b6._inner[a];
    }
    y(a) {
        let b = this.b6._inner[a];
        this.ci._visibility = b._visibility;
        this.ci.aj = b.aj;
        let c = this.bm(a);
        this.ci._fill = c;
        this.ci._stroke = c;
        this.ci.ac = this.e.ey + 3;
        return this.ci;
    }
    a3(a, b) {
        super.a3(a, b);
        if (a.d) {
            if (this.b5) {
                for (let c = 0; c < this.b6.count; c++) {
                    let d = this.x(c, b);
                    if (d._visibility == 0) {
                        a.s(d);
                    }
                }
            }
            else {
                a.s(this.ck);
                a.s(this.cj);
            }
        }
    }
    a2(a, b) {
        if (a.d) {
            if (this.b0.trendLineType != 0 && !b) {
                let c = this.b2.g$j;
                c.ac = this.b0.trendLineThickness;
                c._stroke = this.b0.p2;
                c.ai = this.b0.p4;
                c.ad = this.b0.p5;
                a.u(c);
            }
        }
        super.a2(a, b);
    }
    ai(a) {
        super.ai(a);
        this.e.a2.exportPathData(a, this.ck, "positivePathShape", ["Positive", "Main"]);
        this.e.a2.exportPathData(a, this.cj, "negativePathShape", ["Negative"]);
    }
    b9() {
        this.an();
    }
    ca() {
        if (this.b4) {
            this.b1 = CategoryTrendLineManagerFactory.a(this.b1, this.e.ap(), this.e.jw, this.e, this.e.b2);
        }
    }
}
FinancialPriceSeriesView.$t = markType(FinancialPriceSeriesView, 'FinancialPriceSeriesView', FinancialSeriesView.$);
