/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { XYChart } from "./XYChart";
import { typeCast, runOn, delegateCombine, enumGetBox, markType, TypeRegistrar, getInstanceType } from "igniteui-react-core/ES2015/type";
import { CategoryChartType_$type } from "./CategoryChartType";
import { CategorySeriesMarkerCollisionAvoidance_$type } from "./CategorySeriesMarkerCollisionAvoidance";
import { CategoryTransitionInMode_$type } from "./CategoryTransitionInMode";
import { TransitionInSpeedType_$type } from "./TransitionInSpeedType";
import { CategoryXAxis } from "./CategoryXAxis";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { DataSeriesType_$type } from "igniteui-react-core/ES2015/DataSeriesType";
import { NumericYAxis } from "./NumericYAxis";
import { IDataSeriesAdapterRule_$type } from "igniteui-react-core/ES2015/IDataSeriesAdapterRule";
import { SimpleCategorySeriesRule } from "igniteui-react-core/ES2015/SimpleCategorySeriesRule";
import { SubCollectionsRule } from "igniteui-react-core/ES2015/SubCollectionsRule";
import { Series } from "./Series";
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { ArrayExtension } from "igniteui-react-core/ES2015/ArrayExtension";
import { Brush } from "igniteui-react-core/ES2015/Brush";
import { AxisLabelSettings } from "./AxisLabelSettings";
import { stringIsNullOrEmpty } from "igniteui-react-core/ES2015/string";
/**
 * @hidden
 */
export class CategoryChart extends XYChart {
    constructor() {
        super();
        this.p1 = 1000;
        this.o5 = null;
        this.op = 9;
        this.or = 1;
        this.o9 = false;
        this.ot = 0;
        this.o3 = 0;
        this.pi = 0;
        this.pj = 0;
        this.ph = 0;
        this.pk = 0;
        this.pl = NaN;
        this.pb = false;
        this.p2 = 10;
        this.pn = NaN;
        this.pm = NaN;
        this.po = 0;
        this.ol = null;
        this.om = null;
        this.pa = true;
        this.o7 = false;
        this.o8 = false;
        this.f6();
    }
    gj() {
        super.gj();
        if (this.dataChart == null) {
            return;
        }
        let a = this.dataChart.bn.i.e();
        this.on = a.d;
        this.oo = a.e;
        if (this.nx == null) {
            this.nx = a.k;
        }
        if (this.n4 == null) {
            this.n4 = a.k;
        }
    }
    gl(a, b) {
        super.gl(a, b);
        a.fj = this.p3;
        a.bv = this.o6;
    }
    g2(a, b, c) {
        super.g2(a, b, c);
        switch (a) {
            case "TransitionInDuration":
                this.qs((d) => d.fj = this.p3);
                break;
            case "TransitionInEasingFunction":
                this.qs((d) => d.bv = this.o6);
                break;
        }
    }
    get p3() {
        return this.p1;
    }
    set p3(a) {
        let b = this.p3;
        if (a != b) {
            this.p1 = a;
            this.g1("TransitionInDuration", b, this.p3);
        }
    }
    get o6() {
        return this.o5;
    }
    set o6(a) {
        let b = this.o6;
        if (a != b) {
            this.o5 = a;
            this.g1("TransitionInEasingFunction", b, this.o6);
        }
    }
    p6() {
        let cvd_ = this.dj();
        cvd_.scaleByViewport();
        return (cvd_.serialize());
    }
    ge(a) {
        super.ge(a);
        a.cd = this.bg;
    }
    gk(a, b) {
        super.gk(a, b);
        let c = typeCast(HorizontalAnchoredCategorySeries.$, a);
        if (c == null) {
            return;
        }
        c.oz = this.os;
        c.nx = this.pe;
        c.ng = this.ou;
        c.bp = this.o4;
        c.trendLineBrush = ArrayExtension.getModulus$1(Brush.$, this.o, b);
        c.trendLineType = this.av;
        c.trendLineThickness = this.c6;
        c.l0 = this.ai(a, b);
        if (a.cz) {
            a.jh(ArrayExtension.getModulus$1(Brush.$, this.on, b), ArrayExtension.getModulus$1(Brush.$, this.oo, b));
        }
    }
    ov() {
        return new CategoryXAxis();
    }
    oz() {
        return new NumericYAxis();
    }
    f3() {
        this.xAxis = this.ov();
        this.xAxis.name = "xAxis";
        let a = this.xAxis;
        a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.qu));
        this.yAxis = this.oz();
        this.yAxis.name = "yAxis";
        let b = this.yAxis;
        b.propertyChanged = delegateCombine(b.propertyChanged, runOn(this, this.qv));
        if (this.xAxis.aw == null) {
            this.xAxis.aw = new AxisLabelSettings();
        }
        if (this.yAxis.aw == null) {
            this.yAxis.aw = new AxisLabelSettings();
        }
    }
    m3(a) {
        super.m3(a);
        a.jn = this.pf;
    }
    get oq() {
        return this.op;
    }
    set oq(a) {
        if (a != this.op) {
            let b = this.oq;
            this.op = a;
            this.g1("ChartType", enumGetBox(CategoryChartType_$type, b), enumGetBox(CategoryChartType_$type, this.oq));
        }
    }
    get os() {
        return this.or;
    }
    set os(a) {
        let b = this.os;
        if (a != b) {
            this.or = a;
            this.g1("MarkerCollisionAvoidance", enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, b), enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, this.os));
        }
    }
    get pe() {
        return this.o9;
    }
    set pe(a) {
        let b = this.pe;
        if (a != b) {
            this.o9 = a;
            this.g1("IsTransitionInEnabled", b, this.pe);
        }
    }
    get ou() {
        return this.ot;
    }
    set ou(a) {
        let b = this.ou;
        if (a != b) {
            this.ot = a;
            this.g1("TransitionInMode", enumGetBox(CategoryTransitionInMode_$type, b), enumGetBox(CategoryTransitionInMode_$type, this.ou));
        }
    }
    get o4() {
        return this.o3;
    }
    set o4(a) {
        let b = this.o4;
        if (a != b) {
            this.o3 = a;
            this.g1("TransitionInSpeedType", enumGetBox(TransitionInSpeedType_$type, b), enumGetBox(TransitionInSpeedType_$type, this.o4));
        }
    }
    get ps() {
        return this.pi;
    }
    set ps(a) {
        let b = this.ps;
        if (a != b) {
            this.pi = a;
            this.g1("XAxisInterval", b, this.ps);
        }
    }
    get pt() {
        return this.pj;
    }
    set pt(a) {
        let b = this.pt;
        if (a != b) {
            this.pj = a;
            this.g1("XAxisMinorInterval", b, this.pt);
        }
    }
    get pr() {
        return this.ph;
    }
    set pr(a) {
        let b = this.pr;
        if (a != b) {
            this.ph = a;
            this.g1("XAxisGap", b, this.pr);
        }
    }
    get pu() {
        return this.pk;
    }
    set pu(a) {
        let b = this.pu;
        if (a != b) {
            this.pk = a;
            this.g1("XAxisOverlap", b, this.pu);
        }
    }
    get px() {
        return this.pl;
    }
    set px(a) {
        let b = this.px;
        if (a != b) {
            this.pl = a;
            this.g1("YAxisInterval", b, this.px);
        }
    }
    get pg() {
        return this.pb;
    }
    set pg(a) {
        let b = this.pg;
        if (a != b) {
            this.pb = a;
            this.g1("YAxisIsLogarithmic", b, this.pg);
        }
    }
    get p4() {
        return this.p2;
    }
    set p4(a) {
        let b = this.p4;
        if (a != b) {
            this.p2 = a;
            this.g1("YAxisLogarithmBase", b, this.p4);
        }
    }
    get pz() {
        return this.pn;
    }
    set pz(a) {
        let b = this.pz;
        if (a != b) {
            this.pn = a;
            this.g1("YAxisMinimumValue", b, this.pz);
        }
    }
    get py() {
        return this.pm;
    }
    set py(a) {
        let b = this.py;
        if (a != b) {
            this.pm = a;
            this.g1("YAxisMaximumValue", b, this.py);
        }
    }
    get p0() {
        return this.po;
    }
    set p0(a) {
        let b = this.p0;
        if (a != b) {
            this.po = a;
            this.g1("YAxisMinorInterval", b, this.p0);
        }
    }
    get pq() {
        return this.xAxis.la;
    }
    get pp() {
        return this.xAxis.k9;
    }
    get pw() {
        return this.yAxis.j3;
    }
    get pv() {
        return this.yAxis.j2;
    }
    get on() {
        return this.ol;
    }
    set on(a) {
        let b = this.on;
        if (a != b) {
            this.ol = a;
            this.g1("NegativeBrushes", b, this.on);
        }
    }
    get oo() {
        return this.om;
    }
    set oo(a) {
        let b = this.oo;
        if (a != b) {
            this.om = a;
            this.g1("NegativeOutlines", b, this.oo);
        }
    }
    get pf() {
        return this.pa;
    }
    set pf(a) {
        let b = this.pf;
        if (a != b) {
            this.pa = a;
            this.g1("YAxisAbbreviateLargeNumbers", b, this.pf);
        }
    }
    get pc() {
        return this.o7;
    }
    set pc(a) {
        let b = this.pc;
        if (a != b) {
            this.o7 = a;
            this.g1("IsCategoryHighlightingEnabled", b, this.pc);
        }
    }
    get pd() {
        return this.o8;
    }
    set pd(a) {
        let b = this.pd;
        if (a != b) {
            this.o8 = a;
            this.g1("IsItemHighlightingEnabled", b, this.pd);
        }
    }
    get_b5() {
        let a = new List$1(DataSeriesType_$type, 0);
        if (TypeRegistrar.isRegistered("AreaSeries")) {
            a.add(2);
        }
        if (TypeRegistrar.isRegistered("ColumnSeries")) {
            a.add(1);
        }
        if (TypeRegistrar.isRegistered("LineSeries")) {
            a.add(0);
        }
        if (TypeRegistrar.isRegistered("PointSeries")) {
            a.add(10);
        }
        if (TypeRegistrar.isRegistered("SplineSeries")) {
            a.add(6);
        }
        if (TypeRegistrar.isRegistered("SplineAreaSeries")) {
            a.add(7);
        }
        if (TypeRegistrar.isRegistered("StepAreaSeries")) {
            a.add(5);
        }
        if (TypeRegistrar.isRegistered("StepLineSeries")) {
            a.add(4);
        }
        if (TypeRegistrar.isRegistered("WaterfallSeries")) {
            a.add(8);
        }
        return a;
    }
    get b5() {
        return this.get_b5();
    }
    qu(a, b) {
        switch (b.propertyName) {
            case "ActualMinimum":
                this.g8("XAxisActualMinimum");
                break;
            case "ActualMaximum":
                this.g8("XAxisActualMaximum");
                break;
        }
    }
    qv(a, b) {
        switch (b.propertyName) {
            case "ActualMinimumValue":
                this.g8("YAxisActualMinimum");
                break;
            case "ActualMaximumValue":
                this.g8("YAxisActualMaximum");
                break;
        }
    }
    hj() {
        super.hj();
        this.xAxis.e6 = this.kn == null ? XYChart.kv(this.xAxis, this.v.dataSeries) : this.kn;
        this.xAxis.itemsSource = this.dataChart != null && this.dataChart.series.count > 0 ? this.dataChart.series._inner[0].itemsSource : null;
    }
    get xAxis() {
        return this._xAxis;
    }
    set xAxis(a) {
        this._xAxis = a;
    }
    get yAxis() {
        return this._yAxis;
    }
    set yAxis(a) {
        this._yAxis = a;
    }
    oy(a, b) {
        switch (a) {
            case 2: return this.ar(1);
            case 3: return this.ar(10);
            case 0: return this.ar(0);
            case 1: return this.ar(2);
            case 6: return this.ar(6);
            case 7: return this.ar(7);
            case 4: return this.ar(4);
            case 5: return this.ar(5);
            case 8: return this.ar(8);
            case 9: return this.ox(b);
            default: return this.ar(1);
        }
    }
    ox(a) {
        return this.ar(a);
    }
    u(a) {
        switch (this.oq) {
            case 1: return 2;
            case 0: return 0;
            case 3: return 10;
            case 6: return 6;
            case 7: return 7;
            case 5: return 5;
            case 4: return 4;
            case 8: return 8;
            case 9: return a.suggestedSeries;
            default:
            case 2: return 1;
        }
    }
    aq(a, b) {
        let c = this.oy(this.oq, a.suggestedSeries);
        c.pc = a.findMatchingHint(0).path;
        c.xAxis = this.xAxis;
        c.yAxis = this.yAxis;
        return c;
    }
    hh(a) {
        if (a.suggestedSecondaryAxis == 2) {
            this.yAxis.js = true;
            this.yAxis.kf = 10;
        }
    }
    hk() {
        this.yAxis.js = this.pg;
        this.yAxis.kf = this.p4;
    }
    get_b4() {
        return ((() => {
            let $ret = new List$1(IDataSeriesAdapterRule_$type, 0);
            $ret.add(new SimpleCategorySeriesRule());
            $ret.add(new SubCollectionsRule());
            return $ret;
        })());
    }
    get b4() {
        return this.get_b4();
    }
    f1(a, b) {
        let c = typeCast(HorizontalAnchoredCategorySeries.$, a);
        if (c != null) {
            c.oz = this.os;
            c.l0 = this.ai(a, b);
        }
    }
    qs(a) {
        this.qt((b, c) => a(b));
    }
    qt(a) {
        if (this.dataChart == null) {
            return;
        }
        for (let b = 0; b < this.dataChart.series.count; b++) {
            let c = typeCast(HorizontalAnchoredCategorySeries.$, this.dataChart.series._inner[b]);
            if (c == null) {
                continue;
            }
            a(c, b);
        }
    }
    h7() {
        return this.xAxis;
    }
    h8() {
        return this.yAxis;
    }
    o1() {
        return this.ar(30);
    }
    o2() {
        return this.ar(31);
    }
    b1(a, b) {
        let c = super.b1(a, b);
        if (c != null) {
            let d = new List$1(Series.$, 0);
            if (this.o7) {
                d.add(this.o1());
            }
            if (this.o8) {
                d.add(this.o2());
            }
            for (let e = 0; e < d.count; e++) {
                let f = d._inner[e];
                f.name = a + getInstanceType(f).typeName;
                c.add(f);
            }
        }
        return c;
    }
    ho(a, b, c) {
        super.ho(a, b, c);
        if (this.v.dataSeries.count > 0) {
            if (stringIsNullOrEmpty(this.ea)) {
                this.ac.setXMemberPath(a, c.getMemberPathFor(16));
            }
            if (stringIsNullOrEmpty(this.ec)) {
                this.ac.setYMemberPath(a, c.getMemberPathFor(0));
            }
            if (stringIsNullOrEmpty(this.d6)) {
                this.ac.setLabelMemberPath(a, c.getMemberPathFor(0));
            }
            if (stringIsNullOrEmpty(this.d3)) {
                this.ac.setContentMemberPath(a, c.getMemberPathFor(0));
            }
        }
    }
    g1(a, b, c) {
        super.g1(a, b, c);
        switch (a) {
            case "ChartType":
                this.hj();
                break;
            case "MarkerCollisionAvoidance":
                this.qs((d) => d.oz = this.os);
                break;
            case "IsTransitionInEnabled":
                this.qs((d) => d.nx = this.pe);
                break;
            case "TransitionInMode":
                this.qs((d) => d.ng = this.ou);
                break;
            case "TransitionInSpeedType":
                this.qs((d) => d.bp = this.o4);
                break;
            case "XAxisInterval":
                this.xAxis.k5 = this.ps;
                break;
            case "XAxisMinorInterval":
                this.xAxis.k6 = this.pt;
                break;
            case "XAxisGap":
                this.xAxis.jn = this.pr;
                break;
            case "XAxisOverlap":
                this.xAxis.ju = this.pu;
                break;
            case "YAxisInterval":
                this.yAxis.j7 = this.px;
                break;
            case "YAxisIsLogarithmic":
                this.yAxis.js = this.pg;
                break;
            case "YAxisLogarithmBase":
                this.yAxis.kf = this.p4;
                break;
            case "YAxisMinimumValue":
                this.yAxis.kb = this.pz;
                break;
            case "YAxisMaximumValue":
                this.yAxis.ka = this.py;
                break;
            case "YAxisMinorInterval":
                this.yAxis.kc = this.p0;
                break;
            case "NegativeBrushes":
            case "NegativeOutlines":
                this.qt((d, e) => {
                    if (d.cz) {
                        d.jh(ArrayExtension.getModulus$1(Brush.$, this.on, e), ArrayExtension.getModulus$1(Brush.$, this.oo, e));
                    }
                });
                break;
            case "YAxisAbbreviateLargeNumbers":
                this.m9((d) => d.jn = this.pf);
                break;
            case "IsCategoryHighlightingEnabled":
            case "IsItemHighlightingEnabled":
                this.hj();
                break;
        }
    }
}
CategoryChart.$t = markType(CategoryChart, 'CategoryChart', XYChart.$);
