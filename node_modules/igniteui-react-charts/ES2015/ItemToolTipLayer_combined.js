/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnnotationLayer } from "./AnnotationLayer";
import { Series } from "./Series";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { ItemTooltipLayerFrame } from "./ItemTooltipLayerFrame";
import { Type, Base, fromEnum, Point_$type, markType, runOn, String_$type, typeCast } from "igniteui-react-core/ES2015/type";
import { Pool$1 } from "igniteui-react-core/ES2015/Pool$1";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { ItemTooltipCollisionInfo } from "./ItemTooltipCollisionInfo";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { DataContext } from "igniteui-react-core/ES2015/DataContext";
import { Size } from "igniteui-react-core/ES2015/Size";
import { DeviceUtils } from "igniteui-react-core/ES2015/DeviceUtils";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { isNaN_ } from "igniteui-react-core/ES2015/number";
import { AnnotationLayerView } from "./AnnotationLayerView";
import { PointerTooltip } from "./PointerTooltip";
import { DomWrapper_$type } from "igniteui-react-core/ES2015/dom";
/**
 * @hidden
 */
export class ItemToolTipLayer extends AnnotationLayer {
    constructor() {
        super();
        let a = new ItemTooltipLayerFrame();
        let b = new ItemTooltipLayerFrame();
        let c = new ItemTooltipLayerFrame();
        let d = this.fi / 1000;
        this.l1 = a;
        this.l0 = b;
        this.l2 = c;
        this.ab = ItemToolTipLayer.$;
    }
    bf() {
        return new ItemToolTipLayerView(this);
    }
    it(a) {
        super.it(a);
        this.m3 = a;
    }
    get_cn() {
        return true;
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case ItemToolTipLayer.$$p[1]:
                this.jc(true);
                break;
            case ItemToolTipLayer.$$p[2]:
                this.jc(true);
                break;
            case ItemToolTipLayer.$$p[0]:
                this.jc(true);
                break;
        }
    }
    mk(a, b) {
        if (this.m4 == null || this.m4 == a) {
            if (!this.aq.c) {
                this.jc(b);
            }
        }
    }
    l7(a) {
        if (!super.l7(a)) {
            return false;
        }
        let b = this.mf(a);
        if (!b.c) {
            return false;
        }
        return true;
    }
    mm(a, b) {
        super.mm(a, b);
        let c = a;
        let d = this.m3.b2;
        let e = this.m7;
        let f = this.m6;
        c.o.clear();
        c.i.clear();
        c.n.clear();
        c.g.clear();
        c.f.clear();
        c.l.clear();
        c.j.clear();
        c.m.clear();
        c.k.clear();
        c.h.clear();
        if (isNaN_(this.m0.x) && isNaN_(this.m0.y)) {
            d.count = 0;
            return;
        }
        let g = 0;
        if (this.l7(this.m4)) {
            this.nd(this.m4, c, e, f, 0);
            g++;
        }
        else {
            for (let h of fromEnum(this.bs.series)) {
                if (this.l7(h)) {
                    this.nd(h, c, e, f, g);
                    g++;
                }
            }
            this.nc(c);
        }
        d.count = g;
    }
    nc(a) {
        let b = new List$1(ItemTooltipCollisionInfo.$, 0);
        for (let c = 0; c < a.f.count; c++) {
            let d = new ItemTooltipCollisionInfo();
            d.d = c;
            d.e = { $type: Point_$type, x: a.f._inner[c], y: a.g._inner[c] };
            d.c = a.m._inner[c];
            d.a = a.k._inner[c];
            d.b = a.o._inner[c];
            if (isNaN_(d.e.x) || isNaN_(d.e.y)) {
                continue;
            }
            b.add(d);
        }
        b.aa((e, f) => {
            if (e.e.y < f.e.y) {
                return -1;
            }
            if (e.e.y > f.e.y) {
                return 1;
            }
            if (e.b < f.b) {
                return -1;
            }
            if (e.b > f.b) {
                return 1;
            }
            return 0;
        });
        let e = this.m5(b);
        if (!e) {
            return;
        }
        for (let f = 0; f < b.count - 1; f++) {
            let g = b._inner[f];
            let h = b._inner[f + 1];
            let i = new Rect(0, g.e.x, g.e.y, g.c, g.a);
            let j = new Rect(0, h.e.x, h.e.y, h.c, h.a);
            if (i.intersectsWith(j) || i.top > j.bottom) {
                h.e = { $type: Point_$type, x: h.e.x, y: i.bottom + 1 };
            }
        }
        if (b._inner[b.count - 1].e.y + b._inner[b.count - 1].a > this.bi.br.height) {
            b._inner[b.count - 1].e = { $type: Point_$type, x: b._inner[b.count - 1].e.x, y: b._inner[b.count - 1].e.y - ((b._inner[b.count - 1].e.y + b._inner[b.count - 1].a) - this.bi.br.height) };
        }
        for (let k = b.count - 1; k >= 1; k--) {
            let l = b._inner[k];
            let m = b._inner[k - 1];
            let n = new Rect(0, l.e.x, l.e.y, l.c, l.a);
            let o = new Rect(0, m.e.x, m.e.y, m.c, m.a);
            if (n.intersectsWith(o) || n.top < o.bottom) {
                m.e = { $type: Point_$type, x: m.e.x, y: n.top - (o.height + 1) };
            }
        }
        for (let p = 0; p < b.count; p++) {
            let q = b._inner[p].d;
            let r = b._inner[p];
            a.f._inner[q] = r.e.x;
            a.g._inner[q] = r.e.y;
        }
    }
    m5(a) {
        if (a.count <= 1) {
            return false;
        }
        let b = this.bi.br;
        for (let c = 0; c < a.count - 1; c++) {
            let d = a._inner[c];
            let e = a._inner[c + 1];
            let f = new Rect(0, d.e.x, d.e.y, d.c, d.a);
            let g = new Rect(0, e.e.x, e.e.y, e.c, e.a);
            if (f.intersectsWith(g)) {
                return true;
            }
        }
        return false;
    }
    nd(a, b, c, d, e) {
        let f = this.mf(a);
        if (!f.c) {
            return;
        }
        let g = a.lk(f.d, c, d);
        let h = this.m3.b2;
        let i = this.m8(a);
        let j = this.m0;
        if (!c) {
            j = this.ln(g);
        }
        let k = a.fp(j);
        let l = h.item(e);
        let m = this.bi.br;
        let n = null;
        if (a.co && k != null) {
            n = a.as(k);
        }
        else {
            n = new DataContext();
            n.item = k;
            n.series = a;
        }
        if (!this.m3.b3(a, l, i, n)) {
            return;
        }
        let o = this.m3.cc(l, i, n);
        b.i.add1(l);
        b.j.add1(n);
        b.l.add1(i);
        let p = g.x;
        let q = g.x;
        q = Math.max(q, m.left);
        q = Math.min(q, m.right);
        b.n.add(q);
        let r = g.y;
        r = Math.max(r, m.top);
        r = Math.min(r, m.bottom);
        b.o.add(r);
        let s = DeviceUtils.g(10);
        let t = g.x + s;
        if (t + o.width > m.right) {
            t = (p - o.width) - s;
        }
        if (t < m.left) {
            t = m.left;
        }
        b.f.add(t);
        let u = (g.y - o.height) - s;
        if (u + o.height > m.bottom) {
            u = (m.bottom - o.height) - s;
        }
        if (u < m.top) {
            u = m.top;
        }
        b.g.add(u);
        b.m.add(o.width);
        b.k.add(o.height);
        let v = this.k2;
        if (v == null) {
            v = this.k4;
        }
        if (v == null) {
            v = a.k2;
        }
        b.h.add(v);
    }
    m8(a) {
        return a.toolTip;
    }
    mp(a, b) {
        super.mp(a, b);
        let c = a;
        let d = c.o.count;
        let e = b.br.left;
        let f = b.br.right;
        let g = b.br.top;
        let h = b.br.bottom;
        for (let i = 0; i < d; i++) {
            if (isNaN_(c.n._inner[i]) || isNaN_(c.o._inner[i]) || isNaN_(c.f._inner[i]) || isNaN_(c.g._inner[i]) || c.l._inner[i] == null || c.j._inner[i] == null) {
                this.m3.ca(c.i._inner[i]);
                continue;
            }
            let j = c.f._inner[i];
            let k = c.g._inner[i];
            let l = c.m._inner[i];
            let m = c.k._inner[i];
            let n = false;
            if (j < e && Math.abs(j - e) > 1) {
                n = true;
            }
            if (k < g && Math.abs(k - g) > 1) {
                n = true;
            }
            if ((j + l) > f && Math.abs((j + l) - f) > 1) {
                n = true;
            }
            if ((k + m) > h && Math.abs((k + m) - h) > 1) {
                n = true;
            }
            if (n) {
                this.m3.ca(c.i._inner[i]);
                continue;
            }
            let o = c.i._inner[i];
            let p = Math.min(c.f._inner[i], c.n._inner[i]);
            let q = Math.min(c.g._inner[i], c.o._inner[i]);
            let r = c.n._inner[i] - c.f._inner[i];
            let s = c.o._inner[i] - c.g._inner[i];
            this.m3.cb(o, p, q, r, s);
        }
    }
    c8() {
        return true;
    }
}
ItemToolTipLayer.$t = markType(ItemToolTipLayer, 'ItemToolTipLayer', AnnotationLayer.$);
Type.dep(DependencyProperty, PropertyMetadata, ItemToolTipLayer, 'raisePropertyChanged', ['SkipUnknownValues:m6:ne', [0, true], 'TargetSeries:m4:nf', [Series.$, null], 'UseInterpolation:m7:ng', [0, false]]);
/**
 * @hidden
 */
export class ItemToolTipLayerView extends AnnotationLayerView {
    constructor(a) {
        super(a);
        this.b1 = null;
        this.b2 = null;
        this.b4 = null;
        this._htmlTest = null;
        this.b1 = a;
        this.b4 = new List$1(PointerTooltip.$, 0);
    }
    ap() {
        super.ap();
        this.b2 = ((() => {
            let $ret = new Pool$1(Base.$);
            $ret.create = runOn(this, this.b5);
            $ret.activate = runOn(this, this.b7);
            $ret.disactivate = runOn(this, this.b9);
            $ret.destroy = runOn(this, this.b8);
            return $ret;
        })());
        this.htmlTest = /^[^<]*(<[\w\W]+>)[^>]*$/;
    }
    ag() {
        super.ag();
        for (let a = 0; a < this.b2.a.count; a++) {
            this.b2.a._inner[a].bo();
        }
        for (let b = 0; b < this.b2.b.count; b++) {
            this.b2.b._inner[b].bo();
        }
        this.b2.clear();
    }
    b5() {
        let a = new PointerTooltip();
        a.bs(this.e.e4);
        a._visibility = 1;
        a.ao = this.e.bs.bn.j;
        this.b4.add(a);
        return a;
    }
    b7(a) {
        let b = a;
    }
    b9(a) {
        let b = a;
        b._visibility = 1;
    }
    b8(a) {
        let b = a;
        b.bv();
        b.content = null;
        this.b4.remove1(a);
    }
    get htmlTest() {
        return this._htmlTest;
    }
    set htmlTest(a) {
        this._htmlTest = a;
    }
    b3(a, b, c, d) {
        let e = b;
        if (a.fz == "default") {
            a.fz = a.bi.getDefaultTooltipTemplate();
        }
        let template_ = a.fz;
        let context_ = d;
        if (a.toolTip == null) {
            return false;
        }
        let tooltip_ = a.toolTip;
        if ((tooltip_.updateToolTip)) {
            tooltip_._inPointer = true;
            tooltip_.updateToolTip(context_, true);
            tooltip_.setStyleProperty('position', 'relative');
            tooltip_.setStyleProperty('left', '');
            tooltip_.setStyleProperty('top', '');
        }
        e.content = a.toolTip;
        return true;
    }
    cc(a, b, c) {
        let d = a;
        let e = d.content;
        let f = new Size(1, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        d.ct = 1;
        let g = d.cs(new Size(1, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY));
        d.ct = 0;
        return g;
    }
    cb(a, b, c, d, e) {
        let f = null;
        if (this.e.bs != null) {
            f = this.e.bs.bn.i.i();
        }
        let g = a;
        g.ap = f;
        let h = g.content;
        g.cn = { $type: Point_$type, x: d, y: e };
        g._visibility = 0;
        g.n = b;
        g.o = c;
    }
    ca(a) {
        if (a != null) {
            let b = a;
            b._visibility = 1;
        }
    }
    a3(a, b) {
        super.a3(a, b);
        if (b) {
            return;
        }
        let c = 0;
        let d = 0;
        let e = this.e.bs;
        if (e != null) {
            let f = e.bn.i.b5();
            c += f.x;
            d += f.y;
        }
        for (let g = 0; g < this.b4.count; g++) {
            this.b4._inner[g].bu(this.b4._inner[g].n + c, this.b4._inner[g].o + d);
        }
    }
    ai(a) {
        super.ai(a);
        for (let tooltip_ of fromEnum(this.b2.a)) {
            if (tooltip_._visibility != 0) {
                continue;
            }
            let b = tooltip_;
            let c = b.a3();
            let d = b.n;
            let e = b.o;
            let f = new List$1(String_$type, 0);
            let g = typeCast(DomWrapper_$type, b.content);
            if (g != null) {
                let h = g.getText();
                f.add(h);
            }
            this.e.a2.addPointerTooltipData(a, c, d, e, f);
        }
    }
}
ItemToolTipLayerView.$t = markType(ItemToolTipLayerView, 'ItemToolTipLayerView', AnnotationLayerView.$);
