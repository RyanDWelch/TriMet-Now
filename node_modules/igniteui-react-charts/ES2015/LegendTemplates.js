/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, Point_$type, markType } from "igniteui-react-core/ES2015/type";
import { DataTemplateRenderInfo } from "igniteui-react-core/ES2015/DataTemplateRenderInfo";
import { Series } from "./Series";
import { DataTemplate } from "igniteui-react-core/ES2015/DataTemplate";
import { LegendItemHelper } from "igniteui-react-core/ES2015/LegendItemHelper";
import { RenderingContext } from "igniteui-react-core/ES2015/RenderingContext";
import { Line } from "igniteui-react-core/ES2015/Line";
import { MarkerSeries } from "./MarkerSeries";
import { CanvasViewRenderer } from "igniteui-react-core/ES2015/CanvasViewRenderer";
import { DataTemplateMeasureInfo } from "igniteui-react-core/ES2015/DataTemplateMeasureInfo";
import { Path } from "igniteui-react-core/ES2015/Path";
import { PathGeometry } from "igniteui-react-core/ES2015/PathGeometry";
import { PathFigure } from "igniteui-react-core/ES2015/PathFigure";
import { LineSegment } from "igniteui-react-core/ES2015/LineSegment";
import { ArcSegment } from "igniteui-react-core/ES2015/ArcSegment";
import { Size } from "igniteui-react-core/ES2015/Size";
import { isNaN_, isInfinity } from "igniteui-react-core/ES2015/number";
/**
 * @hidden
 */
export class LegendTemplates extends Base {
    static d(a) {
        let b = a.data;
        let c = b.series;
        let d = c.legendItemBadgeTemplate;
        if (d == null) {
            d = LegendTemplates.ab(c.bj);
        }
        let e = c.fx;
        if (e == null) {
            e = "Series Title";
        }
        LegendItemHelper.d(a.context, a.xPosition, a.yPosition, a.availableWidth, a.availableHeight, a.data, e.toString(), d, a.passInfo, c.aw != null && c.aw.isFinancial, c.d8, c.et);
    }
    static resolveLegendItemTemplate(a) {
        switch (a) {
            case 0: return LegendTemplates.q;
            case 1: return LegendTemplates.r;
        }
        return LegendTemplates.q;
    }
    static b(a) {
        let b = a.data;
        let c = b.series;
        let d = c.legendItemBadgeTemplate;
        if (d == null) {
            d = LegendTemplates.ab(c.bj);
        }
        let e = b.itemLabel;
        if (e == null) {
            e = "Series Item";
        }
        LegendItemHelper.c(a.context, a.xPosition, a.yPosition, a.availableWidth, a.availableHeight, a.data, e.toString(), d, a.passInfo);
    }
    static h(a) {
        let b = a.data;
        let c = a.context;
        let d = b.series;
        if (b.itemBrush != null) {
            b.actualItemBrush = b.itemBrush;
        }
        else {
            b.actualItemBrush = d.k2;
        }
        let e = new RenderingContext(new CanvasViewRenderer(), c);
        let f = new Line();
        f.aj = 0;
        f.al = a.availableHeight / 2;
        f.ak = a.availableWidth;
        f.am = a.availableHeight / 2;
        f.ac = d.ey;
        f._stroke = b.actualItemBrush;
        f.ai = d.la;
        e.r(f);
        let g = typeCast(MarkerSeries.$, b.series);
        if (g != null && g.mh != null && g.mh.render != null) {
            b.outline = g.mv;
            b.thickness = 2;
            LegendTemplates.n(g.mh, a);
        }
    }
    static n(a, b) {
        let c = new DataTemplateMeasureInfo();
        c.passInfo = b.passInfo;
        c.width = 11;
        c.height = 11;
        c.data = b.data;
        c.context = b.context;
        c.renderContext = b.renderContext;
        let d = b.data;
        let e = d.actualItemBrush;
        let f = d.itemBrush;
        if (typeCast(Series.$, d.series) !== null) {
            if (d.itemBrush == null) {
                let g = d.series;
                d.actualItemBrush = g.k5();
            }
        }
        if (a.measure != null) {
            a.measure(c);
            if (isNaN_(c.width) || isInfinity(c.width) || c.width > 11) {
                c.width = 11;
            }
            if (isNaN_(c.height) || isInfinity(c.height) || c.height > 11) {
                c.height = 11;
            }
        }
        let h = new DataTemplateRenderInfo();
        h.passInfo = b.passInfo;
        h.availableWidth = c.width;
        h.availableHeight = c.height;
        h.xPosition = b.availableWidth / 2;
        h.yPosition = b.availableHeight / 2;
        h.data = b.data;
        h.context = b.context;
        h.renderContext = b.renderContext;
        a.render(h);
        d.itemBrush = f;
        d.actualItemBrush = e;
    }
    static p(a) {
        let b = null;
        if (typeCast(Series.$, a.series) !== null) {
            b = a.series;
        }
        if (a.itemBrush != null) {
            a.actualItemBrush = a.itemBrush;
        }
        else {
            if (b != null) {
                a.actualItemBrush = b.k2;
            }
            else {
                a.actualItemBrush = a.itemBrush;
            }
        }
    }
    static c(a) {
    }
    static a(a) {
    }
    static g(a) {
    }
    static m(a) {
        let b = a.data;
        let c = a.context;
        LegendTemplates.p(b);
        let d = new RenderingContext(new CanvasViewRenderer(), c);
        let e = new Path();
        let f = new PathGeometry();
        let g = new PathFigure();
        g._isFilled = true;
        let h = 0;
        if (typeCast(Series.$, b.series) !== null) {
            h = b.series.ey / 2;
            e.ac = b.series.ey;
            e._stroke = b.series.k3;
            e.ai = b.series.la;
        }
        g._startPoint = { $type: Point_$type, x: h, y: 5 };
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: h, y: 14 }));
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
        g._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: 16, y: 9 };
            return $ret;
        })()));
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: h }));
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: h }));
        g._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: h, y: 5 };
            return $ret;
        })()));
        f.b.add(g);
        e.aj = f;
        e._fill = b.actualItemBrush;
        d.s(e);
        let i = typeCast(MarkerSeries.$, b.series);
        if (i != null && i.mh != null && i.mh.render != null) {
            if (typeCast(Series.$, b.series) !== null) {
                b.outline = b.series.k3;
            }
            LegendTemplates.n(i.mh, a);
        }
    }
    static j(a) {
        let b = a.data;
        let c = a.context;
        LegendTemplates.p(b);
        let d = new Path();
        let e = new PathGeometry();
        let f = new PathFigure();
        let g = 0;
        if (typeCast(Series.$, b.series) !== null) {
            g = b.series.ey / 2;
            d.ac = b.series.ey;
            d._stroke = b.series.k3;
            d.ai = b.series.la;
        }
        f._isFilled = true;
        f._startPoint = { $type: Point_$type, x: g, y: 5 };
        f._segments.add(new LineSegment(0, { $type: Point_$type, x: g, y: 14 }));
        f._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
        f._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: 16, y: 9 };
            return $ret;
        })()));
        f._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: g }));
        f._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: g }));
        f._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: g, y: 5 };
            return $ret;
        })()));
        e.b.add(f);
        d.aj = e;
        d._fill = b.actualItemBrush;
        let h = new RenderingContext(new CanvasViewRenderer(), c);
        h.s(d);
    }
    static i(a) {
        let b = a.data;
        let c = a.context;
        let d = b.series;
        if (b.itemBrush != null) {
            b.actualItemBrush = b.itemBrush;
        }
        else {
            b.actualItemBrush = d.k2;
        }
        let e = new Line();
        e.aj = 0;
        e.al = a.availableHeight / 2;
        e.ak = a.availableWidth;
        e.am = a.availableHeight / 2;
        e.ac = d.ey;
        e.ai = d.la;
        e._stroke = b.actualItemBrush;
        let f = new RenderingContext(new CanvasViewRenderer(), c);
        f.r(e);
    }
    static k(a) {
        let b = a.data;
        LegendTemplates.p(b);
        let c = typeCast(MarkerSeries.$, b.series);
        if (c != null && c.mh != null && c.mh.render != null) {
            if (typeCast(Series.$, b.series) !== null) {
                b.outline = b.series.k6();
            }
            LegendTemplates.n(c.mh, a);
        }
    }
    static l(a) {
        let b = a.data;
        let c = a.context;
        let d = b.series;
        if (b.itemBrush != null) {
            b.actualItemBrush = b.itemBrush;
        }
        else {
            b.actualItemBrush = d.k2;
        }
        let e = new Path();
        let f = new PathGeometry();
        let g = new PathFigure();
        let h = 0;
        if (typeCast(Series.$, b.series) !== null) {
            h = b.series.ey / 2;
            e.ac = b.series.ey;
            e._stroke = b.series.k3;
            e.ai = b.series.la;
        }
        g._isFilled = true;
        g._startPoint = { $type: Point_$type, x: h, y: 5 };
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: h, y: 14 }));
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: h }));
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: h }));
        g._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: h, y: 5 };
            return $ret;
        })()));
        f.b.add(g);
        e.aj = f;
        e._fill = b.actualItemBrush;
        let i = new Path();
        let j = new PathGeometry();
        let k = new PathFigure();
        let l = 0;
        let m = null;
        if (typeCast(Series.$, b.series) !== null) {
            l = b.series.ey / 2;
            i.ac = b.series.ey;
            i._stroke = b.series.k3;
            m = b.series.k8();
        }
        k._isFilled = true;
        k._startPoint = { $type: Point_$type, x: l, y: 14 };
        k._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
        k._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: 16, y: 9 };
            return $ret;
        })()));
        k._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: l }));
        j.b.add(k);
        i.aj = j;
        if (m != null) {
            i._fill = m;
        }
        let n = new RenderingContext(new CanvasViewRenderer(), c);
        n.s(e);
        n.s(i);
        let o = typeCast(MarkerSeries.$, b.series);
        if (o != null && o.mh != null && o.mh.render != null) {
            if (typeCast(Series.$, b.series) !== null) {
                b.outline = b.series.k3;
            }
            LegendTemplates.n(o.mh, a);
        }
    }
    static e(a) {
        let b = a.data;
        let c = a.context;
        let d = b.series;
        if (b.itemBrush != null) {
            b.actualItemBrush = b.itemBrush;
        }
        else {
            b.actualItemBrush = d.k2;
        }
        let e = new Path();
        let f = new PathGeometry();
        let g = 0;
        if (typeCast(Series.$, b.series) !== null) {
            g = b.series.ey / 2;
            e.ac = b.series.ey;
            e._stroke = b.series.k3;
            e.ai = b.series.la;
        }
        let h = new PathFigure();
        h._isFilled = true;
        h._startPoint = { $type: Point_$type, x: g, y: 5 };
        h._segments.add(new LineSegment(0, { $type: Point_$type, x: g, y: 14 }));
        h._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: g }));
        h._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: g }));
        h._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: g, y: 5 };
            return $ret;
        })()));
        f.b.add(h);
        e.aj = f;
        e._fill = b.actualItemBrush;
        let i = new Path();
        let j = new PathGeometry();
        let k = new PathFigure();
        let l = 0;
        let m = null;
        if (typeCast(Series.$, b.series) !== null) {
            i.ac = b.series.ey;
            i._stroke = b.series.k3;
            i.ai = b.series.la;
            m = b.series.k8();
        }
        k._isFilled = true;
        k._startPoint = { $type: Point_$type, x: l, y: 14 };
        k._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
        k._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: 16, y: 9 };
            return $ret;
        })()));
        k._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: l }));
        j.b.add(k);
        i.aj = j;
        if (m != null) {
            i._fill = m;
        }
        let n = new RenderingContext(new CanvasViewRenderer(), c);
        n.s(e);
        n.s(i);
    }
    static f(a) {
        let b = a.data;
        let c = a.context;
        let d = b.series;
        if (b.itemBrush != null) {
            b.actualItemBrush = b.itemBrush;
        }
        else {
            b.actualItemBrush = d.k2;
        }
        let e = new Path();
        let f = new PathGeometry();
        let g = new PathFigure();
        let h = 0;
        if (typeCast(Series.$, b.series) !== null) {
            h = b.series.ey / 2;
            e.ac = b.series.ey;
            e._stroke = b.series.k3;
            e.ai = b.series.la;
        }
        g._isFilled = true;
        g._startPoint = { $type: Point_$type, x: h, y: 5 };
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: h, y: 14 }));
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: h }));
        g._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: h }));
        g._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: h, y: 5 };
            return $ret;
        })()));
        f.b.add(g);
        e.aj = f;
        e._fill = b.actualItemBrush;
        let i = new Path();
        let j = new PathGeometry();
        let k = new PathFigure();
        let l = 0;
        let m = null;
        if (typeCast(Series.$, b.series) !== null) {
            l = b.series.ey / 2;
            i.ac = b.series.ey;
            i._stroke = b.series.k3;
            i.ai = b.series.la;
            m = b.series.k8();
        }
        k._isFilled = true;
        k._startPoint = { $type: Point_$type, x: l, y: 14 };
        k._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
        k._segments.add(((() => {
            let $ret = new ArcSegment();
            $ret.f = new Size(1, 5, 5);
            $ret.b = false;
            $ret.e = { $type: Point_$type, x: 16, y: 9 };
            return $ret;
        })()));
        k._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: l }));
        j.b.add(k);
        i.aj = j;
        if (m != null) {
            i._fill = m;
        }
        let n = new RenderingContext(new CanvasViewRenderer(), c);
        n.s(e);
        n.s(i);
    }
    static o(a) {
        let b = a.data;
        let c = a.context;
        LegendTemplates.p(b);
        let d = typeCast(Series.$, b.series) !== null ? b.series : null;
        if (d != null) {
            b.outline = d.k3;
        }
        let e = new PathGeometry();
        let f = ((() => {
            let $ret = new PathFigure();
            $ret.isClosed = true;
            $ret.isFilled = true;
            return $ret;
        })());
        f._startPoint = { $type: Point_$type, x: 0, y: 0 };
        f._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: 0 }));
        f._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: 16 }));
        f._segments.add(new LineSegment(0, { $type: Point_$type, x: 0, y: 16 }));
        f._segments.add(new LineSegment(0, { $type: Point_$type, x: 0, y: 0 }));
        e.b.add(f);
        let g = ((() => {
            let $ret = new Path();
            $ret.aj = e;
            $ret.fill = b.actualItemBrush;
            return $ret;
        })());
        let h = new RenderingContext(new CanvasViewRenderer(), c);
        h.s(g);
        h.r(((() => {
            let $ret = new Line();
            $ret.aj = 8;
            $ret.ak = 8;
            $ret.al = 0;
            $ret.am = 16;
            $ret.stroke = b.outline;
            $ret.ac = 2;
            return $ret;
        })()));
    }
    static ab(a) {
        switch (a) {
            case 0: return LegendTemplates.u;
            case 1: return LegendTemplates.z;
            case 4: return LegendTemplates.x;
            case 6: return LegendTemplates.s;
            case 7: return LegendTemplates.t;
            case 2: return LegendTemplates.v;
            case 3: return LegendTemplates.w;
            case 5: return LegendTemplates.y;
            case 8: return LegendTemplates.aa;
        }
        return LegendTemplates.z;
    }
}
LegendTemplates.$t = markType(LegendTemplates, 'LegendTemplates');
LegendTemplates.q = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.d;
    return $ret;
})());
LegendTemplates.r = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.a;
    $ret.render = LegendTemplates.b;
    return $ret;
})());
LegendTemplates.u = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.h;
    return $ret;
})());
LegendTemplates.z = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.m;
    return $ret;
})());
LegendTemplates.x = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.k;
    return $ret;
})());
LegendTemplates.s = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.e;
    return $ret;
})());
LegendTemplates.t = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.f;
    return $ret;
})());
LegendTemplates.v = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.j;
    return $ret;
})());
LegendTemplates.w = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.i;
    return $ret;
})());
LegendTemplates.y = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.l;
    return $ret;
})());
LegendTemplates.aa = ((() => {
    let $ret = new DataTemplate();
    $ret.measure = LegendTemplates.c;
    $ret.render = LegendTemplates.o;
    return $ret;
})());
