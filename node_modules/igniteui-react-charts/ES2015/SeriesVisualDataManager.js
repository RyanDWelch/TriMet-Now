/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, fromEnum, typeCast, markType, getInstanceType } from "igniteui-react-core/ES2015/type";
import { ISeriesVisualDataManager_$type } from "./ISeriesVisualDataManager";
import { StackedSeriesVisualData } from "./StackedSeriesVisualData";
import { SeriesVisualData } from "./SeriesVisualData";
import { MarkerVisualData } from "./MarkerVisualData";
import { RectData } from "igniteui-react-core/ES2015/RectData";
import { PrimitiveAppearanceData } from "igniteui-react-core/ES2015/PrimitiveAppearanceData";
import { DataContext } from "igniteui-react-core/ES2015/DataContext";
import { Color } from "igniteui-react-core/ES2015/Color";
import { ColorData } from "igniteui-react-core/ES2015/ColorData";
import { AppearanceHelper } from "igniteui-react-core/ES2015/AppearanceHelper";
import { PathVisualData } from "igniteui-react-core/ES2015/PathVisualData";
import { PolygonVisualData } from "igniteui-react-core/ES2015/PolygonVisualData";
import { PolyLineVisualData } from "igniteui-react-core/ES2015/PolyLineVisualData";
import { RectangleVisualData } from "igniteui-react-core/ES2015/RectangleVisualData";
import { PointerTooltipVisualData } from "./PointerTooltipVisualData";
import { CalloutVisualData } from "./CalloutVisualData";
import { LineVisualData } from "igniteui-react-core/ES2015/LineVisualData";
/**
 * @hidden
 */
export class SeriesVisualDataManager extends Base {
    addSubSeriesVisualData(a, b) {
        let c = a;
        let d = b;
        c.fragmentSeries.add(d);
    }
    copyVisualData(a, b) {
        let c = a;
        let d = b;
        for (let e of fromEnum(d.shapes)) {
            c.shapes.add(e);
        }
        for (let f of fromEnum(d.markerShapes)) {
            c.markerShapes.add(f);
        }
        c.pixels = d.pixels;
        c.pixelWidth = d.pixelWidth;
    }
    createFragmentVisualData(a, b, c, d) {
        let e = new SeriesVisualData();
        e.viewport = RectData.b(b);
        e.type = c;
        e.name = d;
        return e;
    }
    exportMarkerVisualData(a, b) {
        let c = b;
        a.lz.cc((d) => {
            let e = this.getMarkerVisualData(a, d, a.mi);
            c.markerShapes.add(typeCast(MarkerVisualData.$, e));
        });
    }
    getMarkerVisualData(a, b, c) {
        let d = new MarkerVisualData();
        let e = new PrimitiveAppearanceData();
        d.x = b.n;
        d.y = b.o;
        d.bounds = new RectData(b.n - (b.m / 2), b.o - (b.l / 2), b.m, b.l);
        e.fill = ColorData.a_1(Color.u(0, 0, 0, 0));
        e.stroke = ColorData.a_1(Color.u(0, 0, 0, 0));
        d.index = -1;
        d.contentTemplate = b.ah;
        if (b.content != null && typeCast(DataContext.$, b.content) !== null && b._visibility == 0) {
            let f = b.content;
            e.fill = AppearanceHelper.b(f.actualItemBrush);
            e.fillExtended = AppearanceHelper.a(f.actualItemBrush);
            e.stroke = AppearanceHelper.b(f.outline);
            e.strokeExtended = AppearanceHelper.a(f.outline);
            e.strokeThickness = a.ey;
            if (f.item != null) {
                d.index = a.bz.indexOf(f.item);
            }
        }
        e.isVisible = b._visibility == 0;
        d.isVisible = b._visibility == 0;
        d.markerAppearance = e;
        d.markerType = this.a(a, c);
        return d;
    }
    a(a, b) {
        if (b == a.bs.kn) {
            return "Circle";
        }
        else if (b == a.bs.ko) {
            return "Diamond";
        }
        else if (b == a.bs.kp) {
            return "Hexagon";
        }
        else if (b == a.bs.kq) {
            return "Hexagram";
        }
        else if (b == a.bs.kr) {
            return "Pentagon";
        }
        else if (b == a.bs.ks) {
            return "Pentagram";
        }
        else if (b == a.bs.kt) {
            return "Pyramid";
        }
        else if (b == a.bs.ku) {
            return "Square";
        }
        else if (b == a.bs.kv) {
            return "Tetragram";
        }
        else if (b == a.bs.kw) {
            return "Triangle";
        }
        else {
            return "None";
        }
    }
    exportMarkerVisualDataFromMarker(a, b, c) {
        let d = b;
        let e = new MarkerVisualData();
        let f = new PrimitiveAppearanceData();
        e.x = c.n;
        e.y = c.o;
        e.bounds = new RectData(c.n - (c.m / 2), c.o - (c.l / 2), c.m, c.l);
        e.index = -1;
        e.contentTemplate = c.ah;
        if (typeCast(DataContext.$, c.content) !== null) {
            let g = c.content;
            f.fill = AppearanceHelper.b(g.actualItemBrush);
            f.stroke = AppearanceHelper.b(g.outline);
        }
        e.isVisible = c._visibility == 0;
        e.markerAppearance = f;
        if (c.ah == a.bs.kn) {
            e.markerType = "Circle";
        }
        else if (c.ah == a.bs.ko) {
            e.markerType = "Diamond";
        }
        else if (c.ah == a.bs.kp) {
            e.markerType = "Hexagon";
        }
        else if (c.ah == a.bs.kq) {
            e.markerType = "Hexagram";
        }
        else if (c.ah == a.bs.kr) {
            e.markerType = "Pentagon";
        }
        else if (c.ah == a.bs.ks) {
            e.markerType = "Pentagram";
        }
        else if (c.ah == a.bs.kt) {
            e.markerType = "Pyramid";
        }
        else if (c.ah == a.bs.ku) {
            e.markerType = "Square";
        }
        else if (c.ah == a.bs.kv) {
            e.markerType = "Tetragram";
        }
        else if (c.ah == a.bs.kw) {
            e.markerType = "Triangle";
        }
        else {
            e.markerType = "None";
        }
        d.markerShapes.add(e);
    }
    exportPathData(a, b, c, d) {
        let e = a;
        let f = new PathVisualData(1, c, b);
        if (d != null) {
            for (let g = 0; g < d.length; g++) {
                f.tags.add(d[g]);
            }
        }
        e.shapes.add(f);
    }
    exportPolygonData(a, b, c, d) {
        let e = a;
        let f = new PolygonVisualData(1, c, b);
        if (d != null) {
            for (let g = 0; g < d.length; g++) {
                f.tags.add(d[g]);
            }
        }
        e.shapes.add(f);
    }
    exportPolylineData(a, b, c, d) {
        let e = a;
        let f = new PolyLineVisualData(1, c, b);
        if (d != null) {
            for (let g = 0; g < d.length; g++) {
                f.tags.add(d[g]);
            }
        }
        e.shapes.add(f);
    }
    exportRectangleData(a, b, c, d) {
        let e = a;
        let f = new RectangleVisualData(1, c, b);
        if (d != null) {
            for (let g = 0; g < d.length; g++) {
                f.tags.add(d[g]);
            }
        }
        e.shapes.add(f);
    }
    exportStackedVisualData(a, b) {
        let c = new StackedSeriesVisualData();
        c.viewport = RectData.b(b);
        c.type = getInstanceType(a).typeName;
        c.name = a.name;
        return c;
    }
    exportTrendlineData(a, b, c) {
        let d = b;
        let e = new PolyLineVisualData(1, "trendLine", c);
        e.tags.add("Trend");
        d.shapes.add(e);
    }
    exportVisualData(a, b) {
        let c = new SeriesVisualData();
        c.viewport = RectData.b(b);
        c.type = this.b(getInstanceType(a).typeName);
        c.name = a.name;
        c.opacity = a._opacity;
        return c;
    }
    exportSeriesPixelsData(a, b, c, d) {
        let e = a;
        e.pixels = b;
        e.pixelWidth = c;
        e.pixelHeight = d;
    }
    b(a) {
        return a;
    }
    addPointerTooltipData(a, b, c, d, e) {
        if (b == null) {
            return;
        }
        let f = a;
        let g = b;
        g.offsetX = c;
        g.offsetY = d;
        g.categoryNames = e;
        f.pointerTooltips.add(g);
    }
    exportPointerTooltipData(a, b, c, d) {
        let e = new PointerTooltipVisualData();
        e.pointerFillShape = new PolygonVisualData(1, "fillShape", a);
        e.pointerOutlineShape = new PolyLineVisualData(1, "outlineShape", b);
        e.boxShape = new RectangleVisualData(1, "boxShape", c);
        e.viewport = RectData.b(d);
        return e;
    }
    exportCalloutData(a, b, c, d, e, f, g, h, i, j, k) {
        let l = new CalloutVisualData();
        l.left = a;
        l.top = b;
        l.marginLeft = c;
        l.marginTop = d;
        l.background = new RectangleVisualData(1, "calloutBackground", f);
        l.text = AppearanceHelper.c(g, h);
        l.line = new LineVisualData(1, "calloutLeaderLine", i);
        e.calloutShapes.add(l);
    }
}
SeriesVisualDataManager.$t = markType(SeriesVisualDataManager, 'SeriesVisualDataManager', Base.$, [ISeriesVisualDataManager_$type]);
