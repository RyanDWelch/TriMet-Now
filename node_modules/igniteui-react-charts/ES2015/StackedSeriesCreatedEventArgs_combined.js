/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { EventArgs, Base, Type, markType, Point_$type, typeCast, Number_$type, runOn, delegateCombine, fromEnum, Boolean_$type, enumGetBox, fromEn, String_$type, getInstanceType, INotifyPropertyChanged_$type, PropertyChangedEventArgs, Array_$type, Nullable$1, TypeRegistrar } from "igniteui-react-core/ES2015/type";
import { Brush } from "igniteui-react-core/ES2015/Brush";
import { DataTemplate } from "igniteui-react-core/ES2015/DataTemplate";
import { Visibility_$type } from "igniteui-react-core/ES2015/Visibility";
import { DoubleCollection } from "igniteui-react-core/ES2015/DoubleCollection";
import { PenLineCap_$type } from "igniteui-react-core/ES2015/PenLineCap";
import { Style } from "igniteui-react-core/ES2015/Style";
import { MarkerType_$type } from "./MarkerType";
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { CategoryLineRasterizer } from "./CategoryLineRasterizer";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { AnchoredCategorySeries } from "./AnchoredCategorySeries";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { CategorySeries } from "./CategorySeries";
import { NumericAxisBase } from "./NumericAxisBase";
import { ISupportsMarkers_$type } from "./ISupportsMarkers";
import { CategoryFrame } from "./CategoryFrame";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { CategorySeriesView } from "./CategorySeriesView";
import { ObservableCollection$1 } from "igniteui-react-core/ES2015/ObservableCollection$1";
import { Axis } from "./Axis";
import { ScalerParams } from "./ScalerParams";
import { AxisRange } from "./AxisRange";
import { AnchoredCategorySeriesView } from "./AnchoredCategorySeriesView";
import { CategoryBucketCalculator } from "./CategoryBucketCalculator";
import { isNaN_, isInfinity, truncate } from "igniteui-react-core/ES2015/number";
import { Path } from "igniteui-react-core/ES2015/Path";
import { ISortingAxis_$type } from "./ISortingAxis";
import { FrameworkElement } from "igniteui-react-core/ES2015/FrameworkElement";
import { XamDataChart } from "./XamDataChart";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { DependencyObject } from "igniteui-react-core/ES2015/DependencyObject";
import { NumericYAxis } from "./NumericYAxis";
import { Pool$1 } from "igniteui-react-core/ES2015/Pool$1";
import { Rectangle } from "igniteui-react-core/ES2015/Rectangle";
import { DataContext } from "igniteui-react-core/ES2015/DataContext";
import { Dictionary$2 } from "igniteui-react-core/ES2015/Dictionary$2";
import { IScaler_$type } from "./IScaler";
import { IIsCategoryBased_$type } from "./IIsCategoryBased";
import { CategoryMarkerManager } from "./CategoryMarkerManager";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { dateMinValue, dateMaxValue } from "igniteui-react-core/ES2015/date";
import { NumericXAxis } from "./NumericXAxis";
import { CategoryYAxis } from "./CategoryYAxis";
import { AnchoredCategoryBucketCalculator } from "./AnchoredCategoryBucketCalculator";
import { IStacked100Series_$type } from "./IStacked100Series";
import { SplineSeriesBase } from "./SplineSeriesBase";
import { CollisionAvoider } from "./CollisionAvoider";
import { SafeSortedReadOnlyDoubleCollection } from "./SafeSortedReadOnlyDoubleCollection";
import { Numeric } from "igniteui-react-core/ES2015/Numeric";
import { ICategoryScaler_$type } from "./ICategoryScaler";
import { CategoryFramePreparer } from "./CategoryFramePreparer";
import { CategoryXAxis } from "./CategoryXAxis";
import { IBarSeries_$type } from "./IBarSeries";
import { Color } from "igniteui-react-core/ES2015/Color";
import { PropertyUpdatedEventArgs } from "igniteui-react-core/ES2015/PropertyUpdatedEventArgs";
import { SingleValuesHolder } from "./SingleValuesHolder";
import { stringIsNullOrEmpty } from "igniteui-react-core/ES2015/string";
import { SplineSeriesBaseView } from "./SplineSeriesBaseView";
import { Canvas } from "igniteui-react-core/ES2015/Canvas";
import { Panel } from "igniteui-react-core/ES2015/Panel";
import { PlatformConstants } from "igniteui-react-core/ES2015/PlatformConstants";
/**
 * @hidden
 */
export class StackedSeriesCreatedEventArgs extends EventArgs {
    constructor(a) {
        super();
        this.c = null;
        this.c = a;
    }
    get brush() {
        return this.c.fu;
    }
    set brush(a) {
        this.c.fu = a;
    }
    get legendItemTemplate() {
        return this.c.dv;
    }
    set legendItemTemplate(a) {
        this.c.dv = a;
    }
    get legendItemBadgeTemplate() {
        return this.c.du;
    }
    set legendItemBadgeTemplate(a) {
        this.c.du = a;
    }
    get legendItemVisibility() {
        return this.c.ge;
    }
    set legendItemVisibility(a) {
        this.c.ge = a;
    }
    get outline() {
        return this.c.fy;
    }
    set outline(a) {
        this.c.fy = a;
    }
    get dashArray() {
        return this.c.f3;
    }
    set dashArray(a) {
        this.c.f3 = a;
    }
    get dashCap() {
        return this.c.f7;
    }
    set dashCap(a) {
        this.c.f7 = a;
    }
    get index() {
        return this.c.av;
    }
    get thickness() {
        return this.c.at;
    }
    set thickness(a) {
        this.c.at = a;
    }
    get title() {
        return this.c.ax;
    }
    set title(a) {
        this.c.ax = a;
    }
    get markerBrush() {
        return this.c.fv;
    }
    set markerBrush(a) {
        this.c.fv = a;
    }
    get markerOutline() {
        return this.c.fw;
    }
    set markerOutline(a) {
        this.c.fw = a;
    }
    get markerStyle() {
        return this.c.gb;
    }
    set markerStyle(a) {
        this.c.gb = a;
    }
    get markerTemplate() {
        return this.c.dw;
    }
    set markerTemplate(a) {
        this.c.dw = a;
    }
    get markerType() {
        return this.c.l;
    }
    set markerType(a) {
        this.c.l = a;
    }
    get startCap() {
        return this.c.f6;
    }
    set startCap(a) {
        this.c.f9 = a;
    }
    get endCap() {
        return this.c.f5;
    }
    set endCap(a) {
        this.c.f8 = a;
    }
}
StackedSeriesCreatedEventArgs.$t = markType(StackedSeriesCreatedEventArgs, 'StackedSeriesCreatedEventArgs', EventArgs.$);
/**
 * @hidden
 */
export class FragmentBase extends HorizontalAnchoredCategorySeries {
    constructor() {
        super();
        this.qg = null;
        this._logicalSeriesLink = null;
        this.qi = null;
        this.qg = new CategoryLineRasterizer();
    }
    get logicalSeriesLink() {
        return this._logicalSeriesLink;
    }
    set logicalSeriesLink(a) {
        this._logicalSeriesLink = a;
    }
    get parentSeries() {
        return this.qi;
    }
    set parentSeries(a) {
        this.qi = a;
    }
    get_cv() {
        return false;
    }
    get_cq() {
        return false;
    }
    get_cs() {
        return true;
    }
    e7() {
        let a = this.parentSeries;
        if (a.fh == -1 || a.o2 == null || a.o2.f.indexOf(this) == -1) {
            return -1;
        }
        return a.o2.f.indexOf(this);
    }
    fb() {
        let a = this.parentSeries;
        if (a.fh == -1 || a.series.count == 0 || a.series.indexOf(this.logicalSeriesLink) == -1) {
            return -1;
        }
        return a.series.indexOf(this.logicalSeriesLink);
    }
    resolveLegendIndex() {
        let a = this.parentSeries;
        if (a.o5) {
            return -1 + a.fh + a.oy.count - a.o2.f.indexOf(this);
        }
        return super.resolveLegendIndex();
    }
    a6() {
        return this.parentSeries;
    }
    m5() {
        if (this.parentSeries == null) {
            return null;
        }
        return this.parentSeries.fetchXAxis();
    }
    np() {
        if (this.parentSeries == null) {
            return null;
        }
        return this.parentSeries.fetchYAxis();
    }
    qk(a, b, c, d, e, f, g, h) {
        let i = c[0];
        let j = c[1];
        let k = new Rect(0, i - 5, j - 5, 11, 11);
        if (!isNaN_(i) && !isNaN_(j) && !isInfinity(i) && !isInfinity(j) && d.tryAdd(k)) {
            b.m.add({ $type: Point_$type, x: i, y: j });
            a.updateMarkerTemplate(g, f, h);
            return true;
        }
        return false;
    }
    ok(a, b) {
        a.u();
        if (this.valueColumn == null || this.parentSeries == null || this.logicalSeriesLink == null) {
            return;
        }
        if (this.logicalSeriesLink.ad.count == 0 || this.logicalSeriesLink.ac.count == 0) {
            return;
        }
        this.nb(b).d(a, b);
    }
    qm(a, b, c) {
        let d = this.o6(c);
        let e = d;
        let f = this.logicalSeriesLink.y;
        let g = f ? this.parentSeries.o2.e : this.parentSeries.o2.d;
        let h = g.indexOf(this);
        if (a.count == 0) {
            return;
        }
        if (h == -1) {
            return;
        }
        let i = false;
        for (let j = h; j >= 0; j--) {
            if (i) {
                break;
            }
            if (j == 0) {
                a.add({ $type: Point_$type, x: a._inner[a.count - 1].x, y: e });
                a.add({ $type: Point_$type, x: a._inner[0].x, y: e });
                break;
            }
            let k = typeCast(FragmentBase.$, g._inner[j - 1]);
            if (k != null && k.qg != null && k.qg.o.count > 0 && this.bi != null && k.dw(this.bi.br, this.bi.bs, this.bi)) {
                i = true;
                for (let l = k.qg.o.count - 1; l >= 0; l--) {
                    a.add(k.qg.o._inner[l]);
                }
            }
        }
    }
    dw(a, b, c) {
        let d = super.dw(a, b, c);
        let e = typeCast(CategoryAxisBase.$, this.parentSeries.fetchXAxis());
        let f = this.parentSeries.fetchYAxis();
        if (this.parentSeries == null || e == null || e.itemsSource == null || f == null || this.parentSeries.bz == null || e.bf == null || f.bf == null) {
            d = false;
        }
        if (this.valueColumn == null) {
            return false;
        }
        if (isInfinity(this.valueColumn.minimum) && isInfinity(this.valueColumn.maximum)) {
            d = false;
        }
        if (isNaN_(this.valueColumn.minimum) && isNaN_(this.valueColumn.maximum)) {
            d = false;
        }
        return d;
    }
    o6(a) {
        let b = 0;
        let c = a.bs;
        let d = a.br;
        let e = this.getEffectiveViewport1(a);
        let f = new ScalerParams(0, c, d, this.yAxis.b8, e);
        f.b = this.eh();
        if (!c.isEmpty && !d.isEmpty && this.yAxis != null) {
            b = this.yAxis.dv(0, f);
        }
        return b;
    }
    an(a) {
        return null;
    }
    ql() {
        if (this.parentSeries == null) {
            return -1;
        }
        let a = this.parentSeries.fh;
        let b = 0;
        let c = 1;
        if (this.parentSeries.o5) {
            b = this.parentSeries.oy.count - 1;
            c = -1;
        }
        for (let d = b; this.parentSeries.o5 ? d >= 0 : d < this.parentSeries.oy.count; d += c) {
            let e = this.parentSeries.oy._inner[d];
            if (e.visualSeriesLink == this) {
                return a;
            }
            if (this.parentSeries.aw == null || e.gd != 0 || e.gc != 0) {
                continue;
            }
            a++;
        }
        return -1;
    }
    qn(a) {
        if (a == null) {
        }
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        if (this.parentSeries == null) {
            return;
        }
        let e = typeCast(NumericAxisBase.$, this.parentSeries.fetchYAxis());
        if (e == null) {
            return;
        }
        switch (b) {
            case "ValueColumn":
                if (this.ox.cz) {
                    this.ox.cy.g$i();
                }
                if (e != null && !e.ck()) {
                    this.parentSeries.ox().cn.g(this.eu);
                    this.jc(false);
                }
                break;
            case "ActualBrush":
                if (this.logicalSeriesLink != null) {
                    this.logicalSeriesLink.fp = this.k2;
                }
                break;
        }
    }
    je(a, b) {
        super.je(a, b);
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
FragmentBase.$t = markType(FragmentBase, 'FragmentBase', HorizontalAnchoredCategorySeries.$);
/**
 * @hidden
 */
export class AreaFragment extends FragmentBase {
    constructor() {
        super();
        this.ab = AreaFragment.$;
    }
    bf() {
        return new AreaFragmentView(this);
    }
    it(a) {
        super.it(a);
        this.qo = a;
    }
    get_ck() {
        return true;
    }
    qq(a, b) {
        let c = this.qo.c8.aj;
        if (this.dj(a, c)) {
            return true;
        }
        let d = this.qo.c9.aj;
        if (this.dj(a, d)) {
            return true;
        }
        return false;
    }
    dh(a, b) {
        if (this.qp(a, b)) {
            return true;
        }
        if (this.qq(a, b)) {
            return true;
        }
        if (this.l3(a, b)) {
            return true;
        }
        return false;
    }
    qp(a, b) {
        let c = this.qo.da.aj;
        if (this.di(a, b, c)) {
            return true;
        }
        let d = this.qo.db.aj;
        if (this.di(a, b, d)) {
            return true;
        }
        return false;
    }
    preferredCategoryMode(a) {
        return 0;
    }
    hv(a, b) {
        super.hv(a, b);
        let c = b;
        c.c7();
    }
    on(a, b) {
        super.on(a, b);
        this.qg.a = typeCast(ISortingAxis_$type, this.xAxis) !== null ? true : false;
        let c = typeCast(AreaFragmentView.$, b);
        let d = c.cn.d;
        this.qg.i(c.c8, c.da, c.c9, c.db, a.f.count, a.f, true, d, this.eu, (e, f, g, h, i) => this.qm(e, a.f, b), 0);
        c.c8._opacity = this.d6;
        c.c9._opacity = 0.5 * this.d6;
    }
    jm() {
        let a = (typeCast(XamDataChart.$, this.bs));
        if (a != null) {
            this.d6 = isNaN_(this.d7) ? this.parentSeries.d6 : this.d7;
        }
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
AreaFragment.$t = markType(AreaFragment, 'AreaFragment', FragmentBase.$);
/**
 * @hidden
 */
export class ColumnFragment extends FragmentBase {
    constructor() {
        super();
        this.ab = ColumnFragment.$;
    }
    bf() {
        return new ColumnFragmentView(this);
    }
    it(a) {
        super.it(a);
        this.qp = a;
    }
    get fragmentXAxis() {
        return this.parentSeries != null ? typeCast(CategoryAxisBase.$, this.parentSeries.fetchXAxis()) : null;
    }
    get fragmentYAxis() {
        return this.parentSeries != null ? typeCast(NumericYAxis.$, this.parentSeries.fetchYAxis()) : null;
    }
    preferredCategoryMode(a) {
        return 2;
    }
    m5() {
        return this.fragmentXAxis;
    }
    np() {
        return this.fragmentYAxis;
    }
    fetchXAxis() {
        return null;
    }
    fetchYAxis() {
        return null;
    }
    hv(a, b) {
        super.hv(a, b);
        let c = b;
        if (a && c.c7 != null) {
            this.m6.m.clear();
            c.c7.count = 0;
        }
    }
    an(a) {
        if (this.valueColumn == null || this.valueColumn.count == 0) {
            return null;
        }
        return new AxisRange(this.valueColumn.minimum, this.valueColumn.maximum);
    }
    dw(a, b, c) {
        if (this.parentSeries == null) {
            return false;
        }
        return this.parentSeries.o6(this, a, b, this.qr(c));
    }
    dt() {
        return true;
    }
    n6(a) {
        if (this.parentSeries != null) {
            return this.parentSeries.n6(this.parentSeries.bi);
        }
        return super.n6(a);
    }
    n7(a) {
        if (this.parentSeries != null) {
            return this.parentSeries.n7(this.parentSeries.bi);
        }
        return super.n6(a);
    }
    lt(a) {
        if (this.m5() == null || this.fragmentYAxis == null) {
            return Rect.empty;
        }
        let b = this.lf(a);
        let c = this.bi.bs;
        let d = this.bi.br;
        let e = this.getEffectiveViewport1(this.bi);
        let f = new ScalerParams(0, c, d, this.fragmentYAxis.b8, e);
        let g = this.aj(this.m5(), this.m6.f, this.n6(this.bi), this.n7(this.bi), a, true);
        if (g == null) {
            return Rect.empty;
        }
        let h = g[0];
        let i = g[1];
        let j = Math.abs(b.x - h[0]);
        let k = Math.abs(b.x - i[0]);
        let l = this.m5().jq(c, d, e);
        if (j < k) {
            let m = h[0] - 0.5 * l;
            let n = h[1];
            let o = h[2];
            return new Rect(0, m, Math.min(n, o), l, Math.max(n, o) - Math.min(n, o));
        }
        else {
            let p = i[0] - 0.5 * l;
            let q = i[1];
            let r = i[2];
            return new Rect(0, p, Math.min(q, r), l, Math.max(q, r) - Math.min(q, r));
        }
    }
    dh(a, b) {
        if (this.dk(a, b)) {
            return true;
        }
        if (this.l3(a, b)) {
            return true;
        }
        return false;
    }
    dk(a, b) {
        let c = this.lu(a);
        if (c.isEmpty) {
            return false;
        }
        let d = this.qy(c, this.ee(b));
        return d.containsPoint(a);
    }
    qy(a, b) {
        let c = a.left + a.width / 2;
        let d = a.top + a.height / 2;
        let e = c - ((a.width / 2) + b);
        let f = d - (a.height / 2);
        let g = a.height;
        let h = a.width + b * 2;
        return new Rect(0, e, f, h, g);
    }
    fv(a, b) {
        let c = typeCast(FrameworkElement.$, a);
        let d = c != null ? typeCast(DataContext.$, c.dataContext) : null;
        let e = d != null ? d.item : null;
        if (e == null) {
            let f = this.bi.br;
            let g = this.bs != null ? this.bs.mq : Rect.empty;
            let h = { $type: Point_$type, x: g.left + g.width * (b.x - f.left) / f.width, y: g.top + g.height * (b.y - f.top) / f.height };
            e = this.fp(h);
        }
        return e;
    }
    fp(a) {
        let b = 0;
        if (typeCast(ISortingAxis_$type, this.m5()) !== null) {
            b = this.fa(a);
            if (b == -1) {
                return null;
            }
        }
        else {
            b = this.e8(a);
        }
        return b >= 0 && this.bz != null && b < this.bz.count ? this.bz.item(b) : null;
    }
    fa(a) {
        let b = this.bi.bs;
        let c = this.bi.br;
        let d = this.getEffectiveViewport1(this.bi);
        if (b.isEmpty || c.isEmpty) {
            return -1;
        }
        let e = this.m5();
        let f = new ScalerParams(0, b, c, e.b8, d);
        let g = typeCast(ISortingAxis_$type, this.fragmentXAxis);
        let h = this.lp(this.bi);
        let i = e.dy(h.left, f);
        let j = e.dy(h.right, f);
        let k = (a.x - b.left) / b.width;
        let l = i + ((j - i) * k);
        if (truncate(l) <= dateMinValue().getTime() || truncate(l) >= dateMaxValue().getTime()) {
            return -1;
        }
        let m = g.i$f(l);
        return m;
    }
    e8(a) {
        if (this.parentSeries == null) {
            return -1;
        }
        return this.parentSeries.pc(a);
    }
    qk(a, b, c, d, e, f, g, h) {
        let i = 0;
        let j = c[0];
        let k = e < i ? c[2] : c[1];
        let l = new Rect(0, j - 5, k - 5, 11, 11);
        if (!isNaN_(j) && !isNaN_(k) && !isInfinity(j) && !isInfinity(k) && d.tryAdd(l)) {
            b.m.add({ $type: Point_$type, x: j, y: k });
            a.updateMarkerTemplate(g, f, h);
            return true;
        }
        return false;
    }
    qr(a) {
        if (a.m) {
            return this.parentSeries.a0.a$h.item(a.aa);
        }
        else if (a == this.bh) {
            return this.parentSeries.bh;
        }
        else {
            return this.parentSeries.ne;
        }
    }
    jb(a, b, c, d, e) {
        this.a0.a$r(this, a, b, d, e);
        let f = this.a0.a$h.item(d);
        let g = f;
        f.ay(c);
        let h = this.qr(f);
        h.cn.g(this.eu);
        if (this.cc(g)) {
            return;
        }
        if (this.oy == null) {
            this.oy = new CategoryFrame(3);
        }
        this.oy.u();
        this.ok(this.oy, g);
        this.on(this.oy, g);
    }
    ok(a, b) {
        a.u();
        if (this.valueColumn == null || this.parentSeries == null || this.logicalSeriesLink == null || this.logicalSeriesLink.ac.count == 0 || this.logicalSeriesLink.ad.count == 0) {
            return;
        }
        let c;
        if (b.m) {
            c = this.parentSeries.ow;
        }
        else if (b == this.bh) {
            c = this.parentSeries.m8;
        }
        else {
            c = this.parentSeries.m6;
        }
        let d = typeCast(CategorySeriesView.$, this.qr(b));
        a.f.clear();
        a.m.clear();
        let e = d.cn.e;
        let f = d.cn.f;
        let g = this.parentSeries.na.h.yScaler;
        let h = typeCast(ISortingAxis_$type, this.parentSeries.na.h.scaler);
        let i = typeCast(NumericAxisBase.$, g) !== null && g.jt;
        let j = typeCast(StackedBucketCalculator.$, d.cn);
        let k = d.cn.d;
        let l = 0;
        for (let m = e; m <= f; m++) {
            let n = m * k;
            if (this._visibility != 0) {
                break;
            }
            if (m >= this.valueColumn.count || m >= c.f.count + e) {
                continue;
            }
            let o = this.valueColumn.item(m);
            let p = !i || (i && o > 0);
            let q;
            if (h == null) {
                q = j.getBucket1(this, m, m, b.bs, b.br, c);
            }
            else {
                q = j.getBucket1(this, m, h.i$b._inner[m], b.bs, b.br, c);
            }
            a.f.add(q);
            if (p) {
                if (this.qk(b, a, q, this.na.h.provideCollisionDetector(), o, n, l, m)) {
                    l++;
                }
            }
        }
        b.cq.count = l;
    }
    on(a, b) {
        super.on(a, b);
        if (this.parentSeries == null) {
            return;
        }
        this.parentSeries.pl(this, a, b);
        CategoryMarkerManager.b(this, a.m, b.cq, this.l4);
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
ColumnFragment.$t = markType(ColumnFragment, 'ColumnFragment', FragmentBase.$);
Type.dep(DependencyProperty, PropertyMetadata, ColumnFragment, 'raisePropertyChanged', ['RadiusX:qs:qw', [1, 2], 'RadiusY:qt:qx', [1, 2]]);
/**
 * @hidden
 */
export class BarFragment extends ColumnFragment {
    constructor() {
        super();
        this.ab = BarFragment.$;
    }
    get barFragmentXAxis() {
        return this.parentSeries != null ? this.parentSeries.xAxis : null;
    }
    get barFragmentYAxis() {
        return this.parentSeries != null ? this.parentSeries.yAxis : null;
    }
    m5() {
        if (this.parentSeries == null) {
            return null;
        }
        return this.parentSeries.fetchYAxis();
    }
    eb(a) {
        let b = this.bs != null ? this.bs.mq : Rect.empty;
        let c = this.bi.br;
        let d = this.lp(this.bi);
        let e = this.getEffectiveViewport1(this.bi);
        let f = this.m5();
        let g = -1;
        if (f != null && !b.isEmpty && !c.isEmpty) {
            let h = new ScalerParams(0, b, c, f.b8, e);
            let i = f.dy(d.top, h);
            let j = f.dy(d.bottom, h);
            let k = (a.y - b.top) / b.height;
            let l = i + (k * (j - i));
            if (f.categoryMode != 0) {
                l -= 0.5;
            }
            g = l;
        }
        return g;
    }
    np() {
        if (this.parentSeries == null) {
            return null;
        }
        return this.parentSeries.fetchYAxis();
    }
    qy(a, b) {
        let c = a.left + a.width / 2;
        let d = a.top + a.height / 2;
        let e = c - (a.width / 2);
        let f = d - ((a.height / 2) + b);
        let g = a.height + b * 2;
        let h = a.width;
        return new Rect(0, e, f, h, g);
    }
    lt(a) {
        if (this.m5() == null) {
            return Rect.empty;
        }
        let b = this.lf(a);
        let c = this.bi.bs;
        let d = this.bi.br;
        let e = this.getEffectiveViewport1(this.bi);
        let f = this.m5();
        let g = new ScalerParams(0, c, d, f.b8, e);
        let h = this.aj(this.m5(), this.m6.f, this.n6(this.bi), this.n7(this.bi), a, true);
        if (h == null) {
            return Rect.empty;
        }
        let i = h[0];
        let j = h[1];
        let k = Math.abs(b.y - i[0]);
        let l = Math.abs(b.y - j[0]);
        let m = f.jq(c, d, e);
        if (k < l) {
            let n = i[0] - 0.5 * m;
            let o = i[2];
            let p = i[1];
            return new Rect(0, o, n, Math.max(p, o) - Math.min(p, o), m);
        }
        else {
            let q = j[0] - 0.5 * m;
            let r = j[2];
            let s = j[1];
            return new Rect(0, r, q, Math.max(s, r) - Math.min(s, r), m);
        }
    }
    dh(a, b) {
        if (this.dk(a, b)) {
            return true;
        }
        if (this.l3(a, b)) {
            return true;
        }
        return false;
    }
    qk(a, b, c, d, e, f, g, h) {
        let i = c[0];
        let j = e < 0 ? c[2] : c[1];
        let k = new Rect(0, j - 5, i - 5, 11, 11);
        if (!isNaN_(j) && !isNaN_(i) && !isInfinity(j) && !isInfinity(i) && d.tryAdd(k)) {
            b.m.add({ $type: Point_$type, x: j, y: i });
            a.updateMarkerTemplate(g, f, h);
            return true;
        }
        return false;
    }
    fp(a) {
        let b = 0;
        if (typeCast(ISortingAxis_$type, this.barFragmentYAxis) !== null) {
            b = this.fa(a);
            if (b == -1) {
                return null;
            }
        }
        else {
            b = this.e8(a);
        }
        return b >= 0 && this.bz != null && b < this.bz.count ? this.bz.item(b) : null;
    }
    fa(a) {
        let b = this.bi.bs;
        let c = this.bi.br;
        if (b.isEmpty || c.isEmpty) {
            return -1;
        }
        let d = this.getEffectiveViewport1(this.bi);
        let e = new ScalerParams(0, b, c, this.barFragmentYAxis.b8, d);
        let f = typeCast(ISortingAxis_$type, this.barFragmentYAxis);
        let g = this.lp(this.bi);
        let h = this.barFragmentYAxis.dy(g.top, e);
        let i = this.barFragmentYAxis.dy(g.bottom, e);
        let j = (a.y - b.top) / b.height;
        let k = h + ((i - h) * j);
        if (truncate(k) <= dateMinValue().getTime() || truncate(k) >= dateMaxValue().getTime()) {
            return -1;
        }
        let l = f.i$f(k);
        return l;
    }
    o6(a) {
        let b = 0;
        let c = a.bs;
        let d = a.br;
        let e = this.getEffectiveViewport1(a);
        let f = new ScalerParams(0, c, d, this.barFragmentXAxis.b8, e);
        if (!c.isEmpty && !d.isEmpty && this.barFragmentXAxis != null) {
            b = this.barFragmentXAxis.dv(0, f);
        }
        return b;
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        if (this.parentSeries == null || this.barFragmentXAxis == null) {
            return;
        }
        let e = this.barFragmentXAxis;
        switch (b) {
            case "ValueColumn":
                if (this.ox.cz) {
                    this.ox.cy.g$i();
                }
                if (e != null && !e.ck()) {
                    this.parentSeries.ox().cn.g(this.eu);
                    this.jc(false);
                }
                break;
        }
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
BarFragment.$t = markType(BarFragment, 'BarFragment', ColumnFragment.$);
/**
 * @hidden
 */
export class AreaFragmentBucketCalculator extends AnchoredCategoryBucketCalculator {
    constructor(a) {
        super(a);
    }
    getBucketWithoutUnknowns(a) {
        return this.getBucket(a);
    }
    getBucket(a) {
        let b = Math.min(a * this.d, this.i.cw.valueColumn.count - 1);
        let c = Math.min(b + this.d - 1, this.i.cw.valueColumn.count - 1);
        let d = NaN;
        let e = NaN;
        let f = this.i.cw;
        let g = f.parentSeries;
        let h = typeCast(IStacked100Series_$type, g) !== null;
        let i = this.i.cw.valueColumn;
        let j = g.ou;
        let k = g.ov;
        let l = f.logicalSeriesLink.ad;
        let m = f.logicalSeriesLink.ac;
        for (let n = b; n <= c; ++n) {
            let o = i.item(n);
            if (isNaN_(o) || isInfinity(o)) {
                o = 0;
            }
            let p = Math.abs(k[n]) + j[n];
            if (h) {
                if (p == 0) {
                    o = 0;
                }
                else if (o < 0) {
                    o = (l._inner[n] + o) / p * 100;
                }
                else {
                    o = (m._inner[n] + o) / p * 100;
                }
            }
            else {
                o = o < 0 ? l._inner[n] + o : m._inner[n] + o;
            }
            if (!isNaN_(d)) {
                if (!isNaN_(o)) {
                    d = Math.min(d, o);
                    e = Math.max(e, o);
                }
            }
            else {
                d = o;
                e = o;
            }
        }
        if (!isNaN_(d)) {
            return [0.5 * (b + c), d, e];
        }
        return [0.5 * (b + c), NaN, NaN];
    }
}
AreaFragmentBucketCalculator.$t = markType(AreaFragmentBucketCalculator, 'AreaFragmentBucketCalculator', AnchoredCategoryBucketCalculator.$);
/**
 * @hidden
 */
export class LineFragmentBucketCalculator extends AnchoredCategoryBucketCalculator {
    constructor(a) {
        super(a);
    }
    getBucketWithoutUnknowns(a) {
        return this.getBucket(a);
    }
    getBucket(a) {
        let b = Math.min(a * this.d, this.i.cw.valueColumn.count - 1);
        let c = Math.min(b + this.d - 1, this.i.cw.valueColumn.count - 1);
        let d = NaN;
        let e = NaN;
        let f = typeCast(FragmentBase.$, this.i.cw);
        let g = f.parentSeries;
        for (let h = b; h <= c; ++h) {
            let i = this.i.cw.valueColumn.item(h);
            let j = Math.abs(g.ov[h]) + g.ou[h];
            if (isNaN_(i) || isInfinity(i)) {
                i = 0;
            }
            if (typeCast(IStacked100Series_$type, g) !== null) {
                if (j == 0) {
                    i = 0;
                }
                else if (i < 0) {
                    i = (f.logicalSeriesLink.ad._inner[h] + i) / j * 100;
                }
                else {
                    i = (f.logicalSeriesLink.ac._inner[h] + i) / j * 100;
                }
            }
            else {
                i = i < 0 ? f.logicalSeriesLink.ad._inner[h] + i : f.logicalSeriesLink.ac._inner[h] + i;
            }
            if (!isNaN_(d)) {
                if (!isNaN_(i)) {
                    d = Math.min(d, i);
                    e = Math.max(e, i);
                }
            }
            else {
                d = i;
                e = i;
            }
        }
        if (!isNaN_(d)) {
            return [0.5 * (b + c), d, e];
        }
        return [0.5 * (b + c), NaN, NaN];
    }
}
LineFragmentBucketCalculator.$t = markType(LineFragmentBucketCalculator, 'LineFragmentBucketCalculator', AnchoredCategoryBucketCalculator.$);
/**
 * @hidden
 */
export class SplineFragmentBucketCalculator extends AnchoredCategoryBucketCalculator {
    constructor(a) {
        super(a);
    }
    getBucket(a) {
        let b = Math.min(a * this.d, this.i.cw.valueColumn.count - 1);
        let c = Math.min(b + this.d - 1, this.i.cw.valueColumn.count - 1);
        let d = NaN;
        let e = NaN;
        let f = typeCast(SplineFragmentBase.$, this.i.cw);
        let g = f.parentSeries;
        for (let h = b; h <= c; ++h) {
            let i = this.i.cw.valueColumn.item(h);
            let j = Math.abs(g.ov[h]) + g.ou[h];
            if (isNaN_(i) || isInfinity(i)) {
                i = 0;
            }
            if (typeCast(IStacked100Series_$type, g) !== null) {
                if (j == 0) {
                    i = 0;
                }
                else if (i < 0) {
                    i = (f.logicalSeriesLink.ad._inner[h] + i) / j * 100;
                }
                else {
                    i = (f.logicalSeriesLink.ac._inner[h] + i) / j * 100;
                }
            }
            else {
                i = i < 0 ? f.logicalSeriesLink.ad._inner[h] + i : f.logicalSeriesLink.ac._inner[h] + i;
            }
            if (!isNaN_(d)) {
                if (!isNaN_(i)) {
                    d = Math.min(d, i);
                    e = Math.max(e, i);
                }
            }
            else {
                d = i;
                e = i;
            }
        }
        if (!isNaN_(d)) {
            return [0.5 * (b + c), d, e];
        }
        return [0.5 * (b + c), NaN, NaN];
    }
}
SplineFragmentBucketCalculator.$t = markType(SplineFragmentBucketCalculator, 'SplineFragmentBucketCalculator', AnchoredCategoryBucketCalculator.$);
/**
 * @hidden
 */
export class StackedBucketCalculator extends CategoryBucketCalculator {
    constructor(a) {
        super(a);
    }
    getBucket(a) {
        let b = typeCast(StackedSeriesBase.$, this.c.cp);
        let c = Math.min(b.ov != null ? b.ov.length : 0, b.ou != null ? b.ou.length : 0);
        let d = Math.min(a * this.d, c - 1);
        let e = Math.min(d + this.d - 1, c - 1);
        let f = NaN;
        let g = NaN;
        for (let h = d; h <= e; ++h) {
            let i = Math.min(b.ov[h], b.ou[h]);
            let j = Math.max(b.ov[h], b.ou[h]);
            if (!isNaN_(f)) {
                if (!isNaN_(i)) {
                    f = Math.min(f, i);
                    g = Math.max(g, i);
                }
                if (!isNaN_(j)) {
                    f = Math.min(f, j);
                    g = Math.max(g, j);
                }
            }
            else {
                f = i;
                g = j;
            }
        }
        if (!isNaN_(f) && !isNaN_(g)) {
            return [0.5 * (d + e), f, g];
        }
        return [NaN, NaN, NaN];
    }
    getBucket1(a, b, c, d, e, f) {
        return null;
    }
}
StackedBucketCalculator.$t = markType(StackedBucketCalculator, 'StackedBucketCalculator', CategoryBucketCalculator.$);
/**
 * @hidden
 */
export class StackedBarBucketCalculator extends StackedBucketCalculator {
    constructor(a) {
        super(a);
    }
    g(a) {
        let b = this.c.bs;
        let c = this.c.br;
        let d = typeCast(StackedBarSeries.$, this.c.cp);
        let e = this.c.cp.bz;
        if (b.isEmpty || c.isEmpty || d.yAxis == null || e == null || e.count == 0) {
            this.d = 0;
            return;
        }
        let f = d.getEffectiveViewport1(this.c);
        let g = new ScalerParams(0, b, c, d.yAxis.b8, f);
        let h = d.lp(this.c);
        let i = Math.floor(d.yAxis.dz(h.top, g, 0));
        let j = Math.ceil(d.yAxis.dz(h.bottom, g, 0));
        if (!d.yAxis.b8) {
            j = Math.ceil(d.yAxis.dz(h.top, g, 0));
            i = Math.floor(d.yAxis.dz(h.bottom, g, 0));
        }
        let k = Math.floor((j - i + 1) * a / h.height);
        this.d = truncate(Math.max(1, k));
        this.e = truncate(Math.max(0, Math.floor(i / this.d) - 1));
        this.f = truncate(Math.ceil(j / this.d));
    }
    getBucket(a) {
        return super.getBucket(a);
    }
    getBucket1(a, b, c, d, e, f) {
        let g = [NaN, NaN, NaN];
        let h = typeCast(BarFragment.$, a);
        if (h == null || h.logicalSeriesLink == null) {
            return g;
        }
        let i = typeCast(StackedBarSeries.$, this.c.cp);
        let j = a.valueColumn.item(c);
        let k = 0;
        let l = NaN;
        let m = NaN;
        let n = Number.NEGATIVE_INFINITY;
        let o = Number.POSITIVE_INFINITY;
        let p = i.getEffectiveViewport1(this.c);
        let q = Math.min(i.ov != null ? i.ov.length : 0, i.ou != null ? i.ou.length : 0);
        let r = c * this.d;
        let s = Math.min(r + this.d - 1, q - 1);
        for (let t = r; t <= s; ++t) {
            j = a.valueColumn.item(t);
            if (j < k) {
                o = Math.min(o, h.logicalSeriesLink.ad._inner[t] + j);
                n = Math.max(n, h.logicalSeriesLink.ad._inner[t]);
            }
            else {
                o = Math.min(o, h.logicalSeriesLink.ac._inner[t]);
                n = Math.max(n, h.logicalSeriesLink.ac._inner[t] + j);
            }
            if (!isNaN_(l)) {
                if (!isNaN_(o)) {
                    l = Math.min(l, o);
                    m = Math.max(m, o);
                }
                if (!isNaN_(n)) {
                    l = Math.min(l, n);
                    m = Math.max(m, n);
                }
            }
            else {
                l = o;
                m = n;
            }
        }
        let u = new ScalerParams(0, d, e, i.xAxis.b8, p);
        g = [f.f._inner[b - this.e][0], i.xAxis.dv(m, u), i.xAxis.dv(l, u)];
        return g;
    }
}
StackedBarBucketCalculator.$t = markType(StackedBarBucketCalculator, 'StackedBarBucketCalculator', StackedBucketCalculator.$);
/**
 * @hidden
 */
export class StackedColumnBucketCalculator extends StackedBucketCalculator {
    constructor(a) {
        super(a);
    }
    getBucket(a) {
        return super.getBucket(a);
    }
    getBucket1(a, b, c, d, e, f) {
        let g = [NaN, NaN, NaN];
        let h = typeCast(ColumnFragment.$, a);
        if (h == null || h.logicalSeriesLink == null) {
            return g;
        }
        let i = typeCast(StackedColumnSeries.$, this.c.cp);
        let j = a.valueColumn.item(c);
        let k = 0;
        let l = NaN;
        let m = NaN;
        let n = Number.NEGATIVE_INFINITY;
        let o = Number.POSITIVE_INFINITY;
        let p = i.getEffectiveViewport1(this.c);
        let q = Math.min(i.ov != null ? i.ov.length : 0, i.ou != null ? i.ou.length : 0);
        let r = c * this.d;
        let s = Math.min(r + this.d - 1, q - 1);
        for (let t = r; t <= s; ++t) {
            j = a.valueColumn.item(t);
            if (j < k) {
                o = Math.min(o, h.logicalSeriesLink.ad._inner[t] + j);
                n = Math.max(n, h.logicalSeriesLink.ad._inner[t]);
            }
            else {
                o = Math.min(o, h.logicalSeriesLink.ac._inner[t]);
                n = Math.max(n, h.logicalSeriesLink.ac._inner[t] + j);
            }
            if (!isNaN_(l)) {
                if (!isNaN_(o)) {
                    l = Math.min(l, o);
                    m = Math.max(m, o);
                }
                if (!isNaN_(n)) {
                    l = Math.min(l, n);
                    m = Math.max(m, n);
                }
            }
            else {
                l = o;
                m = n;
            }
        }
        let u = new ScalerParams(0, d, e, i.yAxis.b8, p);
        g = [f.f._inner[b - this.e][0], i.yAxis.dv(m, u), i.yAxis.dv(l, u)];
        return g;
    }
}
StackedColumnBucketCalculator.$t = markType(StackedColumnBucketCalculator, 'StackedColumnBucketCalculator', StackedBucketCalculator.$);
/**
 * @hidden
 */
export class LineFragment extends FragmentBase {
    constructor() {
        super();
        this.ab = LineFragment.$;
    }
    bf() {
        return new LineFragmentView(this);
    }
    it(a) {
        super.it(a);
        this.qo = a;
    }
    qq(a, b) {
        let c = this.qo.c8.aj;
        if (this.dj(a, c)) {
            return true;
        }
        return false;
    }
    get_ck() {
        return true;
    }
    dh(a, b) {
        if (this.qp(a, b)) {
            return true;
        }
        if (this.qq(a, b)) {
            return true;
        }
        if (this.l3(a, b)) {
            return true;
        }
        return false;
    }
    qp(a, b) {
        let c = this.qo.c9.aj;
        if (this.di(a, b, c)) {
            return true;
        }
        let d = this.qo.da.aj;
        if (this.di(a, b, d)) {
            return true;
        }
        return false;
    }
    preferredCategoryMode(a) {
        return 0;
    }
    hv(a, b) {
        super.hv(a, b);
        let c = b;
        c.c7();
    }
    on(a, b) {
        super.on(a, b);
        let c = (d) => a.f._inner[d][0];
        let d = (e) => a.f._inner[e][1];
        let e = (f) => a.f._inner[f][0];
        let f = (g) => a.f._inner[g][2];
        this.qg.a = typeCast(ISortingAxis_$type, this.xAxis) !== null ? true : false;
        let g = b.cn.d;
        let h = typeCast(LineFragmentView.$, b);
        this.qg.m(h.c9, h.c8, h.da, a.f.count, a.f, true, 0, this.ov(a.f, a.f.count - 1, b.br, b.bs), g, this.eu);
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
LineFragment.$t = markType(LineFragment, 'LineFragment', FragmentBase.$);
/**
 * @hidden
 */
export class SplineFragmentBase extends SplineSeriesBase {
    constructor() {
        super();
        this._logicalSeriesLink = null;
        this.qq = null;
        this.qs = null;
        this.qq = new CategoryLineRasterizer();
    }
    get logicalSeriesLink() {
        return this._logicalSeriesLink;
    }
    set logicalSeriesLink(a) {
        this._logicalSeriesLink = a;
    }
    get parentSeries() {
        return this.qs;
    }
    set parentSeries(a) {
        this.qs = a;
    }
    get_cq() {
        return false;
    }
    preferredCategoryMode(a) {
        return 0;
    }
    get_cs() {
        return true;
    }
    e7() {
        let a = this.parentSeries;
        if (a.fh == -1 || a.o2 == null || a.o2.f.indexOf(this) == -1) {
            return -1;
        }
        return a.o2.f.indexOf(this);
    }
    resolveLegendIndex() {
        let a = this.parentSeries;
        if (a.o5) {
            return -1 + a.fh + a.oy.count - a.o2.f.indexOf(this);
        }
        return super.resolveLegendIndex();
    }
    fb() {
        let a = this.parentSeries;
        if (a.fh == -1 || a.series.count == 0 || a.series.indexOf(this.logicalSeriesLink) == -1) {
            return -1;
        }
        return a.series.indexOf(this.logicalSeriesLink);
    }
    a6() {
        return this.parentSeries;
    }
    qj(a, b, c, d, e, f, g) {
        let h = b[0];
        let i = b[1];
        let j = new Rect(0, h - 5, i - 5, 11, 11);
        if (!isNaN_(h) && !isNaN_(i) && !isInfinity(h) && !isInfinity(i) && c.tryAdd(j)) {
            a.m.add({ $type: Point_$type, x: h, y: i });
            let k = f.cq.item(e);
            k.content.item = this.bz.item(d);
            k.al = g;
            return true;
        }
        return false;
    }
    dw(a, b, c) {
        let d = super.dw(a, b, c);
        let e = typeCast(CategoryAxisBase.$, this.parentSeries.fetchXAxis());
        let f = this.parentSeries.fetchYAxis();
        if (this.parentSeries == null || e == null || e.itemsSource == null || f == null || this.parentSeries.bz == null || e.bf == null || f.bf == null) {
            d = false;
        }
        if (this.valueColumn == null) {
            return false;
        }
        if (isInfinity(this.valueColumn.minimum) && isInfinity(this.valueColumn.maximum)) {
            d = false;
        }
        if (isNaN_(this.valueColumn.minimum) && isNaN_(this.valueColumn.maximum)) {
            d = false;
        }
        return d;
    }
    an(a) {
        return null;
    }
    qu(a, b, c, d, e, f) {
        let g = typeCast(ISortingAxis_$type, d);
        if (g == null) {
            return;
        }
        let h = this.getEffectiveViewport1(f);
        let i = new ScalerParams(0, b, c, d.b8, h);
        let j = new ScalerParams(0, b, c, e.b8, h);
        let k = d.dy(2, i) - d.dy(1, i);
        let l = this.l2();
        let m = 0;
        let n = this.ql(d, b, c, h);
        let o = (p) => Math.abs(this.parentSeries.ov[p]) + this.parentSeries.ou[p];
        let p = (q) => q;
        let q = (r) => {
            let s = g.i$b._inner[r];
            if (typeCast(IStacked100Series_$type, this.parentSeries) !== null) {
                return this.valueColumn.item(s) < 0 ? (this.logicalSeriesLink.ad._inner[s] + this.valueColumn.item(s)) / o(s) * 100 : (this.logicalSeriesLink.ac._inner[s] + this.valueColumn.item(s)) / o(s) * 100;
            }
            else {
                return this.valueColumn.item(s) < 0 ? this.logicalSeriesLink.ad._inner[s] + this.valueColumn.item(s) : this.logicalSeriesLink.ac._inner[s] + this.valueColumn.item(s);
            }
        };
        let r = this.ne.cn.f;
        let s = this.ne.cn.e;
        let t = truncate(Math.ceil(c.width / (r - s)));
        let u = new CollisionAvoider();
        let v = this.ne.cn.d;
        if (v <= 0 || (s <= 0 && r <= 0)) {
            this.ne.cq.count = m;
            return;
        }
        let w = 0;
        for (let x = s; x < r + 1; ++x) {
            let y = null;
            let z = x * v;
            if (g != null && g.i$b != null && z >= 0 && z < g.i$b.count) {
                z = g.i$b._inner[z];
            }
            if (x >= (this.valueColumn.count - 1)) {
                if (l && this.qj(a, a.f._inner[a.f.count - 1], u, Math.min(z, this.bz.count - 1), m, f, w - 1)) {
                    ++m;
                }
                break;
            }
            let aa = p(x);
            let ab = q(x);
            let ac = p(x + 1);
            let ad = q(x + 1);
            let ae = ac - aa;
            let af = this.qg[x];
            let ag = this.qg[x + 1];
            let ah = g.i$d(g.i$b._inner[x]);
            let ai = d.dv(ah, i) + n;
            let aj = e.dv(ab, j);
            a.f.add([ai, aj, aj]);
            w++;
            for (let ak = 1; ak < t; ++ak) {
                let al = ak / t;
                let am = aa + ae * al;
                let an = (ac - am) / ae;
                let ao = (am - aa) / ae;
                let ap = an * ab + ao * ad + ((an * an * an - an) * af + (ao * ao * ao - ao) * ag) * (ae * ae) / 6;
                let aq = g.i$d(g.i$b._inner[x]);
                let ar = g.i$d(g.i$b._inner[x + 1]);
                if (aq == ar && ab == ad) {
                    break;
                }
                let as = aq + (ar - aq) * al;
                am = d.dv(as, i) + n;
                ap = e.dv(ap, j);
                a.f.add([am, ap, ap]);
                w++;
            }
            if (l) {
                y = [ai, aj, aj];
            }
            if (l && this.qj(a, y, u, Math.min(z, this.bz.count - 1), m, f, w - 1)) {
                ++m;
            }
        }
        this.ne.cq.count = m;
    }
    ok(a, b) {
        a.u();
        if (this.valueColumn == null || this.parentSeries == null || this.logicalSeriesLink == null) {
            return;
        }
        if (this.logicalSeriesLink.ad.count == 0 || this.logicalSeriesLink.ac.count == 0) {
            return;
        }
        if (this.ne.cn.d == 0) {
            return;
        }
        super.ok(a, b);
        if (a.f.count <= 1) {
            return;
        }
        let c = b.bs;
        let d = b.br;
        let e = this.getEffectiveViewport1(b);
        let f = typeCast(CategoryAxisBase.$, this.parentSeries.fetchXAxis());
        let g = typeCast(NumericYAxis.$, this.parentSeries.fetchYAxis());
        let h = new ScalerParams(0, c, d, f.b8, e);
        let i = new ScalerParams(0, c, d, g.b8, e);
        a.f.clear();
        a.m.clear();
        let j = this.l2();
        let k = 0;
        let l;
        let m;
        if (b.m) {
            l = this.parentSeries.ow;
            m = this.parentSeries.a0.a$h.item(b.aa);
        }
        else if (b == this.bh) {
            l = this.parentSeries.m8;
            m = typeCast(CategorySeriesView.$, this.parentSeries.bh);
        }
        else {
            l = this.parentSeries.m6;
            m = this.parentSeries.ne;
        }
        let n = m.cn.d;
        let o = typeCast(ISortingAxis_$type, f);
        if (o != null && o.i$b.count != this.bz.count) {
            return;
        }
        let p = this.preferredCategoryMode(f);
        if (p == 0 && f.categoryMode != 0) {
            p = 1;
        }
        let q = 0;
        switch (p) {
            case 0:
                q = 0;
                break;
            case 1:
                q = 0.5 * f.getCategorySize(c, d, e);
                break;
            case 2:
                let r = this.fh;
                q = f.getGroupCenter(this.fh, c, d, e);
                break;
        }
        if (f.b8) {
            q = -q;
        }
        let s = (t) => Math.abs(this.parentSeries.ov[t]) + this.parentSeries.ou[t];
        let t = (u) => u;
        let u = (v) => {
            let w = this.valueColumn.item(v);
            if (isNaN_(w) || isInfinity(w)) {
                w = 0;
            }
            if (typeCast(IStacked100Series_$type, this.parentSeries) !== null) {
                if (s(v) == 0) {
                    return 0;
                }
                return w < 0 ? (this.logicalSeriesLink.ad._inner[v] + w) / s(v) * 100 : (this.logicalSeriesLink.ac._inner[v] + w) / s(v) * 100;
            }
            return w < 0 ? this.logicalSeriesLink.ad._inner[v] + w : this.logicalSeriesLink.ac._inner[v] + w;
        };
        let v = b.cn.d;
        let w = this.qi == 0 ? NaN : 0;
        if (f != null && typeCast(ISortingAxis_$type, f) !== null && f.i$b != null) {
            let x = new SafeSortedReadOnlyDoubleCollection(0, this.valueColumn, f.i$b);
            u = (y) => x.item(y);
        }
        this.qg = Numeric.c(this.valueColumn.count, t, u, w, w);
        let y = m.cn.e;
        let z = m.cn.f;
        let aa = truncate(Math.ceil(d.width / (z - y)));
        let ab = new CollisionAvoider();
        if (o != null) {
            this.qu(a, c, d, f, g, b);
            return;
        }
        let ac = 0;
        let ad = 0;
        for (let ae = y; ae < z + 1; ++ae) {
            if (ae >= this.valueColumn.count) {
                break;
            }
            let af = null;
            if (v == 1) {
                if (ae >= (this.valueColumn.count - 1)) {
                    if (j && a.f.count > 0 && this.qj(a, a.f._inner[a.f.count - 1], ab, Math.min(ae * v, this.bz.count - 1), k, b, ac - 1)) {
                        ++k;
                    }
                    break;
                }
                let ag = t(ae);
                let ah = t(ae + 1);
                let ai = u(ae);
                let aj = u(ae + 1);
                let ak = ah - ag;
                let al = this.qg[ae];
                let am = this.qg[ae + 1];
                let an = f.dv(ag, h) + q;
                let ao = g.dv(ai, i);
                a.f.add([an, ao, ao]);
                ac++;
                ad = ac;
                for (let ap = 1; ap < aa; ++ap) {
                    let aq = ag + ak * ap / aa;
                    let ar = (ah - aq) / ak;
                    let as = (aq - ag) / ak;
                    let at = ar * ai + as * aj + ((ar * ar * ar - ar) * al + (as * as * as - as) * am) * (ak * ak) / 6;
                    aq = f.dv(aq, h) + q;
                    at = g.dv(at, i);
                    a.f.add([aq, at, at]);
                    ac++;
                }
                if (j) {
                    af = [an, ao, ao];
                }
            }
            else {
                af = b.cn.getBucket(ae);
                if (!isNaN_(af[0])) {
                    af[0] = f.dv(af[0], h) + q;
                    af[1] = g.dv(af[1], i);
                    af[2] = g.dv(af[2], i);
                    a.f.add(af);
                }
            }
            if (j && this.qj(a, af, ab, Math.min(ae * v, this.bz.count - 1), k, b, ad - 1)) {
                ++k;
            }
        }
        b.cq.count = k;
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case "ActualBrush":
                if (this.logicalSeriesLink != null) {
                    this.logicalSeriesLink.fp = this.k2;
                }
                break;
        }
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
SplineFragmentBase.$t = markType(SplineFragmentBase, 'SplineFragmentBase', SplineSeriesBase.$);
/**
 * @hidden
 */
export class SplineAreaFragment extends SplineFragmentBase {
    constructor() {
        super();
        this.qz = null;
        this.ab = SplineAreaFragment.$;
    }
    bf() {
        return new SplineAreaFragmentView(this);
    }
    it(a) {
        super.it(a);
        this.qv = typeCast(SplineAreaFragmentView.$, a);
    }
    ac() {
        super.ac();
        this.jc(false);
    }
    get_ck() {
        return true;
    }
    qx(a, b) {
        let c = this.qv.c9.aj;
        if (this.dj(a, c)) {
            return true;
        }
        let d = this.qv.da.aj;
        if (this.dj(a, d)) {
            return true;
        }
        return false;
    }
    dh(a, b) {
        if (this.qw(a, b)) {
            return true;
        }
        if (this.qx(a, b)) {
            return true;
        }
        if (this.l3(a, b)) {
            return true;
        }
        return false;
    }
    qw(a, b) {
        let c = this.qv.db.aj;
        if (this.di(a, b, c)) {
            return true;
        }
        let d = this.qv.dc.aj;
        if (this.di(a, b, d)) {
            return true;
        }
        return false;
    }
    hv(a, b) {
        super.hv(a, b);
        let c = b;
        c.c8();
    }
    on(a, b) {
        super.on(a, b);
        this.qq.a = typeCast(ISortingAxis_$type, this.xAxis) !== null ? true : false;
        let c = typeCast(SplineAreaFragmentView.$, b);
        let d = b.cn.d;
        this.qq.i(c.c9, c.db, c.da, c.dc, a.f.count, a.f, true, d, this.eu, (e, f, g, h, i) => this.qy(e, a.f, b), 1);
        c.c9._opacity = this.d6;
        c.da._opacity = 0.5 * this.d6;
    }
    je(a, b) {
        super.je(a, b);
    }
    qy(a, b, c) {
        let d = this.o6(c);
        let e = d;
        let f = this.logicalSeriesLink.y;
        let g = f ? this.parentSeries.o2.e : this.parentSeries.o2.d;
        let h = g.indexOf(this);
        if (a.count == 0) {
            return;
        }
        if (h == -1) {
            return;
        }
        let i = false;
        for (let j = h; j >= 0; j--) {
            if (i) {
                break;
            }
            if (j == 0) {
                a.add({ $type: Point_$type, x: a._inner[a.count - 1].x, y: e });
                a.add({ $type: Point_$type, x: a._inner[0].x, y: e });
                break;
            }
            let k = typeCast(SplineFragmentBase.$, g._inner[j - 1]);
            if (k != null && k.qq != null && k.qq.o.count > 0 && this.bi != null && k.dw(this.bi.br, this.bi.bs, this.bi)) {
                i = true;
                for (let l = k.qq.o.count - 1; l >= 0; l--) {
                    a.add(k.qq.o._inner[l]);
                }
            }
        }
    }
    o6(a) {
        let b = 0;
        let c = a.bs;
        let d = a.br;
        let e = this.getEffectiveViewport1(a);
        let f = new ScalerParams(0, c, d, this.yAxis.b8, e);
        if (!c.isEmpty && !d.isEmpty && this.yAxis != null) {
            b = this.yAxis.dv(0, f);
        }
        return b;
    }
    jm() {
        let a = (typeCast(XamDataChart.$, this.bs));
        if (a != null) {
            this.d6 = isNaN_(this.d7) ? this.parentSeries.d6 : this.d7;
        }
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
SplineAreaFragment.$t = markType(SplineAreaFragment, 'SplineAreaFragment', SplineFragmentBase.$);
/**
 * @hidden
 */
export class SplineFragment extends SplineFragmentBase {
    constructor() {
        super();
        this.ab = SplineFragment.$;
    }
    bf() {
        return new SplineFragmentView(this);
    }
    it(a) {
        super.it(a);
        this.qv = a;
    }
    qx(a, b) {
        let c = this.qv.c9.aj;
        if (this.dj(a, c)) {
            return true;
        }
        return false;
    }
    get_ck() {
        return true;
    }
    dh(a, b) {
        if (this.qw(a, b)) {
            return true;
        }
        if (this.qx(a, b)) {
            return true;
        }
        if (this.l3(a, b)) {
            return true;
        }
        return false;
    }
    qw(a, b) {
        let c = this.qv.da.aj;
        if (this.di(a, b, c)) {
            return true;
        }
        let d = this.qv.db.aj;
        if (this.di(a, b, d)) {
            return true;
        }
        return false;
    }
    hv(a, b) {
        super.hv(a, b);
        let c = b;
        c.c8();
    }
    on(a, b) {
        super.on(a, b);
        this.qq.a = typeCast(ISortingAxis_$type, this.xAxis) !== null ? true : false;
        let c = typeCast(SplineFragmentView.$, b);
        let d = c.cn.d;
        this.qq.m(c.da, c.c9, c.db, a.f.count, a.f, true, 1, this.ov(a.f, a.f.count - 1, b.br, b.bs), d, this.eu);
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
SplineFragment.$t = markType(SplineFragment, 'SplineFragment', SplineFragmentBase.$);
/**
 * @hidden
 */
export class StackedSeriesBase extends CategorySeries {
    constructor() {
        super();
        this._series = null;
        this.seriesCreated = null;
        this.pb = 0;
        this.pa = 0;
        this.ou = null;
        this.ov = null;
        this.o2 = null;
        this.oz = null;
        this.o7 = new Dictionary$2(String_$type, Boolean_$type, 0);
        this.ow = null;
        this.series = new StackedSeriesCollection();
        let a = this.series;
        a.collectionResetting = delegateCombine(a.collectionResetting, runOn(this, this.pn));
        let b = this.series;
        b.collectionChanged = delegateCombine(b.collectionChanged, runOn(this, this.pm));
        this.na = new StackedSeriesFramePreparer(1, this, this.o3, this, this, this.o3.cn);
        this.o2 = new StackedSeriesManager(this);
        this.oz = new StackedSeriesCollection();
        let c = this.oz;
        c.collectionChanged = delegateCombine(c.collectionChanged, runOn(this, this.pm));
        let d = this.oz;
        d.collectionResetting = delegateCombine(d.collectionResetting, runOn(this, this.ph));
    }
    get_cv() {
        return false;
    }
    getHostReferenceValue() {
        return this.eh();
    }
    bf() {
        return new StackedSeriesView(this);
    }
    it(a) {
        super.it(a);
        this.o3 = a;
    }
    iu(a, b) {
        super.iu(a, b);
        for (let c of fromEnum(this.series)) {
            c.visualSeriesLink.bi.br = b;
        }
    }
    get series() {
        return this._series;
    }
    set series(a) {
        this._series = a;
    }
    fg() {
        if (this.series == null) {
            return -1;
        }
        return this.series.count;
    }
    h7(a) {
        for (let b = 0; b < this.o2.f.count; b++) {
            let c = this.o2.f._inner[b];
            if (!a(c)) {
                break;
            }
        }
    }
    get_isStacked() {
        return true;
    }
    get oy() {
        return this.o4 ? this.oz : this.series;
    }
    ph(a, b) {
        for (let c of fromEnum(this.oz)) {
            if (this.o2 != null && this.o2.c.contains(c)) {
                c.parentSeries = null;
                this.o2.c.remove(c);
            }
        }
    }
    pn(a, b) {
        for (let c of fromEnum(this.series)) {
            if (this.o2 != null && this.o2.c.contains(c)) {
                c.parentSeries = null;
                this.o2.c.remove(c);
            }
        }
    }
    pm(a, b) {
        if (b.oldItems != null) {
            for (let c of fromEn(b.oldItems)) {
                if (this.o2 != null && this.o2.c.contains(c)) {
                    c.parentSeries = null;
                    this.o2.c.remove(c);
                }
            }
        }
        if (b.newItems != null) {
            let d = b.newStartingIndex;
            for (let e of fromEn(b.newItems)) {
                if (this.o2 != null && !this.o2.c.contains(e)) {
                    e.parentSeries = this;
                    e.c1();
                    e.dg();
                    e.dh();
                    e.dp();
                    e.di();
                    e.dj();
                    e.cx();
                    e.cy();
                    e.cz();
                    e.c0();
                    e.c2();
                    e.c3();
                    e.c4();
                    e.c5();
                    e.c9();
                    e.da();
                    e.c6();
                    e.c7();
                    e.c8();
                    e.c9();
                    e.db();
                    e.dc();
                    e.dd();
                    e.cw();
                    e.de();
                    e.df();
                    e.dk();
                    e.dl();
                    e.dm();
                    e.dn();
                    e.dq();
                    if (!this.o4) {
                        this.o2.c.insert(d, e);
                        d++;
                    }
                }
            }
        }
        if (!this.o4) {
            this.po();
        }
    }
    jj(a) {
        this.bq.bn.cz(a, true, false);
    }
    nb(a) {
        if (a != null && a.n) {
            if (a.m) {
                return new StackedSeriesFramePreparer(1, typeCast(IIsCategoryBased_$type, this), typeCast(ISupportsMarkers_$type, a), a, this, a.cn);
            }
            else {
                let b = typeCast(CategorySeriesView.$, this.bh);
                return new StackedSeriesFramePreparer(1, this, typeCast(ISupportsMarkers_$type, b), this.bs.bn.m, this, b.cn);
            }
        }
        else {
            return this.na;
        }
    }
    ok(a, b) {
        a.u();
        this.pk();
        this.nb(b).d(a, b);
    }
    hv(a, b) {
        super.hv(a, b);
        for (let c of fromEnum(this.oy)) {
            if (c.visualSeriesLink != null) {
                c.visualSeriesLink.hv(a, c.visualSeriesLink.bi);
            }
        }
    }
    pi() {
        this.pk();
    }
    po() {
        let a = this.fetchXAxis();
        if (a != null) {
            a.cl(true);
        }
        let b = this.fetchYAxis();
        if (b != null) {
            b.cl(true);
        }
    }
    c9(a) {
        let b = this.bz != null ? this.bz.indexOf(a) : -1;
        let c = this.bs != null ? this.bs.mq : Rect.empty;
        c = c.copy();
        let d = this.bi.br;
        let e = new Rect(0, 0, 0, 1, 1);
        let f = this.lr(this.bi);
        if (b >= 0 && Rect.l_op_Inequality(c, null) && Rect.l_op_Inequality(d, null)) {
            let g = this.fetchXAxis();
            if (g != null) {
                let h = new ScalerParams(0, e, e, g.b8, f);
                let i = g.dv(b, h);
                if (i < c.left + 0.1 * c.width) {
                    i = i + 0.4 * c.width;
                }
                if (i > c.right - 0.1 * c.width) {
                    i = i - 0.4 * c.width;
                }
                c.x = i - 0.5 * c.width;
            }
            let j = this.fetchYAxis();
            if (j != null && this.ou != null && b < this.ou.length) {
                let k = new ScalerParams(0, e, e, j.b8, f);
                let l = j.dv(this.ou[b], k);
                let m = j.dv(this.ov[b], k);
                if (!isNaN_(l) && !isNaN_(m)) {
                    let n = Math.abs(m - l);
                    if (c.height < n) {
                        c.height = n;
                        c.y = Math.min(m, l);
                    }
                    else {
                        if (m < c.top + 0.1 * c.height) {
                            m = m + 0.4 * c.height;
                        }
                        if (m > c.bottom - 0.1 * c.height) {
                            m = m - 0.4 * c.height;
                        }
                        c.y = m - 0.5 * c.height;
                    }
                }
            }
            this.bn.ap(this.bs, c, true);
        }
        return b >= 0;
    }
    an(a) {
        if (this.ov == null || this.ov.length == 0 || this.ou == null || this.ou.length == 0) {
            return null;
        }
        if (a == this.fetchXAxis()) {
            let b = Math.min(this.ov.length, this.ou.length);
            return new AxisRange(0, b - 1);
        }
        if (a == this.fetchYAxis()) {
            return new AxisRange(this.pb, this.pa);
        }
        return null;
    }
    l2() {
        return false;
    }
    hy(a, b, c, d) {
        this.pk();
        this.n0();
        this.jc(false);
    }
    ox() {
        return this.o3;
    }
    o8() {
        let a = 0;
        let b = this.bi.bs;
        let c = this.bi.br;
        let d = this.getEffectiveViewport1(this.bi);
        let e = typeCast(NumericYAxis.$, this.fetchYAxis());
        if (!b.isEmpty && !c.isEmpty && e != null) {
            let f = new ScalerParams(0, b, c, e.b8, d);
            a = e.dv(e.kd, f);
        }
        return a;
    }
    o9() {
        let a = typeCast(NumericYAxis.$, this.fetchYAxis());
        if (a != null) {
            return a.kd;
        }
        return 0;
    }
    pd(a) {
        return this.fh < 0 || this.oy == null || this.oy.count == 0 ? -1 : this.fh + this.oy.indexOf(a);
    }
    pc(a) {
        let b = this.bs != null ? this.bs.mq : Rect.empty;
        let c = this.bi.br;
        let d = this.getEffectiveViewport1(this.bi);
        let e = typeCast(CategoryAxisBase.$, this.fetchXAxis());
        let f = -1;
        if (e != null && !b.isEmpty && !c.isEmpty) {
            let g = new ScalerParams(0, b, c, e.b8, d);
            let h = this.lp(this.bi);
            let i = e.dy(h.left, g);
            let j = e.dy(h.right, g);
            let k = (a.x - b.left) / b.width;
            let l = i + (k * (j - i));
            if (e.categoryMode != 0) {
                l -= 0.5;
            }
            let m = truncate(Math.round(l));
            f = m;
        }
        return f;
    }
    o6(a, b, c, d) {
        let e = true;
        let f = typeCast(CategoryAxisBase.$, this.fetchXAxis());
        let g = typeCast(NumericYAxis.$, this.fetchYAxis());
        if (!d.l() || c.isEmpty || b.isEmpty || f == null || f.itemsSource == null || g == null || this.bz == null || f.bf == null || g.bf == null || g.j3 == g.j2) {
            e = false;
        }
        let h = d;
        let i = h.cn.d;
        if (a.valueColumn == null || a.valueColumn.count == 0 || i < 1 || a._visibility != 0) {
            e = false;
        }
        return e;
    }
    pj() {
        if (this.bs == null || this.o2 == null) {
            return;
        }
        if (!this.o4) {
            this.oz.clear();
            for (let a of fromEnum(this.series)) {
                if (!this.o2.c.contains(a)) {
                    this.o2.c.add(a);
                }
            }
            this.po();
            return;
        }
    }
    on(a, b) {
        super.on(a, b);
        this.o2.h();
    }
    pl(a, b, c) {
    }
    pk() {
        if (this.bz == null) {
            return;
        }
        let a = this.bz.count;
        this.ou = new Array(a);
        this.ov = new Array(a);
        for (let b = 0; b < a; b++) {
            this.ou[b] = 0;
            this.ov[b] = 0;
        }
        this.pb = Number.POSITIVE_INFINITY;
        this.pa = Number.NEGATIVE_INFINITY;
        let c = 0;
        for (let d of fromEnum(this.oy)) {
            this.bz.deregisterColumn(d.p);
            d.p = this.bw(d.cq);
            if (d.visualSeriesLink != null) {
                d.visualSeriesLink.o5 = true;
                d.visualSeriesLink.valueColumn = d.p;
                d.visualSeriesLink.o5 = false;
            }
            d.y = true;
            if (d.p != null) {
                d.ac.clear();
                d.ad.clear();
                for (let e = 0; e < d.p.count; e++) {
                    let f = d.p.item(e);
                    if (f < c) {
                        d.ac.add(c);
                        d.ad.add(this.ov[e]);
                        this.ov[e] = this.ov[e] + f;
                        if (d.y) {
                            d.y = false;
                        }
                    }
                    else if (f >= c) {
                        d.ac.add(this.ou[e]);
                        d.ad.add(c);
                        this.ou[e] = this.ou[e] + f;
                    }
                    else if (isNaN_(f) || isInfinity(f)) {
                        d.ac.add(this.ou[e]);
                        d.ad.add(this.ov[e]);
                    }
                }
            }
        }
        for (let g = 0; g < a; g++) {
            this.pb = Math.min(this.pb, this.ov[g]);
            this.pa = Math.max(this.pa, this.ou[g]);
        }
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case "SeriesViewer":
                if (c != null && d == null) {
                    this.hz(this.fetchXAxis());
                    this.hz(this.fetchYAxis());
                }
                if (c == null && d != null) {
                    this.i3(this.fetchXAxis());
                    this.i3(this.fetchYAxis());
                }
                if (this.oy != null) {
                    for (let e of fromEnum(this.oy)) {
                        e.o = this.bs;
                    }
                    this.jc(false);
                }
                break;
            case "ItemsSource":
                if (this.oy != null) {
                    for (let f of fromEnum(this.oy)) {
                        if (f.visualSeriesLink != null) {
                            f.visualSeriesLink.itemsSource = d;
                        }
                    }
                }
                break;
            case "FastItemsSource":
                if (this.o4) {
                    this.pj();
                }
                if (!this.n0()) {
                    this.o3.cn.g(this.eu);
                }
                this.jc(false);
                break;
            case StackedSeriesBase.$$p[0]:
                this.pj();
                break;
            case StackedSeriesBase.$$p[1]:
                if (this.bs != null) {
                    this.bs.ij(this.o2.f);
                }
                break;
            case StackedSeriesBase.$$p[2]:
                for (let g of fromEnum(this.oy)) {
                    g.dq();
                }
                break;
            case "Brush":
                for (let h of fromEnum(this.oy)) {
                    h.cx();
                }
                break;
            case "DashArray":
                for (let i of fromEnum(this.oy)) {
                    i.cy();
                }
                break;
            case "DashCap":
                for (let j of fromEnum(this.oy)) {
                    j.cz();
                }
                break;
            case "IsDropShadowEnabled":
                for (let k of fromEnum(this.oy)) {
                    k.c1();
                }
                break;
            case "ShadowBlur":
                for (let l of fromEnum(this.oy)) {
                    l.dg();
                }
                break;
            case "ShadowColor":
                for (let m of fromEnum(this.oy)) {
                    m.dh();
                }
                break;
            case "UseSingleShadow":
                for (let n of fromEnum(this.oy)) {
                    n.dp();
                }
                break;
            case "ShadowOffsetX":
                for (let o of fromEnum(this.oy)) {
                    o.di();
                }
                break;
            case "ShadowOffsetY":
                for (let p of fromEnum(this.oy)) {
                    p.dj();
                }
                break;
            case "EndCap":
                for (let q of fromEnum(this.oy)) {
                    q.c0();
                }
                break;
            case "IsHitTestVisible":
                for (let r of fromEnum(this.oy)) {
                    r.c2();
                }
                break;
            case "LegendItemBadgeTemplate":
                for (let s of fromEnum(this.oy)) {
                    s.c3();
                }
                break;
            case "LegendItemTemplate":
                for (let t of fromEnum(this.oy)) {
                    t.c4();
                }
                break;
            case "LegendItemVisibility":
                for (let u of fromEnum(this.oy)) {
                    u.c5();
                }
                break;
            case "MarkerTemplate":
                for (let v of fromEnum(this.oy)) {
                    v.c9();
                }
                break;
            case "MarkerType":
                for (let w of fromEnum(this.oy)) {
                    w.da();
                }
                break;
            case "MarkerBrush":
                for (let x of fromEnum(this.oy)) {
                    x.c6();
                }
                break;
            case "MarkerOutline":
                for (let y of fromEnum(this.oy)) {
                    y.c7();
                }
                break;
            case "MarkerStyle":
                for (let z of fromEnum(this.oy)) {
                    z.c8();
                }
                break;
            case "Opacity":
                for (let aa of fromEnum(this.oy)) {
                    aa.db();
                }
                break;
            case "OpacityMask":
                for (let ab of fromEnum(this.oy)) {
                    ab.dc();
                }
                break;
            case "AreaFillOpacity":
                for (let ac of fromEnum(this.oy)) {
                    ac.cw();
                }
                break;
            case "Outline":
                for (let ad of fromEnum(this.oy)) {
                    ad.dd();
                }
                break;
            case "StartCap":
                for (let ae of fromEnum(this.oy)) {
                    ae.dk();
                }
                break;
            case "Thickness":
                for (let af of fromEnum(this.oy)) {
                    af.dl();
                }
                break;
            case "ToolTip":
                for (let ag of fromEnum(this.oy)) {
                    ag.dm();
                }
                break;
            case "UseLightweightMarkers":
                for (let ah of fromEnum(this.oy)) {
                    ah.dn();
                }
                break;
        }
    }
    get currentCategoryMode() {
        return this.preferredCategoryMode(typeCast(CategoryAxisBase.$, this.fetchXAxis()));
    }
    get scaler() {
        return typeCast(ICategoryScaler_$type, this.fetchXAxis());
    }
    get yScaler() {
        return typeCast(IScaler_$type, this.fetchYAxis());
    }
    get bucketizer() {
        return this.ne.cn;
    }
    get currentMode2Index() {
        return this.n8();
    }
    provideCollisionDetector() {
        return new CollisionAvoider();
    }
    dc() {
        return false;
    }
    get_cq() {
        return false;
    }
    je(a, b) {
        let c = this.dl;
        super.je(a, b);
        if (!c) {
            this.bi.az(b);
            return;
        }
        this.bi.az(b);
        if (this.cc(this.bh)) {
            return;
        }
        for (let d of fromEnum(this.series)) {
            d.visualSeriesLink.je(a, b);
        }
        this.dl = false;
    }
    jb(a, b, c, d, e) {
        super.jb(a, b, c, d, e);
        let f = this.a0.a$h.item(d);
        f.cn.g(this.eu);
        f.ay(c);
        if (this.cc(f)) {
            return;
        }
        if (this.ow == null) {
            this.ow = new CategoryFrame(3);
        }
        this.ow.u();
        this.pk();
        this.nb(f).d(this.ow, f);
        this.on(this.ow, f);
        for (let g of fromEnum(this.series)) {
            g.visualSeriesLink.jb(a, b, c, d, e);
        }
    }
    fo() {
        let a = this.a2.exportStackedVisualData(this, this.lx);
        for (let b of fromEnum(this.series)) {
            let c = this.a2.createFragmentVisualData(this, this.lx, getInstanceType(b).typeName, b.b8);
            b.visualSeriesLink.bi.ai(c);
            this.a2.addSubSeriesVisualData(a, c);
        }
        this.h4(a);
        this.bi.ai(a);
        return a;
    }
    get mayContainUnknowns() {
        return true;
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
StackedSeriesBase.$t = markType(StackedSeriesBase, 'StackedSeriesBase', CategorySeries.$, [IIsCategoryBased_$type]);
Type.dep(DependencyProperty, PropertyMetadata, StackedSeriesBase, 'raisePropertyChanged', ['AutoGenerateSeries:o4:pp', [0, false], 'ReverseLegendOrder:o5:pq', [0, false], 'SeriesVisibility:ps:pr', [Visibility_$type, enumGetBox(Visibility_$type, 0)]]);
/**
 * @hidden
 */
export class HorizontalStackedSeriesBase extends StackedSeriesBase {
    getOffsetValue() {
        return this.na.r(this.xAxis, this.bi.bs, this.bi.br, this.getEffectiveViewport1(this.bi));
    }
    getCategoryWidth() {
        return this.xAxis.getCategorySize(this.bi.bs, this.bi.br, this.getEffectiveViewport1(this.bi));
    }
    fetchXAxis() {
        return this.xAxis;
    }
    fetchYAxis() {
        return this.yAxis;
    }
    ag() {
        return [this.fetchXAxis(), this.fetchYAxis()];
    }
    n0() {
        return this.yAxis != null && this.yAxis.ck();
    }
    jm() {
        let a = (typeCast(XamDataChart.$, this.bs));
        if (a != null) {
            this.d6 = isNaN_(this.d7) ? a.nj.fc : this.d7;
            for (let b of fromEnum(this.oy)) {
                b.cw();
            }
        }
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case HorizontalStackedSeriesBase.$$p[0]:
                if (c != d) {
                    this.hz(typeCast(Axis.$, c));
                    this.i3(typeCast(Axis.$, d));
                    this.ne.cn.g(this.eu);
                    this.jc(false);
                    this.ij();
                }
                break;
            case HorizontalStackedSeriesBase.$$p[1]:
                if (c != d) {
                    this.hz(typeCast(Axis.$, c));
                    this.i3(typeCast(Axis.$, d));
                    this.ne.cn.g(this.eu);
                    this.n0();
                    this.jc(false);
                    this.ij();
                }
                break;
        }
    }
    pw(a) {
        if (typeCast(NumericYAxis.$, a) !== null) {
            return true;
        }
        return false;
    }
    pv(a) {
        if (typeCast(CategoryXAxis.$, a) !== null || a.b5) {
            return true;
        }
        return false;
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
HorizontalStackedSeriesBase.$t = markType(HorizontalStackedSeriesBase, 'HorizontalStackedSeriesBase', StackedSeriesBase.$);
Type.dep(DependencyProperty, PropertyMetadata, HorizontalStackedSeriesBase, 'raisePropertyChanged', ['XAxis::pz', [CategoryAxisBase.$, null], 'YAxis::p0', [NumericYAxis.$, null]]);
/**
 * @hidden
 */
export class StackedAreaSeries extends HorizontalStackedSeriesBase {
    constructor() {
        super();
        this.ab = StackedAreaSeries.$;
    }
    ac() {
        super.ac();
        this.jc(false);
    }
    an(a) {
        if (this.itemsSource == null) {
            return null;
        }
        if (a == this.xAxis) {
            return new AxisRange(0, this.bz.count - 1);
        }
        if (a == this.yAxis) {
            this.pk();
            return new AxisRange(this.pb, this.pa);
        }
        return null;
    }
    preferredCategoryMode(a) {
        return 0;
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
StackedAreaSeries.$t = markType(StackedAreaSeries, 'StackedAreaSeries', HorizontalStackedSeriesBase.$);
/**
 * @hidden
 */
export class VerticalStackedSeriesBase extends StackedSeriesBase {
    m5() {
        return this.yAxis;
    }
    np() {
        return this.xAxis;
    }
    getOffsetValue() {
        return this.na.r(this.yAxis, this.bi.bs, this.bi.br, this.getEffectiveViewport1(this.bi));
    }
    getCategoryWidth() {
        return this.yAxis.getCategorySize(this.bi.bs, this.bi.br, this.getEffectiveViewport1(this.bi));
    }
    get_isVertical() {
        return true;
    }
    fetchXAxis() {
        return this.xAxis;
    }
    fetchYAxis() {
        return this.yAxis;
    }
    n0() {
        return this.xAxis != null && this.xAxis.ck();
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case VerticalStackedSeriesBase.$$p[0]:
                if (c != d) {
                    this.hz(typeCast(Axis.$, c));
                    this.i3(typeCast(Axis.$, d));
                    this.ne.cn.g(this.eu);
                    this.jc(false);
                    this.ij();
                }
                break;
            case VerticalStackedSeriesBase.$$p[1]:
                if (c != d) {
                    this.hz(typeCast(Axis.$, c));
                    this.i3(typeCast(Axis.$, d));
                    this.ne.cn.g(this.eu);
                    this.n0();
                    this.jc(false);
                    this.ij();
                }
                break;
        }
    }
    pw(a) {
        if (typeCast(CategoryYAxis.$, a) !== null) {
            return true;
        }
        return false;
    }
    pv(a) {
        if (typeCast(NumericXAxis.$, a) !== null) {
            return true;
        }
        return false;
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
VerticalStackedSeriesBase.$t = markType(VerticalStackedSeriesBase, 'VerticalStackedSeriesBase', StackedSeriesBase.$);
Type.dep(DependencyProperty, PropertyMetadata, VerticalStackedSeriesBase, 'raisePropertyChanged', ['XAxis::pz', [NumericXAxis.$, null], 'YAxis::p0', [CategoryYAxis.$, null]]);
/**
 * @hidden
 */
export class StackedBarSeries extends VerticalStackedSeriesBase {
    constructor() {
        super();
        this.ab = StackedBarSeries.$;
    }
    ac() {
        super.ac();
        this.jc(false);
    }
    bf() {
        return new StackedBarSeriesView(this);
    }
    it(a) {
        super.it(a);
        this.p1 = a;
    }
    getHostReferenceValue() {
        return this.eh();
    }
    ox() {
        return this.p1;
    }
    preferredCategoryMode(a) {
        return 2;
    }
    n8() {
        let a = 0;
        for (let b of fromEnum(this.bs.series)) {
            if (b == this) {
                return a;
            }
            let c = typeCast(IBarSeries_$type, b);
            if (c != null && c.yAxis == this.yAxis && c.getPreferredCategoryMode() == 2) {
                a++;
            }
        }
        return -1;
    }
    o8() {
        let a = 0;
        let b = this.bs != null ? this.bs.mq : Rect.empty;
        let c = this.bi.br;
        if (!b.isEmpty && !c.isEmpty && this.xAxis != null) {
            let d = this.getEffectiveViewport1(this.bi);
            let e = new ScalerParams(0, b, c, this.xAxis.b8, d);
            a = this.xAxis.dv(this.xAxis.kd, e);
        }
        return a;
    }
    o9() {
        if (this.xAxis != null) {
            return this.xAxis.kd;
        }
        return 0;
    }
    an(a) {
        if (this.itemsSource == null) {
            return null;
        }
        if (a == this.yAxis) {
            return new AxisRange(0, this.bz.count - 1);
        }
        if (a == this.xAxis) {
            this.pk();
            return new AxisRange(this.pb, this.pa);
        }
        return null;
    }
    c9(a) {
        let b = this.bz != null ? this.bz.indexOf(a) : -1;
        let c = this.bs != null ? this.bs.mq : Rect.empty;
        c = c.copy();
        let d = this.bi.br;
        let e = new Rect(0, 0, 0, 1, 1);
        let f = this.lr(this.bi);
        let g = new ScalerParams(0, e, e, this.xAxis.b8, f);
        let h = new ScalerParams(0, e, e, this.yAxis.b8, f);
        if (b >= 0 && Rect.l_op_Inequality(c, null) && Rect.l_op_Inequality(d, null)) {
            if (this.yAxis != null) {
                let i = this.yAxis.dv(b, h);
                if (i < c.top + 0.1 * c.height) {
                    i = i + 0.4 * c.height;
                }
                if (i > c.bottom - 0.1 * c.height) {
                    i = i - 0.4 * c.height;
                }
                c.y = i - 0.5 * c.height;
            }
            if (this.xAxis != null && this.ou != null && b < this.ou.length) {
                let j = this.xAxis.dv(this.ou[b], g);
                let k = this.xAxis.dv(this.ov[b], g);
                if (!isNaN_(j) && !isNaN_(k)) {
                    let l = Math.abs(k - j);
                    if (c.width < l) {
                        c.width = l;
                        c.x = Math.min(k, j);
                    }
                    else {
                        if (k < c.left + 0.1 * c.width) {
                            k = k + 0.4 * c.width;
                        }
                        if (k > c.right - 0.1 * c.width) {
                            k = k - 0.4 * c.width;
                        }
                        c.x = k - 0.5 * c.width;
                    }
                }
            }
            this.bn.ap(this.bs, c, true);
        }
        return b >= 0;
    }
    dw(a, b, c) {
        let d = true;
        let e = c;
        if (!c.l() || b.isEmpty || a.isEmpty || this.yAxis == null || this.yAxis.itemsSource == null || this.xAxis == null || this.bz == null || this.xAxis.bf == null || this.yAxis.bf == null || this.xAxis.j3 == this.xAxis.j2) {
            e.cn.d = 0;
            d = false;
        }
        return d;
    }
    hy(a, b, c, d) {
        switch (a) {
            case 4:
            case 1:
            case 0:
                this.ne.cn.g(this.eu);
                break;
        }
        switch (a) {
            case 4:
                if (this.xAxis != null && !this.xAxis.ck()) {
                    this.jc(true);
                }
                break;
            case 1:
                if (this.xAxis != null && !this.xAxis.ck()) {
                    this.jc(true);
                }
                break;
            case 0:
                if (this.xAxis != null && !this.xAxis.ck()) {
                    this.jc(true);
                }
                break;
            case 2:
                if (this.ne.cn.d > 0) {
                    this.jc(true);
                }
                break;
            case 3:
                if (this.xAxis != null && !this.xAxis.ck()) {
                    this.jc(true);
                }
                break;
        }
    }
    e8(a) {
        let b = this.bs != null ? this.bs.mq : Rect.empty;
        let c = this.bi.br;
        let d = this.getEffectiveViewport1(this.bi);
        let e = -1;
        if (this.yAxis != null && !b.isEmpty && !c.isEmpty) {
            let f = new ScalerParams(0, b, c, this.yAxis.b8, d);
            let g = this.lp(this.bi);
            let h = this.yAxis.dy(g.top, f);
            let i = this.yAxis.dy(g.bottom, f);
            let j = (a.y - b.top) / b.height;
            let k = h + (j * (i - h));
            if (this.yAxis.categoryMode != 0) {
                k -= 0.5;
            }
            let l = truncate(Math.round(k));
            e = l;
        }
        return e;
    }
    fp(a) {
        let b = this.e8(a);
        return b >= 0 && this.bz != null && b < this.bz.count ? this.bz.item(b) : null;
    }
    po() {
        if (this.xAxis != null) {
            this.xAxis.cl(true);
        }
        if (this.yAxis != null) {
            this.yAxis.cl(true);
        }
    }
    pc(a) {
        return this.e8(a);
    }
    o6(a, b, c, d) {
        let e = true;
        if (!d.l() || c.isEmpty || b.isEmpty || this.yAxis == null || this.yAxis.itemsSource == null || this.xAxis == null || this.bz == null || this.xAxis.bf == null || this.yAxis.bf == null) {
            e = false;
        }
        let f = d;
        if (a.valueColumn == null || a.valueColumn.count == 0 || f.cn.d < 1) {
            e = false;
        }
        return e;
    }
    eg() {
        return this.yAxis.jq(this.bi.bs, this.bi.br, this.getEffectiveViewport1(this.bi));
    }
    pl(a, b, c) {
        let d = typeCast(BarFragment.$, a);
        let e = typeCast(ColumnFragmentView.$, c);
        if (!this.dw(c.br, c.bs, c) || d == null || e == null) {
            return;
        }
        let f = this.yAxis.jq(c.bs, c.br, this.getEffectiveViewport1(c));
        if (isNaN_(f) || isInfinity(f)) {
            d.qp.c7.count = 0;
            return;
        }
        let g = 0;
        for (let h of fromEnum(b.f)) {
            if (isInfinity(h[0]) || isNaN_(h[0]) || isInfinity(h[1]) || isInfinity(h[2]) || isNaN_(h[1]) || isNaN_(h[2])) {
                continue;
            }
            let i = h[0] - 0.5 * f;
            let j = h[1];
            let k = h[2];
            k = Math.max(k, -100);
            j = Math.min(j, c.br.right + 100);
            let l = e.c7.item(g);
            l.height = f;
            l.width = Math.abs(j - k);
            e.de(l, Math.min(j, k), i);
            g++;
        }
        e.c7.count = g;
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case StackedBarSeries.$$p[0]:
            case StackedBarSeries.$$p[1]:
                for (let e of fromEnum(this.oy)) {
                    e.de();
                    e.df();
                }
                this.jc(false);
                break;
            case "SyncLink":
                if (this.xAxis != null) {
                    this.xAxis.ck();
                }
                break;
            case "FastItemsSource":
                if (this.xAxis != null && !this.xAxis.ck()) {
                    this.p1.cn.g(this.eu);
                }
                this.jc(false);
                break;
            case "SeriesViewer":
                if (c != null && d == null) {
                    this.hz(this.xAxis);
                    this.hz(this.yAxis);
                }
                if (c == null && d != null) {
                    this.i3(this.xAxis);
                    this.i3(this.yAxis);
                }
                this.p1.cn.g(this.eu);
                this.jc(false);
                if (this.xAxis != null) {
                    this.xAxis.ck();
                }
                break;
        }
    }
    getPreferredCategoryMode() {
        return this.preferredCategoryMode(this.yAxis);
    }
    get currentCategoryMode() {
        return this.preferredCategoryMode(this.yAxis);
    }
    get scaler() {
        return this.yAxis;
    }
    get yScaler() {
        return this.xAxis;
    }
    get mayContainUnknowns() {
        return true;
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
StackedBarSeries.$t = markType(StackedBarSeries, 'StackedBarSeries', VerticalStackedSeriesBase.$, [IIsCategoryBased_$type, IBarSeries_$type]);
Type.dep(DependencyProperty, PropertyMetadata, StackedBarSeries, 'raisePropertyChanged', ['RadiusX:p2:p6', [1, 2], 'RadiusY:p3:p7', [1, 2]]);
/**
 * @hidden
 */
export class StackedColumnSeries extends HorizontalStackedSeriesBase {
    constructor() {
        super();
        this.ab = StackedColumnSeries.$;
    }
    bf() {
        return new StackedColumnSeriesView(this);
    }
    it(a) {
        super.it(a);
        this.p1 = a;
    }
    ox() {
        return this.p1;
    }
    preferredCategoryMode(a) {
        return 2;
    }
    an(a) {
        if (this.itemsSource == null) {
            return null;
        }
        if (a == this.xAxis) {
            return new AxisRange(0, this.bz.count - 1);
        }
        if (a == this.yAxis) {
            this.pk();
            return new AxisRange(this.pb, this.pa);
        }
        return null;
    }
    eg() {
        let a = this.getEffectiveViewport1(this.bi);
        return this.xAxis.jq(this.bi.bs, this.bi.br, a);
    }
    pl(a, b, c) {
        let d = typeCast(ColumnFragment.$, a);
        let e = typeCast(ColumnFragmentView.$, c);
        if (!this.dw(c.br, c.bs, c) || d == null || e == null) {
            return;
        }
        if (d == null) {
            return;
        }
        let f = this.getEffectiveViewport1(c);
        let g = this.xAxis.jq(c.bs, c.br, f);
        if (isNaN_(g) || isInfinity(g)) {
            d.qp.c7.count = 0;
            return;
        }
        let h = 0;
        for (let i of fromEnum(b.f)) {
            if (isInfinity(i[0]) || isNaN_(i[0]) || isInfinity(i[1]) || isInfinity(i[2]) || isNaN_(i[1]) || isNaN_(i[2])) {
                continue;
            }
            let j = i[0] - 0.5 * g;
            let k = i[1];
            let l = i[2];
            k = Math.max(k, -100);
            l = Math.min(l, c.br.bottom + 100);
            let m = e.c7.item(h);
            m.width = g;
            m.height = Math.abs(l - k);
            e.de(m, j, Math.min(l, k));
            h++;
        }
        e.c7.count = h;
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case StackedColumnSeries.$$p[0]:
            case StackedColumnSeries.$$p[1]:
                for (let e of fromEnum(this.oy)) {
                    e.de();
                    e.df();
                }
                this.jc(false);
                break;
            case "SyncLink":
                if (this.yAxis != null) {
                    this.yAxis.ck();
                }
                break;
            case "SeriesViewer":
                if (this.yAxis != null) {
                    this.yAxis.ck();
                }
                break;
        }
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
StackedColumnSeries.$t = markType(StackedColumnSeries, 'StackedColumnSeries', HorizontalStackedSeriesBase.$);
Type.dep(DependencyProperty, PropertyMetadata, StackedColumnSeries, 'raisePropertyChanged', ['RadiusX:p2:p6', [1, 2], 'RadiusY:p3:p7', [1, 2]]);
/**
 * @hidden
 */
export class StackedLineSeries extends HorizontalStackedSeriesBase {
    constructor() {
        super();
        this.ab = StackedLineSeries.$;
    }
    ac() {
        super.ac();
        this.jc(false);
    }
    an(a) {
        if (this.itemsSource == null) {
            return null;
        }
        if (a == this.xAxis) {
            return new AxisRange(0, this.bz.count - 1);
        }
        if (a == this.yAxis) {
            this.pk();
            return new AxisRange(this.pb, this.pa);
        }
        return null;
    }
    preferredCategoryMode(a) {
        return 0;
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
StackedLineSeries.$t = markType(StackedLineSeries, 'StackedLineSeries', HorizontalStackedSeriesBase.$);
/**
 * @hidden
 */
export class StackedSplineAreaSeries extends HorizontalStackedSeriesBase {
    constructor() {
        super();
        this.ab = StackedSplineAreaSeries.$;
    }
    ac() {
        super.ac();
        this.jc(false);
    }
    an(a) {
        if (this.itemsSource == null) {
            return null;
        }
        if (a == this.xAxis) {
            return new AxisRange(0, this.bz.count - 1);
        }
        if (a == this.yAxis) {
            this.pk();
            return new AxisRange(this.pb, this.pa);
        }
        return null;
    }
    preferredCategoryMode(a) {
        return 0;
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
StackedSplineAreaSeries.$t = markType(StackedSplineAreaSeries, 'StackedSplineAreaSeries', HorizontalStackedSeriesBase.$);
/**
 * @hidden
 */
export class StackedSplineSeries extends HorizontalStackedSeriesBase {
    constructor() {
        super();
        this.ab = StackedSplineSeries.$;
    }
    ac() {
        super.ac();
        this.jc(false);
    }
    an(a) {
        if (this.itemsSource == null) {
            return null;
        }
        if (a == this.xAxis) {
            return new AxisRange(0, this.bz.count - 1);
        }
        if (a == this.yAxis) {
            this.pk();
            return new AxisRange(this.pb, this.pa);
        }
        return null;
    }
    preferredCategoryMode(a) {
        return 0;
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
StackedSplineSeries.$t = markType(StackedSplineSeries, 'StackedSplineSeries', HorizontalStackedSeriesBase.$);
/**
 * @hidden
 */
export class StackedFragmentSeries extends DependencyObject {
    constructor() {
        super();
        this.q = false;
        this.r = false;
        this._parentSeries = null;
        this.av = 0;
        this.o = null;
        this.p = null;
        this._visualSeriesLink = null;
        this.ac = null;
        this.ad = null;
        this.ab = null;
        this.y = false;
        this.au = null;
        this.propertyChanged = null;
        this.propertyUpdated = null;
        this.ac = new List$1(Number_$type, 0);
        this.ad = new List$1(Number_$type, 0);
        this.ab = new List$1(Array_$type, 0);
        this.propertyUpdated = delegateCombine(this.propertyUpdated, (a, b) => this.ct(a, b.propertyName, b.oldValue, b.newValue));
    }
    get parentSeries() {
        return this._parentSeries;
    }
    set parentSeries(a) {
        this._parentSeries = a;
    }
    get visualSeriesLink() {
        return this._visualSeriesLink;
    }
    set visualSeriesLink(a) {
        this._visualSeriesLink = a;
    }
    provideRenderer(a) {
        this.au = a;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.provideRenderer(a);
        }
    }
    dq() {
        if (this.parentSeries == null) {
            return;
        }
        this.gd = this.parentSeries._visibility != 0 ? 1 : this.gf;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink._visibility = this.gd;
        }
    }
    c9() {
        if (this.parentSeries == null) {
            return;
        }
        this.dt = this.dw != null ? this.dw : this.parentSeries.mj;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.mj = this.dt;
        }
    }
    da() {
        if (this.parentSeries == null) {
            return;
        }
        let a = this.l == 0 ? 1 : this.l;
        this.k = this.l == 0 ? this.parentSeries.l0 : a;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.l0 = this.k;
        }
    }
    cx() {
        if (this.parentSeries == null) {
            return;
        }
        this.fz = this.fu != null ? this.fu : this.parentSeries.k4;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.k4 = this.fz;
        }
    }
    cy() {
        if (this.parentSeries == null) {
            return;
        }
        this.f2 = this.f3 != null ? this.f3 : this.parentSeries.la;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.la = this.f2;
        }
    }
    cz() {
        if (this.parentSeries == null) {
            return;
        }
        this.f4 = this.f7;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.lb = this.f4;
        }
    }
    c1() {
        if (this.parentSeries == null) {
            return;
        }
        if (!this.q) {
            this.s = this.parentSeries.cp;
        }
        else {
            this.s = this.w;
        }
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.cp = this.s;
        }
    }
    dg() {
        if (this.parentSeries == null) {
            return;
        }
        this.ai = !isNaN_(this.aq) ? this.aq : this.parentSeries.ev;
        if (this.visualSeriesLink != null && !isNaN_(this.ai)) {
            this.visualSeriesLink.ev = this.ai;
        }
    }
    dh() {
        if (this.parentSeries == null) {
            return;
        }
        this.f0 = Color.e(Nullable$1.toNullable(Color.$, this.f1), Nullable$1.toNullable(Color.$, null)) ? this.f1 : this.parentSeries.k9;
        if (this.visualSeriesLink != null && Color.e(Nullable$1.toNullable(Color.$, this.f0), Nullable$1.toNullable(Color.$, null))) {
            this.visualSeriesLink.k9 = this.f0;
        }
    }
    dp() {
        if (this.parentSeries == null) {
            return;
        }
        if (!this.r) {
            this.v = this.parentSeries.du;
        }
        else {
            this.v = this.aa;
        }
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.du = this.v;
        }
    }
    di() {
        if (this.parentSeries == null) {
            return;
        }
        this.aj = !isNaN_(this.ar) ? this.ar : this.parentSeries.ew;
        if (this.visualSeriesLink != null && !isNaN_(this.aj)) {
            this.visualSeriesLink.ew = this.aj;
        }
    }
    dj() {
        if (this.parentSeries == null) {
            return;
        }
        this.ak = !isNaN_(this.as) ? this.as : this.parentSeries.ex;
        if (this.visualSeriesLink != null && !isNaN_(this.ak)) {
            this.visualSeriesLink.ex = this.ak;
        }
    }
    c0() {
        if (this.parentSeries == null) {
            return;
        }
        this.f5 = this.f8;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.lc = this.f5;
        }
    }
    c2() {
        if (this.parentSeries == null) {
            return;
        }
        this.t = this.x;
    }
    c3() {
        if (this.parentSeries == null) {
            return;
        }
        this.dr = this.du != null ? this.du : this.parentSeries.legendItemBadgeTemplate;
        if (this.visualSeriesLink != null) {
            if (this.dr != null) {
                this.visualSeriesLink.legendItemBadgeTemplate = this.dr;
            }
            else {
                this.visualSeriesLink.legendItemBadgeTemplate = null;
            }
        }
    }
    c4() {
        if (this.parentSeries == null) {
            return;
        }
        this.ds = this.dv != null ? this.dv : this.parentSeries.legendItemTemplate;
        if (this.visualSeriesLink != null) {
            if (this.ds != null) {
                this.visualSeriesLink.legendItemTemplate = this.ds;
            }
            else {
                this.visualSeriesLink.legendItemTemplate = null;
            }
        }
    }
    c5() {
        if (this.parentSeries == null) {
            return;
        }
        this.gc = this.parentSeries.ly != 0 ? 1 : this.ge;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.ly = this.gc;
        }
    }
    c6() {
        if (this.parentSeries == null) {
            return;
        }
        this.fq = this.fv != null ? this.fv : this.parentSeries.mw;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.mw = this.fq;
        }
    }
    c7() {
        if (this.parentSeries == null) {
            return;
        }
        this.fr = this.fw != null ? this.fw : this.parentSeries.mx;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.mx = this.fr;
        }
    }
    c8() {
        if (this.parentSeries == null) {
            return;
        }
        this.ga = this.gb != null ? this.gb : this.parentSeries.my;
        if (this.visualSeriesLink != null) {
            if (this.ga != null) {
                this.visualSeriesLink.my = this.ga;
            }
            else {
                this.visualSeriesLink.my = null;
            }
        }
    }
    db() {
        if (this.parentSeries == null) {
            return;
        }
        this.af = !isNaN_(this.an) ? this.an : this.parentSeries._opacity;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink._opacity = this.af;
        }
    }
    dc() {
    }
    dd() {
        if (this.parentSeries == null) {
            return;
        }
        this.ft = this.fy != null ? this.fy : this.parentSeries.k7;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.k7 = this.ft;
        }
    }
    cw() {
        if (this.parentSeries == null) {
            return;
        }
        let a = NaN;
        if (typeCast(StackedAreaSeries.$, this.parentSeries) !== null) {
            a = this.parentSeries.d6;
        }
        if (typeCast(StackedSplineAreaSeries.$, this.parentSeries) !== null) {
            a = this.parentSeries.d6;
        }
        this.ae = !isNaN_(this.am) ? this.am : a;
        if (this.visualSeriesLink != null) {
            if (typeCast(AreaFragment.$, this.visualSeriesLink) !== null) {
                this.visualSeriesLink.d7 = this.ae;
            }
            if (typeCast(SplineAreaFragment.$, this.visualSeriesLink) !== null) {
                this.visualSeriesLink.d7 = this.ae;
            }
        }
    }
    de() {
        if (this.parentSeries == null) {
            return;
        }
        let a = NaN;
        if (typeCast(StackedColumnSeries.$, this.parentSeries) !== null) {
            a = this.parentSeries.p2;
        }
        if (typeCast(StackedBarSeries.$, this.parentSeries) !== null) {
            a = this.parentSeries.p2;
        }
        this.ag = !isNaN_(a) ? a : this.ao;
        if (this.visualSeriesLink != null) {
            if (typeCast(ColumnFragment.$, this.visualSeriesLink) !== null) {
                this.visualSeriesLink.qs = this.ag;
            }
            if (typeCast(BarFragment.$, this.visualSeriesLink) !== null) {
                this.visualSeriesLink.qs = this.ag;
            }
        }
    }
    df() {
        if (this.parentSeries == null) {
            return;
        }
        let a = NaN;
        if (typeCast(StackedColumnSeries.$, this.parentSeries) !== null) {
            a = this.parentSeries.p3;
        }
        if (typeCast(StackedBarSeries.$, this.parentSeries) !== null) {
            a = this.parentSeries.p3;
        }
        this.ah = !isNaN_(a) ? a : this.ap;
        if (this.visualSeriesLink != null) {
            if (typeCast(ColumnFragment.$, this.visualSeriesLink) !== null) {
                this.visualSeriesLink.qt = this.ah;
            }
            if (typeCast(BarFragment.$, this.visualSeriesLink) !== null) {
                this.visualSeriesLink.qt = this.ah;
            }
        }
    }
    dk() {
        if (this.parentSeries == null) {
            return;
        }
        this.f6 = this.f9;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.ld = this.f6;
        }
    }
    dl() {
        if (this.parentSeries == null) {
            return;
        }
        this.al = !isNaN_(this.at) ? this.at : this.parentSeries.ey;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.ey = this.al;
        }
    }
    dm() {
        if (this.parentSeries == null) {
            return;
        }
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.toolTip = this.ay;
        }
    }
    dn() {
        if (this.parentSeries == null) {
            return;
        }
        this.u = this.z;
        if (this.visualSeriesLink != null) {
            this.visualSeriesLink.l4 = this.u;
        }
    }
    cv(a, b, c) {
        if (this.propertyChanged != null) {
            this.propertyChanged(this, new PropertyChangedEventArgs(a));
        }
        if (this.propertyUpdated != null) {
            this.propertyUpdated(this, new PropertyUpdatedEventArgs(a, b, c));
        }
    }
    ct(a, b, c, d) {
        if (this.parentSeries == null) {
            return;
        }
        switch (b) {
            case StackedFragmentSeries.$$p[58]:
                if (this.parentSeries == null || this.visualSeriesLink == null) {
                    return;
                }
                this.visualSeriesLink.fx = d;
                break;
            case StackedFragmentSeries.$$p[63]:
                this.dq();
                break;
            case StackedFragmentSeries.$$p[31]:
                this.cx();
                break;
            case StackedFragmentSeries.$$p[32]:
                this.cy();
                break;
            case StackedFragmentSeries.$$p[33]:
                this.cz();
                break;
            case StackedFragmentSeries.$$p[35]:
                this.q = true;
                this.c1();
                break;
            case StackedFragmentSeries.$$p[52]:
                this.dg();
                break;
            case StackedFragmentSeries.$$p[53]:
                this.dh();
                break;
            case StackedFragmentSeries.$$p[61]:
                this.q = true;
                this.dp();
                break;
            case StackedFragmentSeries.$$p[54]:
                this.di();
                break;
            case StackedFragmentSeries.$$p[55]:
                this.dj();
                break;
            case StackedFragmentSeries.$$p[34]:
                this.c0();
                break;
            case StackedFragmentSeries.$$p[36]:
                this.c2();
                break;
            case StackedFragmentSeries.$$p[43]:
                this.c9();
                break;
            case StackedFragmentSeries.$$p[44]:
                this.da();
                break;
            case StackedFragmentSeries.$$p[37]:
                this.c3();
                break;
            case StackedFragmentSeries.$$p[38]:
                this.c4();
                break;
            case StackedFragmentSeries.$$p[39]:
                this.c5();
                break;
            case StackedFragmentSeries.$$p[40]:
                this.c6();
                break;
            case StackedFragmentSeries.$$p[41]:
                this.c7();
                break;
            case StackedFragmentSeries.$$p[42]:
                this.c8();
                break;
            case StackedFragmentSeries.$$p[47]:
                this.db();
                break;
            case StackedFragmentSeries.$$p[46]:
                this.dc();
                break;
            case StackedFragmentSeries.$$p[48]:
                this.dd();
                break;
            case StackedFragmentSeries.$$p[30]:
                this.cw();
                break;
            case StackedFragmentSeries.$$p[50]:
                this.de();
                break;
            case StackedFragmentSeries.$$p[51]:
                this.df();
                break;
            case StackedFragmentSeries.$$p[56]:
                this.dk();
                break;
            case StackedFragmentSeries.$$p[57]:
                this.dl();
                break;
            case StackedFragmentSeries.$$p[59]:
                this.dm();
                break;
            case StackedFragmentSeries.$$p[60]:
                this.dn();
                break;
        }
        this.parentSeries.jc(false);
    }
}
StackedFragmentSeries.$t = markType(StackedFragmentSeries, 'StackedFragmentSeries', DependencyObject.$, [INotifyPropertyChanged_$type]);
Type.dep(DependencyProperty, PropertyMetadata, StackedFragmentSeries, 'cv', ['ActualAreaFillOpacity:ae:dx', [1, 1], 'ActualBrush:fp:dy', [Brush.$], 'ActualDashArray:f2:dz', [DoubleCollection.$], 'ActualDashCap:f4:d0', [PenLineCap_$type, enumGetBox(PenLineCap_$type, 0)], 'ActualEndCap:f5:d1', [PenLineCap_$type, enumGetBox(PenLineCap_$type, 2)], 'ActualIsDropShadowEnabled:s:d2', [0, false], 'ActualIsHitTestVisible:t:d3', [0, true], 'ActualLegendItemBadgeTemplate:dr:d4', [DataTemplate.$], 'ActualLegendItemTemplate:ds:d5', [DataTemplate.$], 'ActualLegendItemVisibility:gc:d6', [Visibility_$type, enumGetBox(Visibility_$type, 0)], 'ActualMarkerBrush:fq:d7', [Brush.$], 'ActualMarkerOutline:fr:d8', [Brush.$], 'ActualMarkerStyle:ga:d9', [Style.$], 'ActualMarkerTemplate:dt:ea', [DataTemplate.$], 'ActualMarkerType:k:eb', [MarkerType_$type, enumGetBox(MarkerType_$type, 1)], 'ActualOpacityMask:fs:ec', [Brush.$], 'ActualOpacity:af:ed', [1, 1], 'ActualOutline:ft:ee', [Brush.$], 'ActualRadiusX:ag:ef', [1, 0], 'ActualRadiusY:ah:eg', [1, 0], 'ActualShadowBlur:ai:eh', [1, NaN], 'ActualShadowColor:f0:ei', [Color.$], 'ActualShadowOffsetX:aj:ej', [1, NaN], 'ActualShadowOffsetY:ak:ek', [1, NaN], 'ActualStartCap:f6:el', [PenLineCap_$type, enumGetBox(PenLineCap_$type, 2)], 'ActualThickness:al:em', [1, 1], 'ActualToolTip:aw:en', [4], 'ActualUseLightweightMarkers:u:eo', [0, false], 'ActualUseSingleShadow:v:ep', [0, true], 'ActualVisibility:gd:eq', [Visibility_$type, enumGetBox(Visibility_$type, 0)], 'AreaFillOpacity:am:er', [1, NaN], 'Brush:fu:es', [Brush.$], 'DashArray:f3:et', [DoubleCollection.$], 'DashCap:f7:eu', [PenLineCap_$type, enumGetBox(PenLineCap_$type, 0)], 'EndCap:f8:ev', [PenLineCap_$type, enumGetBox(PenLineCap_$type, 2)], 'IsDropShadowEnabled:w:ew', [0], 'IsHitTestVisible:x:ex', [0, true], 'LegendItemBadgeTemplate:du:ey', [DataTemplate.$, null], 'LegendItemTemplate:dv:ez', [DataTemplate.$, null], 'LegendItemVisibility:ge:e0', [Visibility_$type, enumGetBox(Visibility_$type, 0)], 'MarkerBrush:fv:e1', [Brush.$], 'MarkerOutline:fw:e2', [Brush.$], 'MarkerStyle:gb:e3', [Style.$], 'MarkerTemplate:dw:e4', [DataTemplate.$, null], 'MarkerType:l:e5', [MarkerType_$type, enumGetBox(MarkerType_$type, 0)], 'Name:b8:e6', [2], 'OpacityMask:fx:e7', [Brush.$], 'Opacity:an:e8', [1, 1], 'Outline:fy:e9', [Brush.$, null], 'ParentOrLocalBrush:fz:fa', [Brush.$], 'RadiusX:ao:fb', [1, 2], 'RadiusY:ap:fc', [1, 2], 'ShadowBlur:aq:fd', [1, NaN], 'ShadowColor:f1:fe', [Color.$], 'ShadowOffsetX:ar:ff', [1, NaN], 'ShadowOffsetY:as:fg', [1, NaN], 'StartCap:f9:fh', [PenLineCap_$type, enumGetBox(PenLineCap_$type, 2)], 'Thickness:at:fi', [1, 1.5], 'Title:ax:fj', [4, "Series Title"], 'ToolTip:ay:fk', [4, null], 'UseLightweightMarkers:z:fl', [0, false], 'UseSingleShadow:aa:fm', [0], 'ValueMemberPath:cq:fn', [2, null], 'Visibility:gf:fo', [Visibility_$type, enumGetBox(Visibility_$type, 0)]]);
/**
 * @hidden
 */
export class StackedSeriesCollection extends ObservableCollection$1 {
    constructor() {
        super(StackedFragmentSeries.$, 0);
        this.collectionResetting = null;
    }
    p() {
        if (this.collectionResetting != null) {
            this.collectionResetting(this, null);
        }
        super.p();
    }
}
StackedSeriesCollection.$t = markType(StackedSeriesCollection, 'StackedSeriesCollection', ObservableCollection$1.$.specialize(StackedFragmentSeries.$));
/**
 * @hidden
 */
export class StackedSeriesFramePreparer extends CategoryFramePreparer {
    constructor(a, ..._rest) {
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    let c = _rest[0];
                    super(0, c);
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    let g = _rest[4];
                    super(1, c, d, e, f, g);
                }
                break;
        }
    }
    j(a) {
        let b = new SingleValuesHolder();
        if (typeCast(StackedColumnSeries.$, this.h) !== null || typeCast(StackedBarSeries.$, this.h) !== null) {
            let c = typeCast(StackedSeriesBase.$, this.h);
            if (c.oy.count > 0) {
                b.f = c.oy._inner[0].p;
            }
            return b;
        }
        let d = this.ab.valueColumn;
        b.f = d;
        return b;
    }
    t(a, b, c, d, e) {
        let f = 0;
        let g = false;
        let h;
        let i = a.d != null;
        let j = this.h.provideCollisionDetector();
        let k = a.f;
        let l = a.k;
        let m = this.h.mayContainUnknowns;
        let n = new ScalerParams(0, a.m, a.l, a.b.j$a, l);
        let o = new ScalerParams(0, a.m, a.l, a.c.j$a, l);
        o.b = this.h.getHostReferenceValue();
        let p = (a.b.j$c(2, n) - a.b.j$c(1, n));
        let q = a.m;
        let r = a.l;
        let s = typeCast(NumericAxisBase.$, a.c) !== null && a.c.jt;
        for (let t = a.i; t <= a.j; ++t) {
            let u;
            if (a.d == null) {
                if (!m) {
                    u = this.g.getBucketWithoutUnknowns(t);
                }
                else {
                    u = this.g.getBucket(t);
                }
            }
            else {
                u = ((() => { let v = this.f(a, t, b, p, g, h, c); t = v.p1; g = v.p4; h = v.p5; return v.ret; })());
            }
            let v = !s || (s && u[1] > 0);
            let w = u[0];
            if (!isNaN_(u[0])) {
                this.x(a, u, c, i, n, o);
                a.a.f.add(u);
                let x = t * a.h;
                let y = x;
                if (a.d != null && a.d.i$b != null && x >= 0 && x < a.d.i$b.count) {
                    x = a.d.i$b._inner[x];
                }
                let z = u;
                if (k && x < b.e) {
                    z = new Array(u.length);
                    z[0] = w;
                    this.z(b, x, true, a.e);
                    z[1] = b.c;
                    z[2] = b.d;
                    this.x(a, z, c, i, n, o);
                }
                if (d && v && this.l(a.a, z, j, Math.min(x, b.e - 1), f, a.a.f.count - 1)) {
                    ++f;
                }
            }
        }
        return f;
    }
    l(a, b, c, d, e, f) {
        let g = b[0];
        let h = b[1];
        if (typeCast(IBarSeries_$type, this.c) !== null) {
            h = b[0];
            g = b[1];
        }
        let i = new Rect(0, g - 5, h - 5, 11, 11);
        if (!isNaN_(g) && !isNaN_(h) && !isInfinity(g) && !isInfinity(h) && c.tryAdd(i)) {
            a.m.add({ $type: Point_$type, x: g, y: h });
            this.c.updateMarkerTemplate(e, d, f);
            return true;
        }
        return false;
    }
}
StackedSeriesFramePreparer.$t = markType(StackedSeriesFramePreparer, 'StackedSeriesFramePreparer', CategoryFramePreparer.$);
/**
 * @hidden
 */
export class AreaFragmentView extends AnchoredCategorySeriesView {
    constructor(a) {
        super(a);
        this.c6 = null;
        this.c8 = new Path();
        this.da = new Path();
        this.c9 = new Path();
        this.db = new Path();
        this.c6 = a;
    }
    ap() {
        super.ap();
        if (!this.n) {
            this.e.bj = 1;
        }
    }
    c7() {
        this.c8.aj = null;
        this.c9.aj = null;
        this.da.aj = null;
        this.db.aj = null;
    }
    co() {
        return new AreaFragmentBucketCalculator(this);
    }
    a8() {
        super.a8();
        this.c8._fill = this.e.k2;
        this.c9._fill = this.e.k2;
        this.c8._opacity = this.e.d6;
        this.c9._opacity = 0.5 * this.e.d6;
        this.da._stroke = this.e.k3;
        this.da.ac = this.e.ey;
        this.da.ai = this.e.la;
        this.da.ad = this.e.lb;
        this.db._stroke = this.e.k3;
        this.db.ac = this.e.ey;
        this.db.ai = this.e.la;
        this.db.ad = this.e.lb;
    }
    a9() {
        super.a9();
        let a = this.bl();
        this.c8._fill = a;
        this.c9._fill = a;
        this.c8._opacity = 1;
        this.c9._opacity = 1;
        this.da._stroke = a;
        this.da.ac = this.e.ey + 3;
        this.db._stroke = a;
        this.db.ac = this.e.ey + 3;
    }
    a3(a, b) {
        super.a3(a, b);
        a.s(this.c8);
        a.s(this.c9);
        a.s(this.da);
        a.s(this.db);
    }
    get_index() {
        let a = this.c6.parentSeries;
        let b = a.series.count;
        let c = a.series.indexOf(this.c6.logicalSeriesLink);
        let d = (b - 1) - c;
        let e = a.bi.index;
        return e + d;
    }
    ai(a) {
        super.ai(a);
        this.e.a2.exportPathData(a, this.da, "lowerShape", ["Lower"]);
        this.e.a2.exportPathData(a, this.db, "upperShape", ["Upper", "Main"]);
        this.e.a2.exportPathData(a, this.c9, "translucentShape", ["Translucent"]);
        this.e.a2.exportPathData(a, this.c8, "fillShape", ["Fill"]);
    }
}
AreaFragmentView.$t = markType(AreaFragmentView, 'AreaFragmentView', AnchoredCategorySeriesView.$);
/**
 * @hidden
 */
export class ColumnFragmentView extends AnchoredCategorySeriesView {
    constructor(a) {
        super(a);
        this.c6 = null;
        this.da = null;
        this.c7 = null;
        this.c8 = null;
        this.c9 = null;
        this.c6 = a;
        this.c8 = new List$1(Number_$type, 0);
        this.c9 = new List$1(Number_$type, 0);
        this.c7 = ((() => {
            let $ret = new Pool$1(Rectangle.$);
            $ret.create = runOn(this, this.df);
            $ret.activate = runOn(this, this.db);
            $ret.disactivate = runOn(this, this.dd);
            $ret.destroy = runOn(this, this.dc);
            return $ret;
        })());
        this.da = new List$1(Rectangle.$, 0);
    }
    ap() {
        super.ap();
        if (!this.n) {
            this.e.bj = 1;
        }
    }
    df() {
        let a = ((() => {
            let $ret = new Rectangle();
            $ret.dataContext = ((() => {
                let $ret = new DataContext();
                $ret.series = this.e;
                return $ret;
            })());
            return $ret;
        })());
        this.da.add(a);
        a._visibility = 1;
        return a;
    }
    db(a) {
        a._visibility = 0;
    }
    dd(a) {
        a._visibility = 1;
    }
    dc(a) {
        this.da.remove(a);
    }
    bb(a, b) {
        super.bb(a, b);
        let c = a;
        c._fill = this.e.k2;
        c._stroke = this.e.k3;
        c.ac = this.e.ey;
        c.ai = this.e.la;
        c.ad = this.e.lb;
        c.al = this.c6.qs;
        c.am = this.c6.qt;
    }
    de(a, b, c) {
        let d = false;
        if (a.o != c) {
            d = true;
            a.o = c;
        }
        if (a.n != b) {
            d = true;
            a.n = b;
        }
        if (d) {
            this.an();
        }
    }
    bc(a, b) {
        super.bc(a, b);
        let c = a;
        let d = this.bm(b);
        c._fill = d;
        c._stroke = d;
        c.ac = this.e.ey + 3;
    }
    a3(a, b) {
        super.a3(a, b);
        if (a.d) {
            for (let c = 0; c < this.da.count; c++) {
                let d = this.da._inner[c];
                this.ba(d, c, b);
                a.v(d);
            }
        }
    }
    get_index() {
        let a = this.c6.parentSeries;
        let b = a.series.count;
        let c = a.series.indexOf(this.c6.logicalSeriesLink);
        let d = (b - 1) - c;
        let e = a.bi.index;
        return e + d;
    }
    ai(a) {
        super.ai(a);
        let b = 0;
        let c = new List$1(Rectangle.$, 0);
        for (let d of fromEnum(this.c7.a)) {
            c.add(d);
        }
        c.aa((e, f) => {
            if (e.n < f.n) {
                return -1;
            }
            else if (e.n > f.n) {
                return 1;
            }
            else {
                return 0;
            }
        });
        for (let e of fromEnum(c)) {
            this.e.a2.exportRectangleData(a, e, "column" + b, ["Main", "Fill"]);
        }
        b++;
    }
    getDefaultTooltipTemplate() {
        let a = "<div class='ui-chart-default-tooltip-content'>";
        let b = null;
        if (this.c6.m5().b2) {
            b = this.c6.fragmentXAxis;
        }
        else if (this.c6.fragmentYAxis.b2) {
            b = this.c6.fragmentYAxis;
        }
        if (b.b5) {
            let c = b;
            a += "<span>${item." + c.dateTimeMemberPath + "}</span><br/>";
        }
        if (b != null && b.e6 != null) {
            a += "<span>${item." + b.e6 + "}</span><br/>";
        }
        a += "<span";
        let d = this.e.a0.a$q(this.e);
        if (!stringIsNullOrEmpty(d)) {
            a += " style='color:" + d + "'";
        }
        a += ">" + this.c6.fx + ": </span><span class='ui-priority-primary'>" + "${item." + this.c6.pc + "}</span></div>";
        return a;
    }
}
ColumnFragmentView.$t = markType(ColumnFragmentView, 'ColumnFragmentView', AnchoredCategorySeriesView.$);
/**
 * @hidden
 */
export class LineFragmentView extends AnchoredCategorySeriesView {
    constructor(a) {
        super(a);
        this.c6 = null;
        this.c9 = new Path();
        this.c8 = new Path();
        this.da = new Path();
        this.c6 = a;
    }
    c7() {
        this.c8.aj = null;
        this.c9.aj = null;
        this.da.aj = null;
    }
    co() {
        return new LineFragmentBucketCalculator(this);
    }
    a8() {
        super.a8();
        this.c9._stroke = this.e.k2;
        this.c9.ac = this.e.ey;
        this.c9.ai = this.e.la;
        this.c9.ad = this.e.lb;
        this.da._stroke = this.e.k2;
        this.da.ac = this.e.ey;
        this.da.ai = this.e.la;
        this.da.ad = this.e.lb;
        this.c8._fill = this.e.k2;
        this.c8._opacity = 0.75;
    }
    a9() {
        super.a9();
        let a = this.bl();
        this.c9._stroke = a;
        this.c9.ac = this.e.ey + 3;
        this.da._stroke = a;
        this.da.ac = this.e.ey + 3;
        this.c8._fill = a;
        this.c8._opacity = 1;
    }
    a3(a, b) {
        super.a3(a, b);
        if (a.d) {
            a.s(this.c8);
            a.s(this.c9);
            a.s(this.da);
        }
    }
    get_index() {
        let a = this.c6.parentSeries;
        let b = a.series.count;
        let c = a.series.indexOf(this.c6.logicalSeriesLink);
        let d = (b - 1) - c;
        let e = a.bi.index;
        return e + d;
    }
    ai(a) {
        super.ai(a);
        this.e.a2.exportPathData(a, this.c9, "lowerShape", ["Lower", "Main"]);
        this.e.a2.exportPathData(a, this.da, "upperShape", ["Upper"]);
        this.e.a2.exportPathData(a, this.c8, "translucentShape", ["Translucent"]);
    }
}
LineFragmentView.$t = markType(LineFragmentView, 'LineFragmentView', AnchoredCategorySeriesView.$);
/**
 * @hidden
 */
export class SplineAreaFragmentView extends SplineSeriesBaseView {
    constructor(a) {
        super(a);
        this.c7 = null;
        this.c9 = new Path();
        this.db = new Path();
        this.da = new Path();
        this.dc = new Path();
        this.c7 = a;
    }
    ap() {
        super.ap();
        if (!this.n) {
            this.e.bj = 1;
        }
    }
    c8() {
        this.c9.aj = null;
        this.da.aj = null;
        this.db.aj = null;
        this.dc.aj = null;
    }
    a8() {
        super.a8();
        this.c9._fill = this.e.k2;
        this.da._fill = this.e.k2;
        this.c9._opacity = this.e.d6;
        this.da._opacity = 0.5 * this.e.d6;
        this.db._stroke = this.e.k3;
        this.db.ac = this.e.ey;
        this.db.ai = this.e.la;
        this.db.ad = this.e.lb;
        this.dc._stroke = this.e.k3;
        this.dc.ac = this.e.ey;
        this.dc.ai = this.e.la;
        this.dc.ad = this.e.lb;
    }
    a9() {
        super.a9();
        let a = this.bl();
        this.c9._fill = a;
        this.da._fill = a;
        this.da._opacity = 1;
        this.c9._opacity = 1;
        this.db._stroke = a;
        this.db.ac = this.e.ey + 3;
        this.dc._stroke = a;
        this.dc.ac = this.e.ey + 3;
    }
    a3(a, b) {
        super.a3(a, b);
        if (a.d) {
            a.s(this.c9);
            a.s(this.da);
            a.s(this.db);
            a.s(this.dc);
        }
    }
    get_index() {
        let a = this.c7.parentSeries;
        let b = a.series.count;
        let c = a.series.indexOf(this.c7.logicalSeriesLink);
        let d = (b - 1) - c;
        let e = a.bi.index;
        return e + d;
    }
    ai(a) {
        super.ai(a);
        this.e.a2.exportPathData(a, this.db, "lowerShape", ["Lower"]);
        this.e.a2.exportPathData(a, this.dc, "upperShape", ["Upper", "Main"]);
        this.e.a2.exportPathData(a, this.da, "translucentShape", ["Translucent"]);
        this.e.a2.exportPathData(a, this.c9, "fillShape", ["Fill"]);
    }
}
SplineAreaFragmentView.$t = markType(SplineAreaFragmentView, 'SplineAreaFragmentView', SplineSeriesBaseView.$);
/**
 * @hidden
 */
export class SplineFragmentView extends SplineSeriesBaseView {
    constructor(a) {
        super(a);
        this.c7 = null;
        this.da = new Path();
        this.c9 = new Path();
        this.db = new Path();
        this.c7 = a;
    }
    co() {
        return new SplineFragmentBucketCalculator(this);
    }
    c8() {
        this.c9.aj = null;
        this.da.aj = null;
        this.db.aj = null;
    }
    a8() {
        super.a8();
        this.da._stroke = this.e.k2;
        this.da.ac = this.e.ey;
        this.da.ai = this.e.la;
        this.da.ad = this.e.lb;
        this.db._stroke = this.e.k2;
        this.db.ac = this.e.ey;
        this.db.ai = this.e.la;
        this.db.ad = this.e.lb;
        this.c9._fill = this.e.k2;
        this.c9._opacity = 0.75;
    }
    a9() {
        super.a9();
        let a = this.bl();
        this.da._stroke = a;
        this.da.ac = this.e.ey + 3;
        this.db._stroke = a;
        this.db.ac = this.e.ey + 3;
        this.c9._fill = a;
        this.c9._opacity = 0.75;
    }
    a3(a, b) {
        super.a3(a, b);
        if (a.d) {
            a.s(this.c9);
            a.s(this.da);
            a.s(this.db);
        }
    }
    get_index() {
        let a = this.c7.parentSeries;
        let b = a.series.count;
        let c = a.series.indexOf(this.c7.logicalSeriesLink);
        let d = (b - 1) - c;
        let e = a.bi.index;
        return e + d;
    }
    ai(a) {
        super.ai(a);
        this.e.a2.exportPathData(a, this.da, "lowerShape", ["Lower", "Main"]);
        this.e.a2.exportPathData(a, this.db, "upperShape", ["Upper"]);
        this.e.a2.exportPathData(a, this.c9, "translucentShape", ["Translucent"]);
    }
}
SplineFragmentView.$t = markType(SplineFragmentView, 'SplineFragmentView', SplineSeriesBaseView.$);
/**
 * @hidden
 */
export class StackedSeriesView extends CategorySeriesView {
    constructor(a) {
        super(a);
        this.cw = null;
        this.cx = new Canvas();
        this.cz = new Panel();
        this.cw = a;
    }
    get cy() {
        return this.cx;
    }
    get c0() {
        return this.cz;
    }
    co() {
        return new StackedBucketCalculator(this);
    }
    am() {
        super.am();
        for (let a = 0; a < this.cw.o2.f.count; a++) {
            this.cw.o2.f._inner[a].bi.am();
        }
    }
    ao(a, b) {
        super.ao(a, b);
        for (let c of fromEnum(this.cw.series)) {
            c.visualSeriesLink.bi.ao(a, b);
        }
    }
    ac() {
        let a = "rgba(95,95,95,0.5)";
        let b = true;
        let c = 5, d = 5, e = 5;
        let f = this.e;
        if (typeCast(StackedAreaSeries.$, f) !== null || typeCast(StackedSplineAreaSeries.$, f) !== null) {
            d = 1;
            e = -3;
        }
        else if (typeCast(StackedLineSeries.$, f) !== null || typeCast(StackedSplineSeries.$, f) !== null) {
            c = 3;
            d = 1;
            e = 4;
            b = false;
        }
        else if (typeCast(StackedColumnSeries.$, f) !== null) {
            d = 5;
            e = 0;
        }
        let g = new Color();
        g.colorString = a;
        f.k9 = g;
        f.ev = c;
        f.ew = d;
        f.ex = e;
        f.du = b;
    }
}
StackedSeriesView.$t = markType(StackedSeriesView, 'StackedSeriesView', CategorySeriesView.$);
/**
 * @hidden
 */
export class StackedBarSeriesView extends StackedSeriesView {
    constructor(a) {
        super(a);
        this.c1 = null;
        this.c1 = a;
    }
    co() {
        return new StackedBarBucketCalculator(this);
    }
}
StackedBarSeriesView.$t = markType(StackedBarSeriesView, 'StackedBarSeriesView', StackedSeriesView.$);
/**
 * @hidden
 */
export class StackedColumnSeriesView extends StackedSeriesView {
    constructor(a) {
        super(a);
    }
    co() {
        return new StackedColumnBucketCalculator(this);
    }
}
StackedColumnSeriesView.$t = markType(StackedColumnSeriesView, 'StackedColumnSeriesView', StackedSeriesView.$);
/**
 * @hidden
 */
export class StackedSeriesManager extends Base {
    constructor(a) {
        super();
        this.b = null;
        this.f = null;
        this.c = null;
        this.e = null;
        this.d = null;
        this.j = null;
        this.k = null;
        if (a == null) {
            return;
        }
        this.b = a;
        this.f = new ObservableCollection$1(AnchoredCategorySeries.$, 0);
        this.c = new StackedSeriesCollection();
        this.e = new ObservableCollection$1(AnchoredCategorySeries.$, 0);
        this.d = new ObservableCollection$1(AnchoredCategorySeries.$, 0);
        this.j = this.b.o3.cy;
        this.k = this.b.o3.c0;
        let b = this.c;
        b.collectionChanged = delegateCombine(b.collectionChanged, (b, c) => {
            if (c.oldItems != null) {
                for (let d of fromEn(c.oldItems)) {
                    if (this.f.contains(d.visualSeriesLink)) {
                        this.f.remove(d.visualSeriesLink);
                    }
                }
            }
            if (c.newItems != null) {
                let e = c.newStartingIndex;
                for (let f of fromEn(c.newItems)) {
                    let g = this.a(f);
                    this.f.insert(e, g);
                    e++;
                }
            }
        });
        let c = this.f;
        c.collectionChanged = delegateCombine(c.collectionChanged, (c, d) => {
            if (d.oldItems != null) {
                for (let e of fromEn(d.oldItems)) {
                    e.hv(true, e.bi);
                    e.bs = null;
                    e.bn = null;
                    e.itemsSource = null;
                    e.legend = null;
                    if (this.k != null && this.k.ab.contains(e)) {
                        this.k.ab.remove(e);
                    }
                    if (this.b.bs != null) {
                        this.b.bs.jx(e);
                    }
                }
            }
            if (d.newItems != null) {
                for (let f of fromEn(d.newItems)) {
                    f.bs = this.b.bs;
                    f.bn = this.b.bn;
                    if (!this.k.ab.contains(f)) {
                        this.k.ab.add(f);
                    }
                    if (this.b.bs != null) {
                        this.b.bs.hb(f);
                    }
                }
            }
            this.b.jc(false);
        });
    }
    a(a) {
        if (typeCast(StackedLineSeries.$, this.b) !== null) {
            let b = new LineFragment();
            b.provideRenderer(a.au);
            b.parentSeries = this.b;
            a.visualSeriesLink = b;
            b.logicalSeriesLink = a;
            b.bi.br = this.b.bi.br;
            this.i(b, a);
            this.g(b);
            return b;
        }
        if (typeCast(StackedColumnSeries.$, this.b) !== null) {
            let c = new ColumnFragment();
            c.provideRenderer(a.au);
            c.parentSeries = this.b;
            a.visualSeriesLink = c;
            c.logicalSeriesLink = a;
            c.bi.br = this.b.bi.br;
            this.i(c, a);
            this.g(c);
            return c;
        }
        if (typeCast(StackedBarSeries.$, this.b) !== null) {
            let d = new BarFragment();
            d.provideRenderer(a.au);
            d.parentSeries = typeCast(StackedBarSeries.$, this.b);
            a.visualSeriesLink = d;
            d.logicalSeriesLink = a;
            d.bi.br = this.b.bi.br;
            this.i(d, a);
            this.g(d);
            return d;
        }
        if (typeCast(StackedAreaSeries.$, this.b) !== null) {
            let e = new AreaFragment();
            e.provideRenderer(a.au);
            e.parentSeries = this.b;
            a.visualSeriesLink = e;
            e.logicalSeriesLink = a;
            e.bi.br = this.b.bi.br;
            this.i(e, a);
            this.g(e);
            return e;
        }
        if (typeCast(StackedSplineSeries.$, this.b) !== null) {
            let f = new SplineFragment();
            f.provideRenderer(a.au);
            f.parentSeries = this.b;
            a.visualSeriesLink = f;
            f.logicalSeriesLink = a;
            f.bi.br = this.b.bi.br;
            this.i(f, a);
            this.g(f);
            return f;
        }
        if (typeCast(StackedSplineAreaSeries.$, this.b) !== null) {
            let g = new SplineAreaFragment();
            g.provideRenderer(a.au);
            g.parentSeries = this.b;
            a.visualSeriesLink = g;
            g.logicalSeriesLink = a;
            g.bi.br = this.b.bi.br;
            this.i(g, a);
            this.g(g);
            return g;
        }
        return null;
    }
    i(a, b) {
        a.k4 = b.fz;
        a.la = b.f2;
        a.lb = b.f4;
        a.lc = b.f5;
        a.itemsSource = this.b.itemsSource;
        a.legend = this.b.aw;
        a.legendItemTemplate = b.ds;
        a.ly = b.gc;
        a.mw = b.fq;
        a.mx = b.fr;
        a.my = b.ga;
        a.mj = b.dt;
        a.l0 = b.k;
        a.es = this.b.es;
        a._opacity = b.an;
        a.k7 = b.ft;
        a.eu = this.b.eu;
        a.ld = b.f6;
        a.ey = b.al;
        a.fx = b.ax;
        a.l4 = b.u;
        a.pc = b.cq;
        a._visibility = b.gd;
        let c = typeCast(AreaFragment.$, a);
        if (c != null) {
            c.d6 = b.ae;
        }
        let d = typeCast(SplineAreaFragment.$, a);
        if (d != null) {
            d.d6 = b.ae;
        }
        let e = typeCast(ColumnFragment.$, a);
        if (e != null) {
            e.qs = b.ag;
            e.qt = b.ah;
        }
        let f = typeCast(BarFragment.$, a);
        if (f != null) {
            f.qs = b.ag;
            f.qt = b.ah;
        }
        a.toolTip = b.ay;
        a.cp = b.s;
        a.du = b.v;
        b.dg();
        b.dh();
        b.di();
        b.dj();
    }
    h() {
        this.e.clear();
        this.d.clear();
        let a = 0;
        for (let b of fromEnum(this.f)) {
            b.dl = true;
            b.fh = this.b.pd(this.c._inner[a]);
            b.bn = this.b.bn;
            b.bs = this.b.bs;
            if (this.c._inner[a].y) {
                this.e.add(b);
            }
            else {
                this.d.add(b);
            }
            if (typeCast(StackedLineSeries.$, this.b) !== null || typeCast(StackedAreaSeries.$, this.b) !== null || typeCast(StackedSplineSeries.$, this.b) !== null || typeCast(StackedSplineAreaSeries.$, this.b) !== null) {
                b.pf(this.b.fetchXAxis());
                b.pg(this.b.fetchYAxis());
            }
            b.jc(false);
            a++;
        }
    }
    g(a) {
        let fragment_ = a;
        fragment_.externalObject = TypeRegistrar.createFromInternal(fragment_, PlatformConstants.Prefix, PlatformConstants.Postfix);
        fragment_.externalObject._implementation = fragment_;
    }
}
StackedSeriesManager.$t = markType(StackedSeriesManager, 'StackedSeriesManager');
