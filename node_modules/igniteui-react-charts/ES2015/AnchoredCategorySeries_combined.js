/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { CategorySeries } from "./CategorySeries";
import { IIsCategoryBased_$type } from "./IIsCategoryBased";
import { IHasSingleValueCategory_$type } from "./IHasSingleValueCategory";
import { IHasCategoryTrendline_$type } from "./IHasCategoryTrendline";
import { ITrendLineSeries_$type } from "./ITrendLineSeries";
import { IAnchoredCategorySeriesInteractionManager_$type } from "./IAnchoredCategorySeriesInteractionManager";
import { DVContainer } from "igniteui-react-core/ES2015/DVContainer";
import { Type, enumGetBox, typeCast, Point_$type, markType } from "igniteui-react-core/ES2015/type";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { Series } from "./Series";
import { TrendLineType_$type } from "igniteui-react-core/ES2015/TrendLineType";
import { Brush } from "igniteui-react-core/ES2015/Brush";
import { PenLineCap_$type } from "igniteui-react-core/ES2015/PenLineCap";
import { DoubleCollection } from "igniteui-react-core/ES2015/DoubleCollection";
import { CategoryFrame } from "./CategoryFrame";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { ICategoryScaler_$type } from "./ICategoryScaler";
import { IScaler_$type } from "./IScaler";
import { CategorySeriesView } from "./CategorySeriesView";
import { CategorySeriesMarkerCollisionAvoidance_$type } from "./CategorySeriesMarkerCollisionAvoidance";
import { ConsolidatedItemHitTestBehavior_$type } from "./ConsolidatedItemHitTestBehavior";
import { CategoryFramePreparer } from "./CategoryFramePreparer";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { ISortingAxis_$type } from "./ISortingAxis";
import { IFastItemsSource_$type } from "igniteui-react-core/ES2015/IFastItemsSource";
import { NumericAxisBase } from "./NumericAxisBase";
import { CategoryBucketCalculator } from "./CategoryBucketCalculator";
import { AxisRange } from "./AxisRange";
import { NumericYAxis } from "./NumericYAxis";
import { ScalerParams } from "./ScalerParams";
import { CategoryMarkerManager } from "./CategoryMarkerManager";
import { CollisionAvoider } from "./CollisionAvoider";
import { NonCollisionAvoider } from "./NonCollisionAvoider";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { truncate, isNaN_ } from "igniteui-react-core/ES2015/number";
import { CategoryTrendLineManagerFactory } from "./CategoryTrendLineManagerFactory";
/**
 * @hidden
 */
export class AnchoredCategorySeries extends CategorySeries {
    constructor() {
        super();
        this.o1 = null;
        this.o5 = false;
        this.o3 = null;
        this.oy = null;
        this.o8 = null;
        this.na = new CategoryFramePreparer(1, this, this.ne, this, this, this.ne.cn);
    }
    get o2() {
        if (this.o1 == null) {
            this.o1 = DVContainer.instance.createInstance(IAnchoredCategorySeriesInteractionManager_$type, () => this.b2.n);
        }
        return this.o1;
    }
    getHostReferenceValue() {
        return this.eh();
    }
    bf() {
        let a = new AnchoredCategorySeriesView(this);
        return a;
    }
    it(a) {
        super.it(a);
        this.ox = a;
    }
    fs(a, b) {
        let c = this.gu(b);
        if (c == AnchoredCategorySeries.$$p[2]) {
            return this.ft(a, b, this.pc);
        }
        return super.fs(a, b);
    }
    get valueColumn() {
        return this.o3;
    }
    set valueColumn(a) {
        if (this.o3 != a) {
            let b = this.o3;
            this.o3 = a;
            if (!this.o5) {
                this.raisePropertyChanged("ValueColumn", b, this.o3);
            }
        }
    }
    get pu() {
        return this.c(AnchoredCategorySeries.pj);
    }
    set pu(a) {
        this.h(AnchoredCategorySeries.pj, a);
    }
    c9(a) {
        let b = new Rect(0, 0, 0, 1, 1);
        let c = this.fetchXAxis();
        let d = this.fetchYAxis();
        let e = this.lr(this.bi);
        let f = c != null ? this.na.r(typeCast(ICategoryScaler_$type, c), b, b, e) : 0;
        return this.o2.c$a(this, this.valueColumn, c, d, f, a);
    }
    ou(a, b, c) {
        if (b < a || a < 0 || a > this.valueColumn.count || b < 0 || b > this.valueColumn.count || c == null) {
            return null;
        }
        let d = new Array((b - a) + 1);
        let e = c.cc;
        let f = null;
        if (e) {
            f = c.i$b;
        }
        for (let g = a; g <= b; g++) {
            let h = g;
            if (e) {
                h = f._inner[h];
            }
            d[g - a] = this.bz.item(g);
        }
        return d;
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        if (this.ox.cz && this.ox.cy.g$b(a, b, c, d)) {
            this.jc(false);
            this.ij();
        }
        switch (b) {
            case "FastItemsSource":
                if (typeCast(IFastItemsSource_$type, c) != null) {
                    c.deregisterColumn(this.valueColumn);
                    this.valueColumn = null;
                }
                if (typeCast(IFastItemsSource_$type, d) != null) {
                    this.valueColumn = this.bw(this.pc);
                }
                let e = typeCast(NumericAxisBase.$, this.fetchYAxis());
                if (e != null && !e.ck()) {
                    this.ox.cn.g(this.eu);
                    this.jc(false);
                }
                break;
            case AnchoredCategorySeries.$$p[2]:
                if (this.bz != null) {
                    this.bz.deregisterColumn(this.valueColumn);
                    this.valueColumn = this.bw(this.pc);
                }
                this.o8 = this.pc;
                break;
            case "ValueColumn":
                if (this.ox.cz) {
                    this.ox.cy.g$i();
                }
                let f = typeCast(NumericAxisBase.$, this.fetchYAxis());
                if (f != null && !f.ck()) {
                    this.ox.cn.g(this.eu);
                    this.jc(false);
                }
                this.pi();
                this.jp();
                break;
            case "TrendLineBrush":
                this.jn();
                break;
            case "ErrorBarSettings":
                this.jc(false);
                break;
            case "TrendLineType":
                this.ij();
                break;
            case AnchoredCategorySeries.$$p[1]:
                this.jc(false);
                break;
        }
    }
    an(a) {
        if (this.valueColumn == null || this.valueColumn.count == 0) {
            return null;
        }
        if (a == this.fetchXAxis()) {
            return new AxisRange(0, this.valueColumn.count - 1);
        }
        if (a == this.fetchYAxis()) {
            return new AxisRange(this.valueColumn.minimum, this.valueColumn.maximum);
        }
        return null;
    }
    hy(a, b, c, d) {
        switch (a) {
            case 4:
            case 1:
            case 0:
                this.ox.cn.g(this.eu);
                break;
        }
        if (this.ox.cz) {
            this.ox.cy.g$e(a, b, c, d);
        }
        this.pi();
        this.jp();
    }
    n5() {
        return this.o6(this.ne);
    }
    o6(a) {
        let b = 0;
        let c = a.bs;
        let d = a.br;
        let e = this.getEffectiveViewport1(a);
        let f = typeCast(NumericYAxis.$, this.fetchYAxis());
        if (!c.isEmpty && !d.isEmpty && f != null) {
            let g = new ScalerParams(0, c, d, f.b8, e);
            if (f.ce) {
                g.b = this.eh();
            }
            b = f.dv(f.kd, g);
        }
        return b;
    }
    ph(a, b, c) {
        let d = this.o6(c);
        if (a.count > 0) {
            let e = d;
            a.add({ $type: Point_$type, x: a._inner[a.count - 1].x, y: e });
            a.add({ $type: Point_$type, x: a._inner[0].x, y: e });
        }
    }
    ov(a, b, c, d) {
        return this.ow(a, b, c, d, false);
    }
    ow(a, b, c, d, e) {
        return CategorySeries.m0(a, b, c, d, e);
    }
    dw(a, b, c) {
        let d = super.dw(a, b, c);
        let e = c;
        if (this.valueColumn == null || this.valueColumn.count == 0 || e.cn.d < 1) {
            d = false;
        }
        return d;
    }
    hv(a, b) {
        super.hv(a, b);
        let c = b;
        c.ct();
        if (c.cz) {
            c.cy.g$d();
        }
    }
    ok(a, b) {
        super.ok(a, b);
        this.nb(b).d(a, b);
    }
    on(a, b) {
        super.on(a, b);
        let c = typeCast(AnchoredCategorySeriesView.$, b);
        c.b0 = true;
        if (c.cz) {
            c.cy.g$g(a.p);
        }
        if (this.l2()) {
            CategoryMarkerManager.b(this, a.m, b.cq, this.l4);
            this.oh(b, a);
            b.cj();
        }
        this.pe(a, b);
    }
    jb(a, b, c, d, e) {
        super.jb(a, b, c, d, e);
        let f = this.a0.a$h.item(d);
        let g = f;
        g.cn.g(this.eu);
        f.ay(c);
        if (this.cc(g)) {
            return;
        }
        if (this.oy == null) {
            this.oy = new CategoryFrame(3);
        }
        this.oy.u();
        this.ok(this.oy, g);
        this.on(this.oy, g);
    }
    pe(a, b) {
    }
    jn() {
        super.jn();
        if (this.fh < 0) {
            return;
        }
        this.ox.c3();
        if (this.trendLineBrush != null) {
            this.ox.c1();
        }
        else {
            this.ox.c0();
        }
    }
    fv(a, b) {
        if (this.ox.cz && a == this.ox.cy.g$j) {
            return null;
        }
        return super.fv(a, b);
    }
    get currentCategoryMode() {
        return this.preferredCategoryMode(typeCast(CategoryAxisBase.$, this.fetchXAxis()));
    }
    get scaler() {
        return typeCast(ICategoryScaler_$type, this.fetchXAxis());
    }
    get yScaler() {
        return typeCast(IScaler_$type, this.fetchYAxis());
    }
    get bucketizer() {
        return this.ox.cn;
    }
    get currentMode2Index() {
        return this.n8();
    }
    provideCollisionDetector() {
        if (this.oz == 1) {
            return new CollisionAvoider();
        }
        return NonCollisionAvoider.a;
    }
    get trendlinePreparer() {
        return this.ox.cz ? this.ox.cy : null;
    }
    h4(a) {
        super.h4(a);
        if (this.ox.cz) {
            this.a2.exportTrendlineData(this, a, this.ox.cy.g$j);
        }
    }
    fp(a) {
        let b = this.fetchXAxis();
        let c = this.fetchYAxis();
        return this.o2.c$b(this, a, this.n6(this.bi), this.valueColumn, b, c, this.o0 == 1, (d) => super.fp(d));
    }
    get mayContainUnknowns() {
        return this.valueColumn == null || this.valueColumn.mayContainUnknowns;
    }
    eh() {
        return Series.ei(this.valueColumn, typeCast(ISortingAxis_$type, this.fetchXAxis()));
    }
    ao() {
        if (this.valueColumn == null) {
            return null;
        }
        let a = this.m5();
        let b = new ScalerParams(0, this.bs.mq, this.bs.m3, a.b8, this.getEffectiveViewport());
        let c = (a.dy(this.bs.m3.left, b));
        let d = (a.dy(this.bs.m3.right, b));
        let e = null;
        if (a.cc) {
            e = a;
            c = e.i$f(c);
            d = e.i$f(d);
        }
        else {
            c = Math.floor(c);
            d = Math.ceil(d);
        }
        if (isNaN_(c) || isNaN_(d)) {
            return null;
        }
        c = Math.max(0, Math.min(this.valueColumn.count - 1, c));
        d = Math.max(0, Math.min(this.valueColumn.count - 1, d));
        let f = 1.7976931348623157E+308;
        let g = -1.7976931348623157E+308;
        for (let h = truncate(c); h <= truncate(d); h++) {
            let i = h;
            if (e != null) {
                i = e.i$b._inner[h];
            }
            f = Math.min(f, this.valueColumn.item(i));
            g = Math.max(g, this.valueColumn.item(i));
        }
        return new AxisRange(f, g);
    }
    pi() {
        this.d8 = this.valueColumn == null || this.valueColumn.count == 0 ? NaN : this.valueColumn.item(this.valueColumn.count - 1);
    }
    get useHighMarkerFidelity() {
        return this.n1;
    }
}
AnchoredCategorySeries.$t = markType(AnchoredCategorySeries, 'AnchoredCategorySeries', CategorySeries.$, [IIsCategoryBased_$type, IHasSingleValueCategory_$type, IHasCategoryTrendline_$type, ITrendLineSeries_$type]);
AnchoredCategorySeries.pj = DependencyProperty.i("ActualTrendLineBrush", Brush.$, AnchoredCategorySeries.$, new PropertyMetadata(2, null, (a, b) => a.raisePropertyChanged("ActualTrendLineBrush", b.oldValue, b.newValue)));
Type.dep(DependencyProperty, PropertyMetadata, AnchoredCategorySeries, 'raisePropertyChanged', ['ConsolidatedItemHitTestBehavior:o0:pk', [ConsolidatedItemHitTestBehavior_$type, enumGetBox(ConsolidatedItemHitTestBehavior_$type, 0)], 'MarkerCollisionAvoidance:oz:pl', [CategorySeriesMarkerCollisionAvoidance_$type, enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, 1)], 'ValueMemberPath:pc:pt', [2, null], 'TrendLineType::pr', [TrendLineType_$type, enumGetBox(TrendLineType_$type, 0)], 'TrendLineThickness::pq', [1, 1.5], 'TrendLinePeriod::pp', [1, 7], 'TrendLineBrush::pm', [Brush.$, null], 'TrendLineZIndex:o7:ps', [1, 1001], 'TrendLineDashArray:pv:pn', [DoubleCollection.$], 'TrendLineDashCap:pw:po', [PenLineCap_$type, enumGetBox(PenLineCap_$type, 0)]]);
/**
 * @hidden
 */
export class AnchoredCategoryBucketCalculator extends CategoryBucketCalculator {
    constructor(a) {
        super(a);
        this.i = null;
        this.h = null;
        this.j = 0;
        this.i = a;
    }
    getBucketWithoutUnknowns(a) {
        let b = this.h;
        let c = this.j;
        let d = a * this.d;
        let e = d + this.d - 1;
        let f = c - 1;
        d = d < f ? d : f;
        e = e < f ? e : f;
        let g = 1.7976931348623157E+308;
        let h = -1.7976931348623157E+308;
        let i = true;
        for (let j = d; j <= e; ++j) {
            let k = b[j];
            g = g < k ? g : k;
            h = h > k ? h : k;
            i = false;
        }
        if (!i) {
            return [0.5 * (d + e), g, h];
        }
        return [0.5 * (d + e), NaN, NaN];
    }
    getBucket(a) {
        let b = this.h;
        let c = this.j;
        let d = a * this.d;
        let e = d + this.d - 1;
        let f = c - 1;
        d = d < f ? d : f;
        e = e < f ? e : f;
        let g = 0;
        let h = 0;
        let i = true;
        for (let j = d; j <= e; ++j) {
            let k = b[j];
            if (!i) {
                if (!isNaN_(k)) {
                    g = g < k ? g : k;
                    h = h > k ? h : k;
                }
            }
            else {
                if (!isNaN_(k)) {
                    g = k;
                    h = k;
                    i = false;
                }
            }
        }
        if (!i) {
            return [0.5 * (d + e), g, h];
        }
        return [0.5 * (d + e), NaN, NaN];
    }
    cacheValues() {
        this.j = this.i.cw.valueColumn.count;
        this.h = this.i.cw.valueColumn.asArray();
    }
    unCacheValues() {
        this.h = null;
    }
}
AnchoredCategoryBucketCalculator.$t = markType(AnchoredCategoryBucketCalculator, 'AnchoredCategoryBucketCalculator', CategoryBucketCalculator.$);
/**
 * @hidden
 */
export class AnchoredCategorySeriesView extends CategorySeriesView {
    constructor(a) {
        super(a);
        this.cw = null;
        this.cx = null;
        this.cw = a;
    }
    get cy() {
        if (this.cx == null) {
            this.cx = CategoryTrendLineManagerFactory.a(this.cx, this.e.ap(), this.e.jw, this.e, this.e.b2);
        }
        return this.cx;
    }
    set cy(a) {
        this.cx = a;
    }
    get cz() {
        return this.cx != null;
    }
    c3() {
        this.cw.pu = null;
    }
    c1() {
        this.cw.pu = this.cw.trendLineBrush;
    }
    c0() {
        this.cw.pu = this.cw.k2;
    }
    co() {
        return new AnchoredCategoryBucketCalculator(this);
    }
    c2() {
        this.cn.cacheValues();
    }
    c4() {
        this.cn.unCacheValues();
    }
    c5(a) {
        let b = this.cq.item(a);
        return this.cm(b);
    }
    a2(a, b) {
        if (a.d) {
            if (this.cw.trendLineType != 0 && !b) {
                let c = this.cy.g$j;
                c.ac = this.cw.trendLineThickness;
                c._stroke = this.cw.pu;
                c.ai = this.cw.pv;
                c.ad = this.cw.pw;
                a.u(c);
            }
        }
        super.a2(a, b);
    }
    getDefaultTooltipTemplate() {
        return this.cw.o2.c$c(this.e, this.cw.pc);
    }
}
AnchoredCategorySeriesView.$t = markType(AnchoredCategorySeriesView, 'AnchoredCategorySeriesView', CategorySeriesView.$);
