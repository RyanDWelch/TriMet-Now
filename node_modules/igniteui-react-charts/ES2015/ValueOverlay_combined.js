/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Series } from "./Series";
import { IHasCategoryModePreference_$type } from "./IHasCategoryModePreference";
import { Axis } from "./Axis";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { Type, Point_$type, typeCast, Delegate_$type, markType } from "igniteui-react-core/ES2015/type";
import { Brush } from "igniteui-react-core/ES2015/Brush";
import { Thickness } from "igniteui-react-core/ES2015/Thickness";
import { AxisAnnotationFrame } from "./AxisAnnotationFrame";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { Dictionary$2 } from "igniteui-react-core/ES2015/Dictionary$2";
import { Pool$1 } from "igniteui-react-core/ES2015/Pool$1";
import { AxisAnnotation } from "./AxisAnnotation";
import { SeriesView } from "./SeriesView";
import { NotImplementedException } from "igniteui-react-core/ES2015/NotImplementedException";
import { AxisRange } from "./AxisRange";
import { NumericAxisBase } from "./NumericAxisBase";
import { ScalerParams } from "./ScalerParams";
import { CategoryXAxis } from "./CategoryXAxis";
import { AxisAnnotationFrameManager } from "./AxisAnnotationFrameManager";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { isNaN_, isInfinity } from "igniteui-react-core/ES2015/number";
import { stringFormat } from "igniteui-react-core/ES2015/stringExtended";
import { Path } from "igniteui-react-core/ES2015/Path";
/**
 * @hidden
 */
export class ValueOverlay extends Series {
    constructor() {
        super();
        this.mf = 0;
        this.mg = 0;
        this.mc = 0;
        this.l0 = null;
        this.l6 = null;
        this.l5 = null;
        this.ab = ValueOverlay.$;
    }
    en(a, b, c) {
        return this.mh;
    }
    md(a, b) {
        let c = Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        let d = Math.acos((a.x - b.x) / c);
        if ((a.y - b.y) < 0) {
            d = (2 * Math.PI) - d;
        }
        return d;
    }
    lk(a, b, c) {
        if (this.lz == null) {
            return { $type: Point_$type, x: NaN, y: NaN };
        }
        let d = this.me();
        let e = NaN;
        let f = NaN;
        let g = NaN;
        let h = { $type: Point_$type, x: 0.5, y: 0.5 };
        let i = NaN;
        switch (this.lz.az) {
            case 2:
                i = Math.sqrt(Math.pow(a.x - h.x, 2) + Math.pow(a.y - h.y, 2));
                g = d;
                e = h.x + Math.cos(g) * i;
                f = h.y + Math.sin(g) * i;
                f = this.bi.br.top + this.bi.br.height * (f - this.bi.bs.top) / this.bi.bs.height;
                e = this.bi.br.left + this.bi.br.width * (e - this.bi.bs.left) / this.bi.bs.width;
                break;
            case 0:
                e = d;
                f = a.y;
                f = this.bi.br.top + this.bi.br.height * (f - this.bi.bs.top) / this.bi.bs.height;
                break;
            case 1:
                f = d;
                e = a.x;
                e = this.bi.br.left + this.bi.br.width * (e - this.bi.bs.left) / this.bi.bs.width;
                break;
            case 3:
                g = this.md(a, h);
                i = d;
                e = h.x + Math.cos(g) * i;
                f = h.y + Math.sin(g) * i;
                f = this.bi.br.top + this.bi.br.height * (f - this.bi.bs.top) / this.bi.bs.height;
                e = this.bi.br.left + this.bi.br.width * (e - this.bi.bs.left) / this.bi.bs.width;
                break;
        }
        return { $type: Point_$type, x: e, y: f };
    }
    e8(a) {
        throw new NotImplementedException(0);
    }
    fp(a) {
        return this;
    }
    c9(a) {
        return false;
    }
    an(a) {
        let b = typeCast(NumericAxisBase.$, a);
        let c = this.mh;
        if (isNaN_(c) || isInfinity(c)) {
            return null;
        }
        return new AxisRange(c, c);
    }
    jd(a) {
        this.hv(true, this.bi);
        if (!this.l4()) {
            return;
        }
        if (this.da(a)) {
            if (this.ca()) {
                if (this.bt.g) {
                    this.bt.t();
                }
                let b = this.mf;
                this.mf = this.mg;
                this.mg = b;
            }
            else {
                this.mf = this.mc;
            }
            this.mc = this.me();
            this.jk();
        }
        else {
            this.mc = this.me();
            this.my(this.mc, this.l2);
        }
    }
    me() {
        let a, b;
        let c = this.getViewInfo(b, a);
        b = c.p0;
        a = c.p1;
        let d = this.getEffectiveViewport1(this.bi);
        let e = new ScalerParams(0, a, b, this.lz.b8, d);
        return this.lz.dv(this.mh, e);
    }
    my(a, b) {
        if (this.lz == null) {
            return;
        }
        let c = typeCast(CategoryAxisBase.$, this.lz);
        if (c != null && !c.b5) {
            if (this.mh > c.jy - 1) {
                return;
            }
            if (c.categoryMode == 2) {
                let d = this.getEffectiveViewport1(b);
                let e = 0.5 * c.getCategorySize(b.bs, b.br, d);
                let f = false;
                if (c.ce && !c.b8) {
                    f = true;
                }
                if (typeCast(CategoryXAxis.$, c) !== null && c.b8) {
                    f = true;
                }
                if (f) {
                    e = -e;
                }
                a += e;
            }
        }
        let g = typeCast(NumericAxisBase.$, this.lz);
        if (g != null) {
            if (this.mh < g.j3 || this.mh > g.j2) {
                return;
            }
            if (g.jt && this.mh < 0) {
                return;
            }
        }
        let h;
        switch (this.lz.az) {
            case 2:
            case 3:
                h = this.lz.is(a, b.bs, b.br, this.getEffectiveViewport1(b), this.lp(b));
                break;
            default:
                h = this.lz.is(a, b.bs, b.br);
                break;
        }
        if (h != null) {
            b.bv(h);
        }
        if (this.l3) {
            this.mz(a, this.ca());
        }
    }
    dw(a, b, c) {
        let d = true;
        d = super.dw(a, b, c);
        if (!c.l() || b.isEmpty || a.isEmpty || this.lz == null || this.lz.bf == null) {
            d = false;
        }
        return d;
    }
    js(a, b) {
        this.jc(false);
    }
    jr(a, b) {
        this.jc(false);
    }
    hy(a, b, c, d) {
        throw new NotImplementedException(0);
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case ValueOverlay.$$p[10]:
                if (c != null) {
                    c.bv(this);
                }
                if (d != null) {
                    d.ch(this);
                }
                this.jc(false);
                this.ij();
                break;
            case "TransitionProgress":
                this.mg = this.mf + this.ez * (this.mc - this.mf);
                if (this.cc(this.bi)) {
                    return;
                }
                if (this.ez == 1) {
                    this.my(this.mc, this.l2);
                }
                else {
                    this.my(this.mg, this.l2);
                }
                if (this.bs != null) {
                    this.bs.jj(this);
                }
                break;
            case ValueOverlay.$$p[12]:
                let e = typeCast(NumericAxisBase.$, this.lz);
                if (e != null) {
                    e.ck();
                }
                this.jc(true);
                this.ik();
                break;
            case ValueOverlay.$$p[11]:
            case ValueOverlay.$$p[9]:
            case ValueOverlay.$$p[0]:
            case ValueOverlay.$$p[2]:
            case ValueOverlay.$$p[3]:
            case ValueOverlay.$$p[8]:
            case ValueOverlay.$$p[4]:
            case ValueOverlay.$$p[5]:
            case ValueOverlay.$$p[6]:
            case ValueOverlay.$$p[7]:
                this.jc(true);
                break;
        }
    }
    ia() {
        super.ia();
        if (this.lz != null) {
            this.lz.g5(false);
        }
    }
    hv(a, b) {
        super.hv(a, b);
        let c = b;
        c.bu();
    }
    l4() {
        if (this.lz == null || this.lz.bf == null || isNaN_(this.mh) || this._visibility == 1) {
            return false;
        }
        let a = typeCast(CategoryAxisBase.$, this.lz);
        if (a != null && a.jy == 0) {
            return false;
        }
        return true;
    }
    preferredCategoryMode(a) {
        return 0;
    }
    get categoryAxis() {
        return typeCast(CategoryAxisBase.$, this.lz);
    }
    bf() {
        return new ValueOverlayView(this);
    }
    it(a) {
        super.it(a);
        this.l2 = typeCast(ValueOverlayView.$, a);
    }
    je(a, b) {
        super.je(a, b);
        if (!this.dl) {
            this.bi.az(b);
            return;
        }
        this.bi.az(b);
        if (this.cc(this.bh) || !this.l4()) {
            return;
        }
        let c = this.getEffectiveViewport1(this.bi);
        let d = this.lz.dv(this.mh, new ScalerParams(0, this.bh.bs, a, this.lz.b8, c));
        this.my(d, typeCast(ValueOverlayView.$, this.bh));
        this.dl = false;
    }
    getOffsetValue() {
        return 0;
    }
    getCategoryWidth() {
        return 0;
    }
    get ng() {
        return new Thickness(1, this.l8, this.ma, this.l9, this.l7);
    }
    ag() {
        return [this.lz];
    }
    mz(a, b) {
        if (isNaN_(a)) {
            return;
        }
        let c = false;
        if (this.l5 == null) {
            c = true;
            this.l6 = new List$1(Axis.$, 0);
            this.l5 = new Dictionary$2(Axis.$, Pool$1.$.specialize(AxisAnnotation.$), 0);
        }
        this.l0 = new AxisAnnotationFrame();
        let d = this.k2;
        if (d == null) {
            d = this.k4;
        }
        let e = this.lz.ce;
        AxisAnnotationFrameManager.c(this.l0, { $type: Point_$type, x: a, y: a }, this, this.bs, this.getEffectiveViewport(), d, this.nd, this.nf, this.ne, this.ng, this.mb, this.nd, this.nf, this.ne, this.ng, this.mb, !this.lz.ce, this.lz.ce);
        AxisAnnotationFrameManager.d(this, this.l0, c, this.l5, this.l6, b, this.mi, this.mi, this.l1, this.l1);
    }
    get_c6() {
        return true;
    }
    mu(a) {
        if (this.lz != null) {
            return this.lz.fi(a);
        }
        return null;
    }
    get mw() {
        let a = this.mu(this.mh);
        return a != null ? a : stringFormat("{0:0.##}", this.mh);
    }
}
ValueOverlay.$t = markType(ValueOverlay, 'ValueOverlay', Series.$, [IHasCategoryModePreference_$type]);
Type.dep(DependencyProperty, PropertyMetadata, ValueOverlay, 'raisePropertyChanged', ['AxisAnnotationBackground:nd:m0', [Brush.$, null], 'AxisAnnotationFormatLabel:l1:m1', [Delegate_$type], 'AxisAnnotationInterpolatedValuePrecision:mi:m2', [1, -1], 'AxisAnnotationOutline:ne:m3', [Brush.$, null], 'AxisAnnotationPaddingBottom:l7:m4', [1, NaN], 'AxisAnnotationPaddingLeft:l8:m5', [1, NaN], 'AxisAnnotationPaddingRight:l9:m6', [1, NaN], 'AxisAnnotationPaddingTop:ma:m7', [1, NaN], 'AxisAnnotationStrokeThickness:mb:m8', [1, NaN], 'AxisAnnotationTextColor:nf:m9', [Brush.$, null], 'Axis:lz:na', [Axis.$, null], 'IsAxisAnnotationEnabled:l3:nb', [0, false], 'Value:mh:nc', [1, 0]]);
/**
 * @hidden
 */
export class ValueOverlayView extends SeriesView {
    constructor(a) {
        super(a);
        this.bw = null;
        this.bw = new Path();
    }
    a8() {
        super.a8();
        this.bw._stroke = this.e.k2;
        this.bw.ac = this.e.ey;
        this.bw.ai = this.e.la;
        this.bw.ad = this.e.lb;
    }
    a9() {
        super.a9();
        let a = this.bl();
        this.bw._stroke = a;
        this.bw.ac = this.e.ey + 3;
        this.bw._stroke = a;
        this.bw.ac = this.e.ey + 3;
    }
    bv(a) {
        this.bw.aj = a;
        this.an();
    }
    bu() {
        this.bw.aj = null;
        this.an();
    }
    a3(a, b) {
        super.a3(a, b);
        if (a.d) {
            a.s(this.bw);
        }
    }
    ai(a) {
        super.ai(a);
        this.e.a2.exportPathData(a, this.bw, "ValueOverlayPath", []);
    }
}
ValueOverlayView.$t = markType(ValueOverlayView, 'ValueOverlayView', SeriesView.$);
