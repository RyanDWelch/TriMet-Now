/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { ReactRenderer, ReactWrapper } from "igniteui-react-core/ES2015/react-renderer";
import { Visibility_$type } from "igniteui-react-core/ES2015/Visibility";
import { TypeRegistrar } from "igniteui-react-core/ES2015/type";
import { XamSparkline } from './XamSparkline';
import { brushToString, stringToBrush, ensureBool, ensureEnum, initializePropertiesFromCss, NamePatcher, isValidProp, getModifiedProps, toSpinal } from "igniteui-react-core/ES2015/componentUtil";
import { DataContext } from "igniteui-react-core/ES2015/igr-data-context";
import { SparklineStylingDefaults } from './SparklineStylingDefaults';
import { TrendLineType_$type } from "igniteui-react-core/ES2015/TrendLineType";
import { SparklineDisplayType_$type } from './SparklineDisplayType';
import { UnknownValuePlotting_$type } from "igniteui-react-core/ES2015/UnknownValuePlotting";
export class IgrSparkline extends React.Component {
    constructor(props) {
        super(props);
        this._dataSource = null;
        this._initialized = false;
        this._tooltipTemplate = null;
        this._tooltipContent = null;
        this._defaultTooltips = null;
        this._uniqueTooltipId = 0;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        this._tooltipRef = this._tooltipRef.bind(this);
        this._activeTooltipElements = new Map();
        this._activeTooltips = new Map();
        this._currentTooltips = [];
        let container = null;
        if (document) {
            container = document.createElement("div");
            container.style.display = "block";
            container.style.width = "100%";
            container.style.height = "100%";
        }
        var root;
        root = container;
        this._renderer = new ReactRenderer(root, document, true, SparklineStylingDefaults);
        this._implementation = this.createImplementation();
        this._container = this._renderer.getWrapper(container);
        //this._renderer.rootWrapper.append(this._container);
        //this._container.setStyleProperty("display", "block");
        //this._container.setStyleProperty("width", "100%");
        //this._container.setStyleProperty("height", "100%");
        this._wrapper = this._renderer;
        //var root: any;
        //root = this._container;
        //if (this._container.nativeElement != null) {
        //    root = this._container.nativeElement;
        //}
        var sparkline = this.i;
        this._sparkline = sparkline;
        sparkline.provideContainer(this._renderer);
        this._renderer.addSizeWatcher(() => {
            this._sparkline.notifyResized();
        });
        this._initialized = true;
    }
    set height(value) {
        this._height = value;
        if (this._elRef) {
            this._elRef.style.height = value;
            this.notifyResized();
        }
    }
    get height() {
        return this._height;
    }
    set width(value) {
        this._width = value;
        if (this._elRef) {
            this._elRef.style.width = value;
            this.notifyResized();
        }
    }
    get width() {
        return this._width;
    }
    render() {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        let children = [];
        React.Children.forEach(this.props.children, (ch) => {
            children.push(ch);
        });
        if (this._currentTooltips && this._currentTooltips.length > 0) {
            for (let i = 0; i < this._currentTooltips.length; i++) {
                let t = this._currentTooltips[i];
                if (this._activeTooltipElements.has(t)) {
                    children.push(this._activeTooltipElements.get(t));
                }
                else {
                    if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
                        continue;
                    }
                    let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
                    let tEle = React.createElement(Tooltip, {
                        ref: this._tooltipRef,
                        key: this._currentTooltips[i].key,
                        owner: this._currentTooltips[i]
                    });
                    let portal = ReactDOM.createPortal(tEle, t, this._currentTooltips[i].key);
                    this._activeTooltipElements.set(t, portal);
                    children.push(portal);
                }
            }
        }
        let div = React.createElement("div", {
            className: "ig-sparkline igr-sparkline",
            ref: this._getMainRef,
            children: children
        });
        return div;
        //}
    }
    _tooltipRef(t) {
        //console.log(t);
        if (t === null) {
            return;
        }
        if (t.currentOwner &&
            t.currentOwner.tooltipTemplate) {
            t.template = t.currentOwner.tooltipTemplate;
        }
        this._activeTooltips.set(t.currentOwner, t);
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                {
                    this[p] = this.props[p];
                }
            }
        }
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container.getNativeElement());
        this.notifyResized();
        this.initializeContent();
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    set dataSource(value) {
        this._dataSource = value;
        this.i.itemsSource = this._dataSource;
        //console.log("setting axis data source: " + value)
    }
    get dataSource() {
        if (this._dataSource != null) {
            return this._dataSource;
        }
        return this.i.itemsSource;
    }
    _getMainRef(div) {
        this._elRef = div;
    }
    destroy() {
        this._sparkline.destroy();
        this._wrapper.destroy();
    }
    createImplementation() {
        return new XamSparkline();
    }
    initializeContent() {
        this._styling(this._container.getNativeElement(), this);
        this.i.notifyResized();
    }
    componentWillUnmount() {
        //this._grid.destroy();
        this.destroy();
    }
    initializeProperties() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    set tooltipTemplate(value) {
        this._tooltipTemplate = value;
        if (value == null) {
            if (this._tooltipContent !== null) {
                this._tooltipContent.destroy();
                this._tooltipContent = null;
            }
        }
        if (this._tooltipContent != null) {
            this._tooltipContent.instance.template = this._tooltipTemplate;
        }
        else {
            this._ensureTooltipCreated();
        }
    }
    get tooltipTemplate() {
        return this._tooltipTemplate;
    }
    createWrapper(ele) {
        let wrapper = new ReactWrapper(ele, this._renderer);
        wrapper.updateToolTip = ele.updateToolTip;
        wrapper.hideToolTip = ele.hideToolTip;
        return wrapper;
    }
    _ensureDefaultTooltip() {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips["ensureDefaultTooltip"](this);
    }
    _onDefaultTooltipsReady(cr) {
        this._ensureDefaultTooltip();
    }
    _updateTooltipState() {
        if (this._initialized) {
            this.setState({ tooltips: this._currentTooltips });
        }
    }
    createTooltip() {
        // if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
        // 	return null;
        // }
        // let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
        let wrapper = this._wrapper.createElement("div");
        let ele = wrapper.getNativeElement();
        ele.key = "__tooltip_" + this._uniqueTooltipId;
        this._uniqueTooltipId++;
        this._currentTooltips = this._currentTooltips.slice(0);
        this._currentTooltips.push(ele);
        //let element = React.createElement(Tooltip,  );
        //let portal = ReactDOM.createPortal(element, ele);
        let self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                let ext = new DataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container.getNativeElement()) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.getNativeElement().appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            if (self._activeTooltips.has(ele)) {
                let t = self._activeTooltips.get(ele);
                if (t.template === null &&
                    self.tooltipTemplate !== null) {
                    t.template = self.tooltipTemplate;
                }
                t.dataContext = c;
            }
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        this._updateTooltipState();
        return ele;
    }
    _ensureTooltipCreated() {
        if (this.i.toolTip == null) {
            let tooltip = this.createTooltip();
            let ele = tooltip;
            if (tooltip == null) {
                return;
            }
            this._tooltipContent = tooltip;
            //(<any>tooltip.instance).template = this._tooltipTemplate;
            this.i.toolTip = this.createWrapper(tooltip);
            if (this._activeTooltips.has(ele)) {
                let tCont = this._activeTooltips.get(ele);
                tCont.template = ele.tooltipTemplate;
            }
        }
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets or sets the sparkline brush.
*/
    get brush() {
        return brushToString(this.i.es);
    }
    set brush(v) {
        this.i.es = stringToBrush(v);
    }
    /**
     * Gets or sets the negative brush of the sparkline.
    */
    get negativeBrush() {
        return brushToString(this.i.ez);
    }
    set negativeBrush(v) {
        this.i.ez = stringToBrush(v);
    }
    /**
     * Gets or sets the marker brush of the sparkline.
    */
    get markerBrush() {
        return brushToString(this.i.ey);
    }
    set markerBrush(v) {
        this.i.ey = stringToBrush(v);
    }
    /**
     * Gets or sets the negative marker brush of the sparkline.
    */
    get negativeMarkerBrush() {
        return brushToString(this.i.e0);
    }
    set negativeMarkerBrush(v) {
        this.i.e0 = stringToBrush(v);
    }
    /**
     * Gets or sets the first marker brush of the sparkline.
    */
    get firstMarkerBrush() {
        return brushToString(this.i.et);
    }
    set firstMarkerBrush(v) {
        this.i.et = stringToBrush(v);
    }
    /**
     * Gets or sets the last marker brush of the sparkline.
    */
    get lastMarkerBrush() {
        return brushToString(this.i.ew);
    }
    set lastMarkerBrush(v) {
        this.i.ew = stringToBrush(v);
    }
    /**
     * Gets or sets the high marker brush of the sparkline.
    */
    get highMarkerBrush() {
        return brushToString(this.i.eu);
    }
    set highMarkerBrush(v) {
        this.i.eu = stringToBrush(v);
    }
    /**
     * Gets or sets the low marker brush of the sparkline.
    */
    get lowMarkerBrush() {
        return brushToString(this.i.ex);
    }
    set lowMarkerBrush(v) {
        this.i.ex = stringToBrush(v);
    }
    /**
     * Gets or sets the trendline brush of the sparkline.
    */
    get trendLineBrush() {
        return brushToString(this.i.e2);
    }
    set trendLineBrush(v) {
        this.i.e2 = stringToBrush(v);
    }
    /**
     * Gets or sets the horizontal axis line brush of the sparkline.
    */
    get horizontalAxisBrush() {
        return brushToString(this.i.ev);
    }
    set horizontalAxisBrush(v) {
        this.i.ev = stringToBrush(v);
    }
    /**
     * Gets or sets the vertical axis line brush of the sparkline.
    */
    get verticalAxisBrush() {
        return brushToString(this.i.e3);
    }
    set verticalAxisBrush(v) {
        this.i.e3 = stringToBrush(v);
    }
    /**
     * Gets or sets the normal range brush of the sparkline.
    */
    get normalRangeFill() {
        return brushToString(this.i.e1);
    }
    set normalRangeFill(v) {
        this.i.e1 = stringToBrush(v);
    }
    /**
     * Gets or sets the display state of the horizontal axis.
    */
    get horizontalAxisVisibility() {
        return this.i.e6;
    }
    set horizontalAxisVisibility(v) {
        this.i.e6 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the display state of the vertical axis.
    */
    get verticalAxisVisibility() {
        return this.i.fd;
    }
    set verticalAxisVisibility(v) {
        this.i.fd = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the marker visibility of the sparkline.
    */
    get markerVisibility() {
        return this.i.e9;
    }
    set markerVisibility(v) {
        this.i.e9 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the negative marker visibility of the sparkline.
    */
    get negativeMarkerVisibility() {
        return this.i.fa;
    }
    set negativeMarkerVisibility(v) {
        this.i.fa = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the first marker visibility of the sparkline.
    */
    get firstMarkerVisibility() {
        return this.i.e4;
    }
    set firstMarkerVisibility(v) {
        this.i.e4 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the last marker visibility of the sparkline.
    */
    get lastMarkerVisibility() {
        return this.i.e7;
    }
    set lastMarkerVisibility(v) {
        this.i.e7 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the low marker visibility of the sparkline.
    */
    get lowMarkerVisibility() {
        return this.i.e8;
    }
    set lowMarkerVisibility(v) {
        this.i.e8 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the high marker visibility of the sparkline.
    */
    get highMarkerVisibility() {
        return this.i.e5;
    }
    set highMarkerVisibility(v) {
        this.i.e5 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the normal range visibility of the sparkline.
    */
    get normalRangeVisibility() {
        return this.i.fb;
    }
    set normalRangeVisibility(v) {
        this.i.fb = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the position of the normal range on the sparkline.
    */
    get displayNormalRangeInFront() {
        return this.i.as;
    }
    set displayNormalRangeInFront(v) {
        this.i.as = ensureBool(v);
    }
    /**
     * Gets or sets the marker size of the sparkline.
    */
    get markerSize() {
        return this.i.a9;
    }
    set markerSize(v) {
        this.i.a9 = +v;
    }
    /**
     * Gets or sets the first marker size of the sparkline.
    */
    get firstMarkerSize() {
        return this.i.a2;
    }
    set firstMarkerSize(v) {
        this.i.a2 = +v;
    }
    /**
     * Gets or sets the last marker size of the sparkline.
    */
    get lastMarkerSize() {
        return this.i.a4;
    }
    set lastMarkerSize(v) {
        this.i.a4 = +v;
    }
    /**
     * Gets or sets the high marker size of the sparkline.
    */
    get highMarkerSize() {
        return this.i.a3;
    }
    set highMarkerSize(v) {
        this.i.a3 = +v;
    }
    /**
     * Gets or sets the low marker size of the sparkline.
    */
    get lowMarkerSize() {
        return this.i.a8;
    }
    set lowMarkerSize(v) {
        this.i.a8 = +v;
    }
    /**
     * Gets or sets the negative marker size of the sparkline.
    */
    get negativeMarkerSize() {
        return this.i.be;
    }
    set negativeMarkerSize(v) {
        this.i.be = +v;
    }
    /**
     * Gets or sets the line thickness of the sparkline.
    */
    get lineThickness() {
        return this.i.a5;
    }
    set lineThickness(v) {
        this.i.a5 = +v;
    }
    /**
     * Gets or sets the minimum value of the y axis.
    */
    get minimum() {
        return this.i.bd;
    }
    set minimum(v) {
        this.i.bd = +v;
    }
    /**
     * Gets or sets the maximum value of the y axis.
    */
    get maximum() {
        return this.i.bc;
    }
    set maximum(v) {
        this.i.bc = +v;
    }
    /**
     * Gets or sets the string path to the value column.
    */
    get valueMemberPath() {
        return this.i.c2;
    }
    set valueMemberPath(v) {
        this.i.c2 = v;
    }
    /**
     * String identifier of a column or property name to get labels from on each item in the data source.  These labels will be retrieved from the first and last item, and displayed by the horizontal axis.
    */
    get labelMemberPath() {
        return this.i.b7;
    }
    set labelMemberPath(v) {
        this.i.b7 = v;
    }
    /**
     * Gets or sets the type of trendline used by the sparkline.
    */
    get trendLineType() {
        return this.i.an;
    }
    set trendLineType(v) {
        this.i.an = ensureEnum(TrendLineType_$type, v);
    }
    /**
     * Gets or sets the trendline period used by the sparkline.
    */
    get trendLinePeriod() {
        return this.i.bm;
    }
    set trendLinePeriod(v) {
        this.i.bm = +v;
    }
    /**
     * Gets or sets the thickness of the sparkline's trendline.
    */
    get trendLineThickness() {
        return this.i.bi;
    }
    set trendLineThickness(v) {
        this.i.bi = +v;
    }
    /**
     * Gets or sets the minimum value of the normal range.
    */
    get normalRangeMinimum() {
        return this.i.bg;
    }
    set normalRangeMinimum(v) {
        this.i.bg = +v;
    }
    /**
     * Gets or sets the maximum value of the normal range.
    */
    get normalRangeMaximum() {
        return this.i.bf;
    }
    set normalRangeMaximum(v) {
        this.i.bf = +v;
    }
    /**
     * Gets or sets the display type of the sparkline.
    */
    get displayType() {
        return this.i.am;
    }
    set displayType(v) {
        this.i.am = ensureEnum(SparklineDisplayType_$type, v);
    }
    /**
     * Gets or sets the way null values are interpreted.
    */
    get unknownValuePlotting() {
        return this.i.ao;
    }
    set unknownValuePlotting(v) {
        this.i.ao = ensureEnum(UnknownValuePlotting_$type, v);
    }
    /**
     * The value or content to display on the vertical axis.
     * This can be set to a formatted string, such as "{0:n}", or it can be set to a DataTemplate.
    */
    get verticalAxisLabel() {
        return this.i.bp;
    }
    set verticalAxisLabel(v) {
        this.i.bp = v;
    }
    /**
     * The value or content to display on the horizontal axis.
     * This can be set to a formatted string, such as "{0}", or it can be set to a DataTemplate.
    */
    get horizontalAxisLabel() {
        return this.i.bn;
    }
    set horizontalAxisLabel(v) {
        this.i.bn = v;
    }
    /**
     * Sets or gets a function which takes an object that produces a formatted label for displaying in the chart.
    */
    get formatLabel() {
        return this.i.bl;
    }
    set formatLabel(v) {
        this.i.bl = v;
    }
    /**
     * Gets or sets the scaling value used to affect the pixel density of the control.
     * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
     * to appear blurry.
    */
    get pixelScalingRatio() {
        return this.i.bh;
    }
    set pixelScalingRatio(v) {
        this.i.bh = +v;
    }
    /**
     * Gets the actual scaling value used by the component to affect the pixel density of the control.
     * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
     * to appear blurry.
    */
    get actualPixelScalingRatio() {
        return this.i.a1;
    }
    set actualPixelScalingRatio(v) {
        this.i.a1 = +v;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Sparkline");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
 * Provides a container to the sparkline control.

* @param container  * The container.
*/
    provideContainer(container) {
        this.i.provideContainer(container);
    }
    /**
     * Notify that the control has resized.
    
    */
    notifyResized() {
        this.i.notifyResized();
    }
    notifySetItem(source_, index, oldItem, newItem) {
        this.i.dd(source_, index, oldItem, newItem);
    }
    /**
     * Used to manually notify the IgxSparklineComponent that the data source has reset or cleared its items.  Invoking this method is only necessary if that datasource is not observable.
    
    * @param source_  * The data source which was cleared or reset.
    */
    notifyClearItems(source_) {
        this.i.c9(source_);
    }
    notifyInsertItem(source_, index, newItem) {
        this.i.da(source_, index, newItem);
    }
    notifyRemoveItem(source_, index, oldItem) {
        this.i.db(source_, index, oldItem);
    }
    /**
     * Returns the sparkline visuals expressed as a SparklineVisualData object.
    
    */
    exportVisualData() {
        let iv = this.i.aq();
        return (iv);
    }
    /**
     * Returns visuals as a serialized string.
    
    */
    exportSerializedVisualData() {
        let iv = this.i.bu();
        return (iv);
    }
}
