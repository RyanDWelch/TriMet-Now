/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, Type, markType, Array_$type, Number_$type, Point_$type, enumGetBox, runOn, fromEnum } from "igniteui-react-core/ES2015/type";
import { IBucketizer_$type } from "./IBucketizer";
import { ArgumentNullException } from "igniteui-react-core/ES2015/ArgumentNullException";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { ISortingAxis_$type } from "./ISortingAxis";
import { ScalerParams } from "./ScalerParams";
import { Series } from "./Series";
import { truncate, intDivide, isNaN_, isInfinity } from "igniteui-react-core/ES2015/number";
import { FramePreparer } from "./FramePreparer";
import { IIsCategoryBased_$type } from "./IIsCategoryBased";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { ISupportsMarkers_$type } from "./ISupportsMarkers";
import { IProvidesViewport_$type } from "./IProvidesViewport";
import { ISupportsErrorBars_$type } from "./ISupportsErrorBars";
import { CategoryFrame } from "./CategoryFrame";
import { PreparationParams } from "./PreparationParams";
import { IDateTimeAxis_$type } from "./IDateTimeAxis";
import { NumericAxisBase } from "./NumericAxisBase";
import { IHasCategoryTrendline_$type } from "./IHasCategoryTrendline";
import { IHasSingleValueCategory_$type } from "./IHasSingleValueCategory";
import { DefaultCategoryTrendlineHost } from "./DefaultCategoryTrendlineHost";
import { DefaultSingleValueProvider } from "./DefaultSingleValueProvider";
import { SingleValuesHolder } from "./SingleValuesHolder";
import { MarkerSeries } from "./MarkerSeries";
import { IHasCategoryModePreference_$type } from "./IHasCategoryModePreference";
import { ICategorySeriesInteractionManager_$type } from "./ICategorySeriesInteractionManager";
import { DVContainer } from "igniteui-react-core/ES2015/DVContainer";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { CategoryTransitionInMode_$type } from "./CategoryTransitionInMode";
import { HighlightingInfo } from "./HighlightingInfo";
import { CategoryTransitionSourceFramePreparer } from "./CategoryTransitionSourceFramePreparer";
import { SeriesPointOfInterest } from "./SeriesPointOfInterest";
import { Marker } from "./Marker";
import { MarkerSeriesView } from "./MarkerSeriesView";
import { CategorySeriesRenderManager } from "./CategorySeriesRenderManager";
import { Pool$1 } from "igniteui-react-core/ES2015/Pool$1";
import { Clipper } from "igniteui-react-core/ES2015/Clipper";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { round10N } from "igniteui-react-core/ES2015/numberExtended";
/**
 * @hidden
 */
export class CategoryBucketCalculator extends Base {
    constructor(a) {
        super();
        this.c = null;
        this.e = 0;
        this.f = 0;
        this.d = 0;
        if (a == null) {
            throw new ArgumentNullException(0, "view");
        }
        this.c = a;
        this.e = -1;
        this.d = 0;
    }
    getBucket(a) {
        return null;
    }
    getBucketWithoutUnknowns(a) {
        return this.getBucket(a);
    }
    getErrorBucket(a, b) {
        return NaN;
    }
    g(a) {
        let b = this.c.bs;
        let c = this.c.br;
        let d = this.c.cp;
        let e = typeCast(CategoryAxisBase.$, d.fetchXAxis());
        let f = d.bz;
        if (b.isEmpty || c.isEmpty || e == null || f == null || f.count == 0) {
            this.d = 0;
            return;
        }
        let g = d.getEffectiveViewport1(this.c);
        let h = d.lp(this.c);
        let i = typeCast(ISortingAxis_$type, e);
        if (i == null || i.i$b == null) {
            let j = new ScalerParams(0, b, c, e.b8, g);
            let k = Math.floor(e.dz(h.left, j, 0));
            let l = Math.ceil(e.dz(h.right, j, 0));
            if (e.b8) {
                l = Math.ceil(e.dz(h.left, j, 0));
                k = Math.floor(e.dz(h.right, j, 0));
            }
            let m = Math.floor((l - k + 1) * a / h.width);
            this.d = truncate(Math.max(1, m));
            this.e = truncate(Math.max(0, Math.floor(k / this.d) - 1));
            this.f = truncate(Math.ceil(l / this.d));
        }
        else {
            this.e = i.i$e(b, c, g, h);
            this.f = i.i$g(b, c, g, h);
            this.d = 1;
        }
    }
    getBucketInfo(a, b, c, d) {
        a = this.e;
        b = this.f;
        c = this.d;
        d = this.c.cp.eu;
        return {
            p0: a,
            p1: b,
            p2: c,
            p3: d
        };
    }
    cacheValues() {
    }
    unCacheValues() {
    }
}
CategoryBucketCalculator.$t = markType(CategoryBucketCalculator, 'CategoryBucketCalculator', Base.$, [IBucketizer_$type]);
/**
 * @hidden
 */
export class CategoryFramePreparerBase extends FramePreparer {
    constructor(a, ..._rest) {
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    let c = _rest[0];
                    let d = [c, typeCast(ISupportsMarkers_$type, c), typeCast(IProvidesViewport_$type, c), typeCast(ISupportsErrorBars_$type, c), typeCast(IBucketizer_$type, c)];
                    {
                        let f = d[0];
                        let g = d[1];
                        let h = d[2];
                        let i = d[3];
                        let j = d[4];
                        super(1, g, h, i);
                        this.g = null;
                        this.h = null;
                        this.m = false;
                        this.o = new List$1(Array_$type, 0);
                        this.p = new List$1(Number_$type, 0);
                        this.n = new List$1(Number_$type, 0);
                        this.h = f;
                        this.g = j;
                    }
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    let g = _rest[4];
                    super(1, d, e, f);
                    this.g = null;
                    this.h = null;
                    this.m = false;
                    this.o = new List$1(Array_$type, 0);
                    this.p = new List$1(Number_$type, 0);
                    this.n = new List$1(Number_$type, 0);
                    this.h = c;
                    this.g = g;
                }
                break;
        }
    }
    i(a) {
        let b = new PreparationParams();
        b.f = this.h.useHighMarkerFidelity;
        b.b = this.h.scaler;
        b.c = this.h.yScaler;
        b.d = typeCast(ISortingAxis_$type, b.b);
        b.a = typeCast(CategoryFrame.$, a);
        if (b.a == null || b.b == null || b.c == null) {
            return null;
        }
        let c;
        let d;
        let e;
        let f;
        let g = this.g.getBucketInfo(c, d, e, f);
        c = g.p0;
        d = g.p1;
        e = g.p2;
        f = g.p3;
        b.i = c;
        b.j = d;
        b.h = e;
        b.g = f;
        if (b.j < b.i) {
            return null;
        }
        let h;
        let i;
        let j;
        let k = this.a.getViewInfo(i, h);
        i = k.p0;
        h = k.p1;
        j = this.a.getEffectiveViewport();
        b.m = h;
        b.l = i;
        b.k = j;
        if (Rect.l_op_Equality(b.m, Rect.empty) || Rect.l_op_Equality(b.l, Rect.empty)) {
            return null;
        }
        if (this.h != null && (typeCast(Series.$, this.h) !== null && this.h.cs) && this.g != null) {
            b.e = true;
        }
        return b;
    }
    r(a, b, c, d) {
        return a.getSeriesOffset(b, c, d, this.h.currentMode2Index, this.h.currentCategoryMode);
    }
    s(a) {
        return this.r(a.b, a.m, a.l, a.k);
    }
    d(a, b) {
        let c = this.i(a);
        if (c == null || this.g == null) {
            return;
        }
        c.a.f.clear();
        c.a.k.clear();
        c.a.m.clear();
        c.a.p.clear();
        c.a.i.clear();
        c.a.h.clear();
        c.a.g.clear();
        let d = this.c.shouldDisplayMarkers;
        let e = false;
        let f = this.s(c);
        let g = this.j(c);
        if (c.d != null && c.d.i$b != null && c.d.i$b.count != g.e) {
            return;
        }
        if (c.d != null && c.d.i$a) {
            c.d.i$h();
        }
        this.g.cacheValues();
        if (this.m && c.d != null && c.d.i$b.count > 0) {
            let h = c.d.i$b._inner[c.i];
            this.z(g, h, true, c.e);
            while ((isNaN_(g.c) || isNaN_(g.d)) && c.i > 0) {
                c.i = c.i - 1;
                h = c.d.i$b._inner[c.i];
                this.z(g, h, true, c.e);
            }
            let i = c.d.i$b._inner[c.j];
            this.z(g, i, true, c.e);
            while ((isNaN_(g.c) || isNaN_(g.d)) && c.j < g.e - 1) {
                c.j = c.j + 1;
                i = c.d.i$b._inner[c.j];
                this.z(g, i, true, c.e);
            }
        }
        if (this.m && c.d == null) {
            let j = c.i;
            let k = this.g.getBucket(j);
            while ((isNaN_(k[1]) || isNaN_(k[2])) && c.i > 0) {
                c.i = c.i - 1;
                j = c.i;
                k = this.g.getBucket(j);
            }
            let l = c.j;
            k = this.g.getBucket(l);
            while ((isNaN_(k[1]) || isNaN_(k[2])) && c.j < (intDivide(g.e, c.h))) {
                c.j = c.j + 1;
                l = c.j;
                k = this.g.getBucket(l);
            }
        }
        this.w(c, g, f);
        let m = this.t(c, g, f, d, e);
        this.c.updateMarkerCount(m);
        this.v(typeCast(CategoryFrame.$, a), b);
        this.g.unCacheValues();
        return;
    }
    v(a, b) {
    }
    get q() {
        return this.o;
    }
    t(a, b, c, d, e) {
        let f = 0;
        let g = false;
        let h = null;
        let i = false;
        let j = a.d != null;
        let k = a.m;
        let l = a.l;
        let m = typeCast(NumericAxisBase.$, a.c) !== null && a.c.jt;
        let n = a.f;
        let o = this.h.mayContainUnknowns;
        let p = this.o;
        let q = this.n;
        let r = this.p;
        p.clear();
        q.clear();
        r.clear();
        let s = this.g;
        let t = this.h.provideCollisionDetector();
        let u = 0;
        let v = a.k;
        let w = new ScalerParams(0, k, l, a.b.j$a, v);
        let x = ((() => {
            let $ret = new ScalerParams(0, k, l, a.c.j$a, v);
            $ret.b = typeCast(Series.$, this.h) !== null ? this.h.eh() : NaN;
            return $ret;
        })());
        if (j) {
            u = a.b.j$c(2, w) - a.b.j$c(1, w);
            i = this.k();
        }
        let y = a.i;
        let z = a.j;
        let aa = a.a.f;
        let ab = typeCast(IDateTimeAxis_$type, a.b);
        if (ab != null) {
            ab.StartTimeCursor();
        }
        for (let ac = y; ac <= z; ++ac) {
            let ad;
            if (!j) {
                if (!o) {
                    ad = s.getBucketWithoutUnknowns(ac);
                }
                else {
                    ad = s.getBucket(ac);
                }
            }
            else {
                ad = ((() => { let ae = this.f(a, ac, b, u, g, h, c); ac = ae.p1; g = ae.p4; h = ae.p5; return ae.ret; })());
            }
            let ae = !m || (m && ad[1] > 0);
            let af = ad[0];
            if (!j || !isNaN_(ad[0])) {
                aa.add(ad);
                if (g && i) {
                    if (h != null) {
                        aa.add(h);
                    }
                }
                if (d && ae) {
                    let ag = ac * a.h;
                    let ah = ag;
                    if (j && a.d.i$b != null && ag >= 0 && ag < a.d.i$b.count) {
                        ag = a.d.i$b._inner[ag];
                    }
                    let ai = new Array(ad.length);
                    ai[0] = ad[0];
                    ai[1] = ad[1];
                    ai[2] = ad[2];
                    if (n && ag < b.e) {
                        ai = new Array(ad.length);
                        ai[0] = af;
                        this.z(b, ag, true, a.e);
                        ai[1] = b.c;
                        ai[2] = b.d;
                    }
                    p.add(ai);
                    q.add(a.a.f.count - 1);
                    r.add(ag);
                }
            }
        }
        if (ab != null) {
            ab.ResetTimeCursor();
        }
        this.y(a, c, j, w, x, e, d);
        if (d) {
            let aj = p.count;
            let ak;
            for (let al = 0; al < aj; al++) {
                ak = p._inner[al];
                if (this.l(a.a, ak, t, Math.min(r._inner[al], b.e - 1), f, q._inner[al])) {
                    ++f;
                }
            }
        }
        return f;
    }
    k() {
        if (typeCast(Series.$, this.h) !== null) {
            return this.h.ck;
        }
        return false;
    }
    f(a, b, c, d, e, f, g) {
        let h;
        f = null;
        e = false;
        let i = typeCast(CategorySeries.$, this.h);
        let j = a.l;
        let k = a.m;
        let l = a.k;
        let m = new ScalerParams(0, k, j, a.b.j$a, l);
        let n = new ScalerParams(0, k, j, a.c.j$a, l);
        let o = a.e;
        if (a.d == null || a.d.i$b == null || a.d.i$b.count == 0) {
            return {
                ret: [NaN, NaN, NaN],
                p1: b,
                p4: e,
                p5: f
            };
        }
        if (i != null && i.bz != null && i.bz.count < a.d.i$b.count) {
            return {
                ret: [NaN, NaN, NaN],
                p1: b,
                p4: e,
                p5: f
            };
        }
        let p = a.d.i$b._inner[b];
        let q = a.d.i$d(p);
        let r = q;
        this.z(c, p, false, o);
        while (b < a.j) {
            p = a.d.i$b._inner[b + 1];
            r = a.d.i$d(p);
            this.z(c, p, true, o);
            if (r - q >= d || isNaN_(c.c) || isNaN_(c.d)) {
                if (e) {
                    let s = a.d.i$b._inner[b];
                    this.z(c, s, true, o);
                    f = [a.b.j$b(q, m), c.c, c.d];
                }
                break;
            }
            if (!e && this.k()) {
                let t = a.d.i$b._inner[b];
                this.z(c, t, true, o);
                let u = [a.b.j$b(q, m), c.c, c.d];
                if (!isNaN_(u[0])) {
                    if (!isNaN_(u[1]) && !isNaN_(u[2])) {
                        if (a.d != null) {
                            u[0] = u[0] + g;
                        }
                        a.a.f.add(u);
                        e = true;
                    }
                    else {
                        break;
                    }
                }
            }
            b++;
            this.u(c, p, o);
        }
        let v = NaN;
        if (!isNaN_(q)) {
            v = a.b.j$b(q, m);
        }
        h = this.e(v, c);
        return {
            ret: h,
            p1: b,
            p4: e,
            p5: f
        };
    }
    y(a, b, c, d, e, f, g) {
        let h = a.h;
        let i = a.a.f.count;
        let j = a.a.f;
        let k = this.o;
        let l = k.count;
        if (f) {
            let m = a.c.j$b(a.c.kd, e);
            a.c.j$e(a.a.k, 0, a.a.k.count, e);
            let n = a.a.k;
            let o = n.count;
            for (let p = 0; p < n.count; p++) {
                n._inner[p] = Math.abs(n._inner[p] - m);
            }
        }
    }
    w(a, b, c) {
    }
}
CategoryFramePreparerBase.$t = markType(CategoryFramePreparerBase, 'CategoryFramePreparerBase', FramePreparer.$);
/**
 * @hidden
 */
export class CategoryFramePreparer extends CategoryFramePreparerBase {
    constructor(a, ..._rest) {
        a = (a == void 0) ? 0 : a;
        switch (a) {
            case 0:
                {
                    let c = _rest[0];
                    let d = [c, typeCast(ISupportsMarkers_$type, c), typeCast(IProvidesViewport_$type, c), typeCast(ISupportsErrorBars_$type, c), typeCast(IBucketizer_$type, c)];
                    {
                        let f = d[0];
                        let g = d[1];
                        let h = d[2];
                        let i = d[3];
                        let j = d[4];
                        super(1, f, g, h, i, j);
                        this.aa = null;
                        this.ab = null;
                        this.aa = new DefaultCategoryTrendlineHost();
                        if (typeCast(IHasCategoryTrendline_$type, f) !== null) {
                            this.aa = typeCast(IHasCategoryTrendline_$type, f);
                        }
                        this.ab = new DefaultSingleValueProvider();
                        if (typeCast(IHasSingleValueCategory_$type, f) !== null) {
                            this.ab = typeCast(IHasSingleValueCategory_$type, f);
                        }
                    }
                }
                break;
            case 1:
                {
                    let c = _rest[0];
                    let d = _rest[1];
                    let e = _rest[2];
                    let f = _rest[3];
                    let g = _rest[4];
                    super(1, c, d, e, f, g);
                    this.aa = null;
                    this.ab = null;
                    this.aa = new DefaultCategoryTrendlineHost();
                    if (typeCast(IHasCategoryTrendline_$type, c) !== null) {
                        this.aa = typeCast(IHasCategoryTrendline_$type, c);
                    }
                    this.ab = new DefaultSingleValueProvider();
                    if (typeCast(IHasSingleValueCategory_$type, c) !== null) {
                        this.ab = typeCast(IHasSingleValueCategory_$type, c);
                    }
                }
                break;
        }
    }
    l(a, b, c, d, e, f) {
        let g = b[0];
        let h = b[1];
        let i = new Rect(0, g - 5, h - 5, 11, 11);
        if (!isNaN_(g) && !isNaN_(h) && !isInfinity(g) && !isInfinity(h) && c.tryAdd(i)) {
            a.m.add({ $type: Point_$type, x: g, y: h });
            this.c.updateMarkerTemplate(e, d, f);
            return true;
        }
        return false;
    }
    j(a) {
        let b = new SingleValuesHolder();
        let c = this.ab.valueColumn;
        b.f = c;
        return b;
    }
    x(a, b, c, d, e, f) {
        if (d) {
            b[0] = b[0] + c;
        }
        else {
            b[0] = a.b.j$b(b[0], e) + c;
        }
        b[1] = a.c.j$b(b[1], f);
        if (a.h > 1 || d) {
            b[2] = a.c.j$b(b[2], f);
        }
        else {
            b[2] = b[1];
        }
    }
    y(a, b, c, d, e, f, g) {
        super.y(a, b, c, d, e, f, g);
        let h = a.h;
        let i = a.a.f.count;
        let j = a.a.f;
        let k = this.q;
        let l = k.count;
        let m = new List$1(Number_$type, 0);
        if (!c) {
            m.add(0);
        }
        let n = new List$1(Number_$type, 0);
        n.add(1);
        if (c || h > 1) {
            n.add(2);
        }
        a.b.j$d(j, m, 0, i, d);
        a.c.j$d(j, n, 0, i, e);
        for (let o = 0; o < i; o++) {
            j._inner[o][0] = j._inner[o][0] + b;
        }
        if (h == 1 && !c) {
            for (let p = 0; p < i; p++) {
                j._inner[p][2] = j._inner[p][1];
            }
        }
        if (g) {
            a.b.j$d(k, m, 0, l, d);
            a.c.j$d(k, n, 0, l, e);
            for (let q = 0; q < l; q++) {
                k._inner[q][0] = k._inner[q][0] + b;
            }
            if (h == 1 && !c) {
                for (let r = 0; r < l; r++) {
                    k._inner[r][2] = k._inner[r][1];
                }
            }
        }
    }
    w(a, b, c) {
        if (this.aa.trendLineType == 0 || this.aa.trendlinePreparer == null || this.aa.trendLinePeriod < 1) {
            return;
        }
        this.aa.trendlinePreparer.prepareLine(this.aa, a, b, c);
    }
    z(a, b, c, d) {
        let e = a;
        let f = e.f;
        let g = f.item(b);
        let h = g;
        if (d) {
            let i = this.g.getBucket(b);
            g = i[1];
            h = i[1];
        }
        if (c) {
            e.c = g;
            e.d = h;
        }
        else {
            e.a = g;
            e.b = h;
        }
    }
    u(a, b, c) {
        let d = a;
        let e = d.f;
        if (b < e.count) {
            let f;
            if (c) {
                let g = this.g.getBucket(b);
                f = g[1];
            }
            else {
                f = e.item(b);
            }
            d.a = Math.min(d.a, f);
            d.b = Math.max(d.b, f);
        }
    }
    e(a, b) {
        let c = b;
        return [a, c.a, c.b];
    }
}
CategoryFramePreparer.$t = markType(CategoryFramePreparer, 'CategoryFramePreparer', CategoryFramePreparerBase.$);
/**
 * @hidden
 */
export class CategorySeries extends MarkerSeries {
    constructor() {
        super();
        this.na = null;
        this.nn = null;
        this.nr = false;
        this.nq = false;
        this.assigningCategoryStyle = null;
        this.assigningCategoryMarkerStyle = null;
        this.nl = null;
        this.nm = null;
        this.m7 = new CategoryFrame(3);
        this.m9 = new CategoryFrame(3);
        this.m6 = new CategoryFrame(3);
        this.m8 = new CategoryFrame(3);
        this.nd = null;
        this.nh = null;
        this.nd = new CategorySeriesRenderManager();
        this.nh = new CategoryTransitionSourceFramePreparer();
        this.nr = false;
        this.nq = false;
        this.ab = CategorySeries.$;
    }
    bf() {
        let a = new CategorySeriesView(this);
        return a;
    }
    get no() {
        if (this.nn == null) {
            this.nn = DVContainer.instance.createInstance(ICategorySeriesInteractionManager_$type, () => this.b2.n);
        }
        return this.nn;
    }
    ch(a, b, c) {
        if (!this.hasMarkers) {
            return false;
        }
        let d = this.getEffectiveViewport1(this.bi);
        let e = this.fetchXAxis();
        let f = new ScalerParams(1, this.bs.mq, this.lx, e.b8);
        f.c = d;
        let g = this.fetchYAxis();
        let h = new ScalerParams(1, this.bs.mq, this.lx, g.b8);
        h.c = d;
        let i = this.bs.mq;
        let j = this.lx;
        let k = this.currentMode2Index;
        let l = 0;
        if (e.b5 && e.b3) {
            l = e.getSeriesOffset(i, j, d, k, e.categoryMode);
        }
        a.clear();
        this.lz.cc((m) => {
            if (m._visibility == 0) {
                let n = new SeriesPointOfInterest();
                let o = m.n;
                let p = m.o;
                if (o < this.lx.left || o > this.lx.right || p < this.lx.top || p > this.lx.bottom) {
                    return;
                }
                if (e.b2 && !e.b5 && e.categoryMode != 0) {
                    n.b = m.ak;
                }
                else {
                    n.b = e.dy(o, f);
                }
                if (g.b2 && !g.b5 && g.categoryMode != 0) {
                    n.c = m.ak;
                }
                else {
                    n.c = g.dy(p, h);
                }
                n.a = m.content;
                if (b) {
                    n.d = this.n9(n.c, c);
                }
                else {
                    n.d = e.fi(m.ak);
                }
                a.add(n);
            }
        });
        return true;
    }
    n9(a, b) {
        if (b >= 0) {
            return round10N(a, b).toString();
        }
        else {
            return a.toString();
        }
    }
    it(a) {
        super.it(a);
        this.ne = a;
    }
    preferredCategoryMode(a) {
        return 0;
    }
    get categoryAxis() {
        return this.m5();
    }
    m5() {
        return this.fetchXAxis();
    }
    np() {
        return this.fetchYAxis();
    }
    get_cl() {
        return true;
    }
    ac() {
        super.ac();
        this.ne.cn.g(this.eu);
    }
    ny() {
        return (this.assigningCategoryStyle != null && this.nr) || this.cu;
    }
    nz() {
        return (this.assigningCategoryMarkerStyle != null && this.nq) || this.cu;
    }
    om(a) {
        if (this.assigningCategoryStyle != null && this.nr) {
            this.assigningCategoryStyle(this, a);
        }
    }
    ol(a) {
        if (this.assigningCategoryMarkerStyle != null && this.nq) {
            this.assigningCategoryMarkerStyle(this, a);
        }
    }
    mz(a, b) {
        return null;
    }
    hv(a, b) {
        super.hv(a, b);
        if (a) {
            this.og(b);
        }
    }
    a8() {
        let a = super.a8();
        return a;
    }
    ia() {
        super.ia();
        let a = this.fetchXAxis();
        if (a != null) {
            a.g5(false);
        }
        let b = this.fetchYAxis();
        if (b != null) {
            b.g5(false);
        }
    }
    js(a, b) {
        super.js(a, b);
        this.ne.cn.g(this.eu);
        this.jc(false);
    }
    jr(a, b) {
        if (this.dm && this.ez < 0.05 && (this.bs == null || !this.bs.c5())) {
            this.dn = true;
        }
        super.jr(a, b);
        this.ne.cn.g(this.eu);
        this.jc(false);
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case "SeriesViewer":
                let e = this.fetchYAxis();
                let f = this.fetchXAxis();
                if (c != null && d == null) {
                    this.hz(f);
                    this.hz(e);
                }
                if (c == null && d != null) {
                    this.i3(f);
                    this.i3(e);
                }
                this.ne.cn.g(this.eu);
                this.jc(false);
                break;
            case "SyncLink":
                if (this.bn != null && this.bs != null) {
                    this.ne.cn.g(this.eu);
                }
                this.jc(false);
                break;
            case "TransitionProgress":
                this.m9.c(this.ez, this.m7, this.m6);
                if (this.cc(this.bi)) {
                    return;
                }
                if (this.ez == 1) {
                    this.m6.v();
                    this.on(this.m6, this.ne);
                    if (this.dm) {
                        this.dm = false;
                        this.hw();
                        this.bt.r = truncate(this.eq());
                        this.bt.b = this.bu;
                    }
                }
                else {
                    this.on(this.m9, this.ne);
                }
                if (this.bs != null) {
                    this.bs.jj(this);
                }
                break;
            case "ErrorBarSettings":
                this.ij();
                break;
            case CategorySeries.$$p[4]:
                this.jc(false);
                break;
            case CategorySeries.$$p[1]:
                this.nr = this.nt();
                this.jc(false);
                break;
            case CategorySeries.$$p[0]:
                this.nq = this.ns();
                this.jc(false);
                break;
        }
    }
    nt() {
        return this.nw;
    }
    ns() {
        return this.nv;
    }
    n4(a) {
        return this.ed(a, this.fetchXAxis());
    }
    get_c1() {
        return typeCast(ISortingAxis_$type, this.m5()) !== null;
    }
    ap() {
        return this.m5();
    }
    fa(a) {
        return this.no.b$d(this, a);
    }
    fp(a) {
        return this.no.b$f(this, a);
    }
    e8(a) {
        let b = truncate(Math.round(this.eb(a)));
        return b;
    }
    eb(a) {
        return this.no.b$c(this, a);
    }
    get_nu() {
        return false;
    }
    get nu() {
        return this.get_nu();
    }
    au(a, b) {
        let c = this.nk(a, b, this.nm);
        this.nm = c;
        return c;
    }
    get_cv() {
        return true;
    }
    at(a, b) {
        if (this.nu) {
            let c = this.nj(a, b, this.nl);
            this.nl = c;
            return c;
        }
        else {
            let d = this.ni(a, b, this.nl);
            this.nl = d;
            return d;
        }
    }
    n3() {
        return this.ne.cq.a;
    }
    nk(a, b, c) {
        if (!this.l2()) {
            return null;
        }
        let d = this.m6;
        if (this.ca()) {
            d = this.m9;
        }
        let e = this.n3();
        return this.no.b$b(this, e, d.f, a, b, c);
    }
    nj(a, b, c) {
        let d = this.ne.cn.e;
        let e = this.ne.cn.f;
        let f = this.ne.cn.d;
        let g = this.m6;
        if (this.ca()) {
            g = this.m9;
        }
        return this.no.b$a(this, g.f, d, e, f, a, b, c);
    }
    ni(a, b, c) {
        let d = new HighlightingInfo();
        d.b = this;
        d.f = 0;
        d.e = this.bz.count - 1;
        if (c != null && c.f == d.f && c.e == d.e) {
            return c;
        }
        return d;
    }
    oi(a, b, c, d, e, f) {
        let g = this.b9;
        this.nd.ab(a, b, c, d, e, f, g);
        let h = this.nd.b;
        let i = null;
        let j = this.bz;
        if (g && this.bs != null) {
            i = this.bs.az.getHighlightingInfo(this, j, d, h.m, h.l, true);
            h.b = i;
        }
        h.f = f;
        this.ol(h);
        this.nd.z(i, f, g);
    }
    oj(a, b, c, d, e, f) {
        let g = this.b9;
        this.nd.ac(a, b, c, d, e, f, g);
        let h = this.nd.c;
        let i = null;
        let j = this.bz;
        if (g && this.bs != null) {
            i = this.bs.az.getHighlightingInfo(this, j, d, h.m, h.l, false);
            h.b = i;
        }
        h.f = f;
        this.om(h);
        this.nd.aa(i, f, g);
    }
    dw(a, b, c) {
        let d = super.dw(a, b, c);
        d = d && this.n2(this.fetchXAxis());
        d = d && this.n2(this.fetchYAxis());
        let e = c;
        if (!c.l() || b.isEmpty || a.isEmpty || this.bz == null) {
            d = false;
        }
        if (!d) {
            e.cn.d = 0;
        }
        return d;
    }
    n2(a) {
        if (a == null || a.bf == null) {
            return false;
        }
        let b = typeCast(CategoryAxisBase.$, a);
        if (b != null) {
            if (b.itemsSource == null) {
                return false;
            }
            if (b.jx < 1) {
                return false;
            }
        }
        else {
            let c = typeCast(NumericAxisBase.$, a);
            if (c != null) {
                return c.j3 != c.j2;
            }
        }
        return true;
    }
    dc() {
        return this.nx;
    }
    nf() {
        return 12;
    }
    hw() {
        super.hw();
        this.m7.v();
        this.m6.v();
        this.m9.v();
    }
    jd(a) {
        super.jd(a);
        this.ne.cn.g(this.eu);
        if (this.cc(this.bi)) {
            this.m6.y();
            this.m9.y();
            this.m7.y();
            return;
        }
        if (this.de) {
            if (this.ca()) {
                if (this.bt.g) {
                    this.bt.t();
                }
                this.on(this.m9, this.ne);
            }
            else {
                this.on(this.m6, this.ne);
            }
            return;
        }
        if (this.da(a)) {
            let b = this.m7;
            if (this.ca()) {
                if (this.bt.g) {
                    this.bt.t();
                }
                this.m7 = this.m9;
                this.m9 = b;
            }
            else {
                this.m7 = this.m6;
                this.m6 = b;
            }
            this.ok(this.m6, this.ne);
            if (this.dp) {
                this.bt.w();
                this.bt.r = truncate(this.er());
                this.bt.b = this.bv != null ? this.bv : this.bu;
                this.nh.p(this.m7, this.m6, this.isVertical, this.fetchXAxis(), this.fetchYAxis(), this.ng, this.nf(), this.bp, this.bo(), runOn(this, this.n5), this.ne.br);
            }
            this.hs();
            this.jk();
            if (this.dp) {
                this.dn = false;
                this.dm = true;
            }
        }
        else {
            this.ok(this.m6, this.ne);
            this.on(this.m6, this.ne);
        }
    }
    bo() {
        return 3;
    }
    n5() {
        if (this.isVertical) {
            return this.lx.left;
        }
        return this.lx.bottom;
    }
    n8() {
        let a = 0;
        let b = this.fetchXAxis();
        for (let c of fromEnum(this.bs.series)) {
            if (c == this) {
                return a;
            }
            let d = typeCast(CategorySeries.$, c);
            if (d != null) {
                let e = typeCast(CategoryAxisBase.$, d.fetchXAxis());
                if (e == b && d.preferredCategoryMode(e) == 2) {
                    a++;
                }
            }
        }
        return -1;
    }
    get GetErrorBarsXAxis() {
        return this.fetchXAxis();
    }
    get GetErrorBarsYAxis() {
        return this.fetchYAxis();
    }
    oh(a, b) {
        this.nd.w(this, this.nz(), runOn(this, this.mz), this.n6(a), this.n7(a));
        let c = this.nd.b;
        let d = c != null;
        let e = this.m5();
        if (e == null) {
            return;
        }
        let f = this.getEffectiveViewport1(a);
        let g = new ScalerParams(0, a.bs, a.br, e.b8, f);
        let h = this.bz == null ? 0 : this.bz.count;
        let i = a;
        let j = b.f;
        let k = i.cn.e;
        let l = i.cn.f;
        let m = i.cn.d;
        let n = k * m;
        for (let o = 0; o < a.cq.count; o++) {
            let p = a.cq.item(o);
            let q = p.content;
            if (d) {
                let r = p.al;
                this.oi(j, r, h, e, g, a.n);
            }
            this.nd.ad(p, q);
        }
    }
    on(a, b) {
        this.lo = a.aa;
        b.ar();
    }
    ok(a, b) {
        a.u();
    }
    n6(a) {
        return a.cn.d;
    }
    n7(a) {
        return a.cn.e;
    }
    og(a) {
        let b = a;
        b.cq.count = 0;
    }
    je(a, b) {
        super.je(a, b);
        if (!this.dl) {
            this.bi.az(b);
            return;
        }
        let c = typeCast(CategorySeriesView.$, this.bh);
        c.cn.g(this.eu);
        this.bi.az(b);
        if (this.cc(this.bh)) {
            return;
        }
        this.oo();
        this.dl = false;
    }
    oo() {
        let a = typeCast(CategorySeriesView.$, this.bh);
        if (!this.df) {
            this.ok(this.m8, a);
        }
        this.df = false;
        this.on(this.m8, a);
    }
    nb(a) {
        let b = typeCast(CategorySeriesView.$, a);
        if (b != null && b.n) {
            if (b.m) {
                return new CategoryFramePreparer(1, typeCast(IIsCategoryBased_$type, this), typeCast(ISupportsMarkers_$type, b), b, this, b.cn);
            }
            else {
                return new CategoryFramePreparer(1, typeCast(IIsCategoryBased_$type, this), typeCast(ISupportsMarkers_$type, b), this.bs.bn.m, this, b.cn);
            }
        }
        else {
            return this.na;
        }
    }
    am(a) {
        if (this.fetchXAxis() == a) {
            return this.fetchYAxis();
        }
        if (this.fetchYAxis() == a) {
            return this.fetchXAxis();
        }
        return null;
    }
    ag() {
        return [this.fetchXAxis(), this.fetchYAxis()];
    }
    static m0(a, b, c, d, e) {
        let f = null;
        if (b > -1 && !d.isEmpty && !c.isEmpty) {
            let g = a._inner[0][0] < c.left - 2000 ? c.left - 10 : NaN;
            let h = c.bottom + 10;
            let i = a._inner[b][0] > c.right + 2000 ? c.right + 10 : NaN;
            let j = c.top - 10;
            f = new Clipper(1, g, h, i, j, e);
        }
        return f;
    }
}
CategorySeries.$t = markType(CategorySeries, 'CategorySeries', MarkerSeries.$, [IHasCategoryModePreference_$type, ISupportsErrorBars_$type]);
Type.dep(DependencyProperty, PropertyMetadata, CategorySeries, 'raisePropertyChanged', ['IsCustomCategoryMarkerStyleAllowed:nv:op', [0, false], 'IsCustomCategoryStyleAllowed:nw:oq', [0, false], 'IsTransitionInEnabled:nx:or', [0, false], 'TransitionInMode:ng:os', [CategoryTransitionInMode_$type, enumGetBox(CategoryTransitionInMode_$type, 0)], 'UseHighMarkerFidelity:n1:ot', [0, false]]);
/**
 * @hidden
 */
export class CategorySeriesView extends MarkerSeriesView {
    constructor(a) {
        super(a);
        this.cp = null;
        this.cs = 0;
        this.cn = null;
        this.cq = null;
        this.cs = -1;
        this.cp = a;
        this.cn = this.co();
        this.cq = ((() => {
            let $ret = new Pool$1(Marker.$);
            $ret.create = runOn(this, this.bx);
            $ret.activate = runOn(this, this.cg);
            $ret.disactivate = runOn(this, this.ci);
            $ret.destroy = runOn(this, this.ch);
            return $ret;
        })());
    }
    cr(a) {
        if (this.cs != a.t) {
            return true;
        }
        return false;
    }
    cu(a) {
        this.cs = a.t;
    }
    updateMarkerTemplate(a, b, c) {
        if (!this.by.l4) {
            let d = this.cq.item(a);
            let e = d.content;
            e.item = this.e.bz.item(b);
            d.ak = b;
            d.al = c;
        }
    }
    co() {
        return new CategoryBucketCalculator(this);
    }
    get shouldDisplayMarkers() {
        return this.cp.l2();
    }
    updateMarkerCount(a) {
        this.cq.count = a;
    }
    cc(a) {
        this.cq.c(a);
    }
    ct() {
    }
}
CategorySeriesView.$t = markType(CategorySeriesView, 'CategorySeriesView', MarkerSeriesView.$, [ISupportsMarkers_$type]);
