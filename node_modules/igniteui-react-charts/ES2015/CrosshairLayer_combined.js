/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnnotationLayer } from "./AnnotationLayer";
import { Brush } from "igniteui-react-core/ES2015/Brush";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { Series } from "./Series";
import { Thickness } from "igniteui-react-core/ES2015/Thickness";
import { Visibility_$type } from "igniteui-react-core/ES2015/Visibility";
import { CrosshairLayerFrame } from "./CrosshairLayerFrame";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { Axis } from "./Axis";
import { Dictionary$2 } from "igniteui-react-core/ES2015/Dictionary$2";
import { Pool$1 } from "igniteui-react-core/ES2015/Pool$1";
import { AxisAnnotation } from "./AxisAnnotation";
import { Type, Number_$type, enumGetBox, fromEnum, Point_$type, markType, runOn } from "igniteui-react-core/ES2015/type";
import { AxisAnnotationFrameManager } from "./AxisAnnotationFrameManager";
import { Tuple$2 } from "igniteui-react-core/ES2015/Tuple$2";
import { Path } from "igniteui-react-core/ES2015/Path";
import { PathGeometry } from "igniteui-react-core/ES2015/PathGeometry";
import { PathFigure } from "igniteui-react-core/ES2015/PathFigure";
import { LineSegment } from "igniteui-react-core/ES2015/LineSegment";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { isNaN_ } from "igniteui-react-core/ES2015/number";
import { AnnotationLayerView } from "./AnnotationLayerView";
import { TranslateTransform } from "igniteui-react-core/ES2015/TranslateTransform";
import { LineGeometry } from "igniteui-react-core/ES2015/LineGeometry";
import { BrushUtil } from "igniteui-react-core/ES2015/BrushUtil";
/**
 * @hidden
 */
export class CrosshairLayer extends AnnotationLayer {
    constructor() {
        super();
        this.xAxisAnnotationFormatLabel = null;
        this.yAxisAnnotationFormatLabel = null;
        this.nd = null;
        this.nc = null;
        let a = new CrosshairLayerFrame();
        let b = new CrosshairLayerFrame();
        let c = new CrosshairLayerFrame();
        let d = this.fi / 1000;
        this.l1 = a;
        this.l0 = b;
        this.l2 = c;
        this.ab = CrosshairLayer.$;
    }
    bf() {
        return new CrosshairLayerView(this);
    }
    it(a) {
        super.it(a);
        this.m5 = a;
    }
    m7() {
        return this.xAxisAnnotationFormatLabel != null;
    }
    m8() {
        return this.yAxisAnnotationFormatLabel != null;
    }
    get ph() {
        return new Thickness(1, this.nf, this.nh, this.ng, this.ne);
    }
    get pi() {
        return new Thickness(1, this.nk, this.nm, this.nl, this.nj);
    }
    mk(a, b) {
        if (this.m6 == null || this.m6 == a) {
            if (!this.aq.c) {
                this.jc(b);
            }
        }
    }
    mm(a, b) {
        super.mm(a, b);
        let c = a;
        let d = this.nb;
        let e = this.na;
        c.ad.clear();
        c.ae.clear();
        c.ac.clear();
        c.af.clear();
        AxisAnnotationFrameManager.b(c);
        if (this.l7(this.m6)) {
            this.oh(this.m6, c, d, e);
        }
        else {
            for (let f of fromEnum(this.bs.series)) {
                if (this.l7(f)) {
                    this.oh(f, c, d, e);
                }
            }
        }
    }
    l7(a) {
        if (!super.l7(a)) {
            return false;
        }
        let b = this.mf(a);
        if (!b.c) {
            return false;
        }
        return true;
    }
    im() {
        super.im();
        if (!this.aq.c && !this.ca()) {
            return;
        }
        if (this.ca()) {
            this.oi(this.l2, false);
        }
        else {
            this.oi(this.l0, false);
        }
    }
    oh(a, b, c, d) {
        let e = this.mf(a);
        if (!e.c) {
            return;
        }
        let f = e.d;
        f = a.lk(f, c, d);
        let g = this.k2;
        if (g == null) {
            g = this.k4;
        }
        if (g == null) {
            g = a.k2;
            if (g != null) {
                g = this.m5.b8(g);
            }
        }
        let h = g;
        let i = g;
        if (this.o9 != null) {
            h = this.o9;
        }
        if (this.pa != null) {
            i = this.pa;
        }
        b.ac.add(h);
        b.af.add(i);
        b.ad.add(f.y);
        b.ae.add(f.x);
        if (this.m9) {
            AxisAnnotationFrameManager.c(b, f, a, this.bs, this.getEffectiveViewport(), g, this.pb, this.pd, this.pc, this.ph, this.ni, this.pe, this.pg, this.pf, this.pi, this.nn, this.pk == 0, this.pj == 0);
        }
    }
    oi(a, b) {
        let c = false;
        if (this.nc == null) {
            c = true;
            this.nd = new List$1(Axis.$, 0);
            this.nc = new Dictionary$2(Axis.$, Pool$1.$.specialize(AxisAnnotation.$), 0);
        }
        AxisAnnotationFrameManager.d(this, a, c, this.nc, this.nd, b, this.no, this.np, this.xAxisAnnotationFormatLabel, this.yAxisAnnotationFormatLabel);
    }
    og(a, b, c, d, e) {
        let f = a.item(b);
        b++;
        if (e) {
            f._stroke = d.af._inner[c];
            f._fill = d.af._inner[c];
        }
        else {
            f._stroke = d.ac._inner[c];
            f._fill = d.ac._inner[c];
        }
        f.ac = this.ey;
        f.ai = this.la;
        f.ad = this.lb;
        return new Tuple$2(Path.$, Number_$type, f, b);
    }
    mp(a, b) {
        super.mp(a, b);
        let c = this.m5.b2;
        let d = a;
        let e = d.ad.count;
        let f = 0;
        let g = b.br.left;
        let h = b.br.right;
        let i = b.br.top;
        let j = b.br.bottom;
        let k = this.pk == 0;
        let l = this.pj == 0;
        for (let m = 0; m < e; m++) {
            let n = Math.floor(d.ad._inner[m]);
            let o = Math.floor(d.ae._inner[m]);
            let p = null;
            if (k) {
                if (isNaN_(n)) {
                    continue;
                }
                let q = this.og(c, f, m, d, true);
                p = q.c;
                f = q.d;
                let r = new PathGeometry();
                let s = new PathFigure();
                s._startPoint = { $type: Point_$type, x: o, y: i };
                let t = new LineSegment(1);
                t.c = { $type: Point_$type, x: o, y: j };
                s._segments.add(t);
                r.b.add(s);
                p.aj = r;
            }
            if (l) {
                if (isNaN_(n)) {
                    continue;
                }
                let u = this.og(c, f, m, d, false);
                p = u.c;
                f = u.d;
                let v = new PathGeometry();
                let w = new PathFigure();
                w._startPoint = { $type: Point_$type, x: g, y: n };
                let x = new LineSegment(1);
                x.c = { $type: Point_$type, x: h, y: n };
                w._segments.add(x);
                v.b.add(w);
                p.aj = v;
            }
        }
        c.count = f;
        if (this.ca()) {
            this.oi(this.l2, true);
        }
        else {
            this.oi(this.l0, false);
        }
    }
    c8() {
        return true;
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case CrosshairLayer.$$p[1]:
                this.jc(true);
                break;
            case CrosshairLayer.$$p[7]:
                this.jc(true);
                break;
            case CrosshairLayer.$$p[4]:
                this.jc(true);
                break;
            case CrosshairLayer.$$p[2]:
            case CrosshairLayer.$$p[8]:
            case CrosshairLayer.$$p[10]:
            case CrosshairLayer.$$p[12]:
            case CrosshairLayer.$$p[14]:
            case CrosshairLayer.$$p[13]:
            case CrosshairLayer.$$p[11]:
            case CrosshairLayer.$$p[15]:
            case CrosshairLayer.$$p[16]:
            case CrosshairLayer.$$p[17]:
            case CrosshairLayer.$$p[19]:
            case CrosshairLayer.$$p[21]:
            case CrosshairLayer.$$p[23]:
            case CrosshairLayer.$$p[22]:
            case CrosshairLayer.$$p[20]:
            case CrosshairLayer.$$p[24]:
            case CrosshairLayer.$$p[25]:
            case CrosshairLayer.$$p[0]:
            case CrosshairLayer.$$p[6]:
            case CrosshairLayer.$$p[5]:
                this.jc(true);
                break;
        }
    }
}
CrosshairLayer.$t = markType(CrosshairLayer, 'CrosshairLayer', AnnotationLayer.$);
Type.dep(DependencyProperty, PropertyMetadata, CrosshairLayer, 'raisePropertyChanged', ['HorizontalLineStroke:o9:oj', [Brush.$, null], 'HorizontalLineVisibility:pj:ok', [Visibility_$type, enumGetBox(Visibility_$type, 0)], 'IsAxisAnnotationEnabled:m9:ol', [0, false], 'SkipUnknownValues:na:om', [0, true], 'TargetSeries:m6:on', [Series.$, null], 'UseInterpolation:nb:oo', [0, true], 'VerticalLineStroke:pa:op', [Brush.$, null], 'VerticalLineVisibility:pk:oq', [Visibility_$type, enumGetBox(Visibility_$type, 0)], 'XAxisAnnotationBackground:pb:or', [Brush.$, null], 'XAxisAnnotationInterpolatedValuePrecision:no:os', [1, -1], 'XAxisAnnotationOutline:pc:ot', [Brush.$, null], 'XAxisAnnotationPaddingBottom:ne:ou', [1, NaN], 'XAxisAnnotationPaddingLeft:nf:ov', [1, NaN], 'XAxisAnnotationPaddingRight:ng:ow', [1, NaN], 'XAxisAnnotationPaddingTop:nh:ox', [1, NaN], 'XAxisAnnotationStrokeThickness:ni:oy', [1, NaN], 'XAxisAnnotationTextColor:pd:oz', [Brush.$, null], 'YAxisAnnotationBackground:pe:o0', [Brush.$, null], 'YAxisAnnotationInterpolatedValuePrecision:np:o1', [1, -1], 'YAxisAnnotationOutline:pf:o2', [Brush.$, null], 'YAxisAnnotationPaddingBottom:nj:o3', [1, NaN], 'YAxisAnnotationPaddingLeft:nk:o4', [1, NaN], 'YAxisAnnotationPaddingRight:nl:o5', [1, NaN], 'YAxisAnnotationPaddingTop:nm:o6', [1, NaN], 'YAxisAnnotationStrokeThickness:nn:o7', [1, NaN], 'YAxisAnnotationTextColor:pg:o8', [Brush.$, null]]);
/**
 * @hidden
 */
export class CrosshairLayerView extends AnnotationLayerView {
    constructor(a) {
        super(a);
        this.b1 = null;
        this.b2 = null;
        this.b3 = null;
        this.b1 = a;
        this.b3 = new List$1(Path.$, 0);
    }
    ap() {
        super.ap();
        this.b2 = ((() => {
            let $ret = new Pool$1(Path.$);
            $ret.create = runOn(this, this.b9);
            $ret.activate = runOn(this, this.b4);
            $ret.disactivate = runOn(this, this.b6);
            $ret.destroy = runOn(this, this.b5);
            return $ret;
        })());
    }
    b9() {
        let a = new Path();
        a.j = new TranslateTransform();
        this.b3.add(a);
        return a;
    }
    b4(a) {
        a._visibility = 0;
    }
    b6(a) {
        a._visibility = 1;
    }
    b5(a) {
        this.b3.remove(a);
    }
    b7(a, b, c, d) {
        if (a.aj == null || a.aj.b.x != d || a.aj.c.x != c) {
            let e = ((() => {
                let $ret = new LineGeometry();
                $ret.c = { $type: Point_$type, x: c, y: b };
                $ret.b = { $type: Point_$type, x: d, y: b };
                return $ret;
            })());
            a.aj = e;
        }
    }
    b8(a) {
        if (a == null) {
            return a;
        }
        return BrushUtil.h(a, 0.1);
    }
    a3(a, b) {
        super.a3(a, b);
        if (a.d && !b) {
            for (let c = 0; c < this.b3.count; c++) {
                let d = this.b3._inner[c];
                if (d._visibility == 0) {
                    a.s(d);
                }
            }
        }
    }
    ai(a) {
        super.ai(a);
        for (let b = 0; b < this.b3.count; b++) {
            this.e.a2.exportPathData(a, this.b3._inner[b], "crosshairLine", ["Main", "Crosshair"]);
        }
    }
}
CrosshairLayerView.$t = markType(CrosshairLayerView, 'CrosshairLayerView', AnnotationLayerView.$);
