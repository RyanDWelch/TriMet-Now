/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { ScatterBase } from "./ScatterBase";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { Type, Point_$type, typeCast, markType } from "igniteui-react-core/ES2015/type";
import { ScatterFrame } from "./ScatterFrame";
import { ScatterSplineSeriesView } from "./ScatterSplineSeriesView";
import { Clipper } from "igniteui-react-core/ES2015/Clipper";
import { OwnedPoint } from "./OwnedPoint";
import { ScalerParams } from "./ScalerParams";
import { PathGeometry } from "igniteui-react-core/ES2015/PathGeometry";
import { Numeric } from "igniteui-react-core/ES2015/Numeric";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
/**
 * @hidden
 */
export class ScatterSplineSeries extends ScatterBase {
    constructor() {
        super();
        this.ab = ScatterSplineSeries.$;
        this.m8 = new ScatterFrame();
        this.na = new ScatterFrame();
        this.m7 = new ScatterFrame();
    }
    bf() {
        return new ScatterSplineSeriesView(this);
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case ScatterSplineSeries.$$p[0]:
                this.jc(false);
                this.ij();
                break;
        }
    }
    bd() {
        if (this.be == 0) {
            return 2;
        }
        else {
            return super.bd();
        }
    }
    n1(a, b) {
        super.n1(a, b);
        a.m.clear();
        a.u.clear();
        let c = b.bs;
        let d = b.br;
        let e = this.getEffectiveViewport1(b);
        let f = this.eu * this.eu;
        let g = Math.min(this.nc != null ? this.nc.count : 0, this.ne != null ? this.ne.count : 0);
        let h = new ScalerParams(0, c, d, this.m3.d, e);
        let i = ((() => {
            let $ret = new ScalerParams(0, c, d, this.m3.e, e);
            $ret.b = this.eh();
            return $ret;
        })());
        let j = (k) => this.m3.a.dv(this.nc.item(k), h);
        let k = (l) => this.m3.b.dv(this.ne.item(l), i);
        let l = ((() => {
            let $ret = new Clipper(0, d, false);
            $ret.i = a.m;
            return $ret;
        })());
        for (let m = 0; m < g;) {
            let n = m;
            ++m;
            while (m < g && this.ow(j, k, n, m) < f) {
                ++m;
            }
            if (g > this.nj) {
                l.j(this.o0(j, k, n, m - 1));
            }
            else {
                let o = new OwnedPoint();
                o.c = { $type: Point_$type, x: j(n), y: k(n) };
                o.a = this.bz.item(n);
                if (!a.u.containsKey(o.a)) {
                    a.u.addItem(o.a, o);
                }
            }
        }
        if (g > this.nj) {
            l.i = null;
        }
    }
    o0(a, b, c, d) {
        if (c == d) {
            return { $type: Point_$type, x: a(c), y: b(c) };
        }
        let e = 0;
        let f = 0;
        let g = (d - c + 1);
        for (let h = c; h <= d; ++h) {
            e += a(h);
            f += b(h);
        }
        return { $type: Point_$type, x: e / g, y: f / g };
    }
    ow(a, b, c, d) {
        let e = a(d) - a(c);
        let f = b(d) - b(c);
        return e * e + f * f;
    }
    hv(a, b) {
        super.hv(a, b);
        let c = typeCast(ScatterSplineSeriesView.$, b);
        c.c0(false);
    }
    oa(a, b) {
        this.hv(false, b);
        super.oa(a, b);
        this.n4(a);
        let c = typeCast(ScatterSplineSeriesView.$, b);
        c.da.aj = new PathGeometry();
        c.da.aj.b = Numeric.h(a.m.count, (d) => a.m._inner[d].x, (d) => a.m._inner[d].y, this.ox);
    }
}
ScatterSplineSeries.$t = markType(ScatterSplineSeries, 'ScatterSplineSeries', ScatterBase.$);
Type.dep(DependencyProperty, PropertyMetadata, ScatterSplineSeries, 'raisePropertyChanged', ['Stiffness:ox:oz', [1, 0.5]]);
