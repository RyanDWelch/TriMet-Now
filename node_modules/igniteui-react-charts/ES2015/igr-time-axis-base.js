import { IgrCategoryAxisBase } from "./igr-category-axis-base";
import { ensureBool } from "igniteui-react-core/ES2015/componentUtil";
/**
 * Represents an category-based horizontal X axis that uses a DateTime scale.
*
* Represents horizontal axis that uses a DateTime scale.
*
* ```ts
*   <IgrDataChart
*     dataSource={this.state.dataSource}
*     width="700px"
*     height="500px">
*     <IgrTimeXAxis name="xAxis" label="Date"
* 			dateTimeMemberPath="Date" />
*  </IgrDataChart>
* ```
*/
export class IgrTimeAxisBase extends IgrCategoryAxisBase {
    constructor(props) {
        super(props);
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the DateTime mapping property for the axis.
    *
    * Use `dateTimeMemberPath` property for DateTime mapping with the axis.
    *
    * ```ts
    *   <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *     <IgrTimeXAxis name="xAxis" label="Date"
    * 			dateTimeMemberPath="Date" />
    *  </IgrDataChart>
    * ```
    */
    get dateTimeMemberPath() {
        return this.i.dateTimeMemberPath;
    }
    set dateTimeMemberPath(v) {
        this.i.dateTimeMemberPath = v;
    }
    /**
     * Gets or sets whether the data assigned to the date time axis should be considered pre-sorted by date/time.
    *
    * Use `isDataPreSorted` property to decide if the data assigned to the date time axis should be considered pre-sorted by date/time.
    */
    get isDataPreSorted() {
        return this.i.k1;
    }
    set isDataPreSorted(v) {
        this.i.k1 = ensureBool(v);
    }
    /**
     * Gets the coerced minimum value.
    *
    * Use `actualMinimumValue` to get the coerced maximum value.
    */
    get actualMinimumValue() {
        return this.i.actualMinimumValue;
    }
    set actualMinimumValue(v) {
        this.i.actualMinimumValue = v;
    }
    /**
     * Gets the coerced maximum value.
    *
    * Use `actualMaximumValue` to get the  coerced maximum value
    */
    get actualMaximumValue() {
        return this.i.actualMaximumValue;
    }
    set actualMaximumValue(v) {
        this.i.actualMaximumValue = v;
    }
    /**
     * Gets or sets the axis MinimumValue.
    *
    * Use `minimumValue` property for axis minimum value.
    */
    get minimumValue() {
        return this.i.minimumValue;
    }
    set minimumValue(v) {
        this.i.minimumValue = v;
    }
    /**
     * Gets or sets the axis MaximumValue.
    *
    * Use `maximumValue` property for axis maximum value.
    */
    get maximumValue() {
        return this.i.maximumValue;
    }
    set maximumValue(v) {
        this.i.maximumValue = v;
    }
    /**
     * Checks if the axis is of date time axis type
    *
    * Use `isDateTime` property to Checks if the axis is of date time axis type.
    */
    get isDateTime() {
        return this.i.b5;
    }
    /**
     * Checks if axis requires sorting of items
    *
    * Use `isSorting` property to Checks if axis requires sorting of items.
    */
    get isSorting() {
        return this.i.cc;
    }
    getItemValue(item, memberPathName) {
        let iv = this.i.e3(item, memberPathName);
        return (iv);
    }
    /**
     * Gets the index of the data item with the value nearest the given value.
    
    * @param unscaledValue  * The value to find a value close to.
    */
    getIndexClosestToUnscaledValue(unscaledValue) {
        let iv = this.i.i$f(unscaledValue);
        return (iv);
    }
    /**
     * Updates the axis when the data has been changed.
    
    *
    * Updates the axis when the data has been changed. ?
    */
    notifyDataChanged() {
        this.i.i$i();
    }
}
