/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { FastItemDateTimeColumn } from "igniteui-react-core/ES2015/FastItemDateTimeColumn";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { ISortingAxis_$type } from "./ISortingAxis";
import { IDateTimeAxis_$type } from "./IDateTimeAxis";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { Type, typeCast, Number_$type, Date_$type, fromEnum, runOn, delegateRemove, delegateCombine, markType, TypeRegistrar } from "igniteui-react-core/ES2015/type";
import { ScalerParams } from "./ScalerParams";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { NumericScaler } from "./NumericScaler";
import { SeriesViewer } from "./SeriesViewer";
import { SortedListView$1 } from "./SortedListView$1";
import { ArrayExtension } from "igniteui-react-core/ES2015/ArrayExtension";
import { AxisRangeChangedEventArgs } from "./AxisRangeChangedEventArgs";
import { IFastItemsSource_$type } from "igniteui-react-core/ES2015/IFastItemsSource";
import { HorizontalAxisLabelPanel } from "./HorizontalAxisLabelPanel";
import { MathUtil } from "igniteui-react-core/ES2015/MathUtil";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { truncate, isNaN_ } from "igniteui-react-core/ES2015/number";
import { dateMinValue, dateSubtract, dateAdd, dateMaxValue, dateFromTicks } from "igniteui-react-core/ES2015/date";
/**
 * @hidden
 */
export class TimeAxisBase extends CategoryAxisBase {
    constructor() {
        super();
        this.kv = null;
        this.k4 = null;
        this.kz = false;
        this.k7 = dateMaxValue();
        this.k6 = dateMinValue();
        FastItemDateTimeColumn.o();
    }
    dv(a, b) {
        if (!b.c.isEmpty) {
            let c = this.lc(a, NumericScaler.ac, b.c, Rect.empty);
            c = (c - b.d.left) / b.d.width;
            c = b.d.left + b.d.width * (c - b.e.left) / b.e.width;
            return c;
        }
        return this.lc(a, b.e, b.d, b.c);
    }
    e3(a, b) {
        let c = this.fu(b);
        if (c == this.dateTimeMemberPath) {
            return this.e4(a, b, this.dateTimeMemberPath);
        }
        return super.e3(a, b);
    }
    lc(a, b, c, d) {
        let e;
        if (+(this.actualMaximumValue) == +(this.actualMinimumValue)) {
            e = -1;
        }
        else {
            e = (a - this.actualMinimumValue.getTime()) / (this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime());
        }
        let f = 0;
        if (this.categoryMode == 2) {
            f = this.getGroupCenter(0, b, c, d);
        }
        if (this.b8) {
            e = 1 - e;
            f = -f;
        }
        return c.left + c.width * (e - b.left) / b.width - f;
    }
    ld(a, b, c) {
        let d;
        if (+(this.actualMaximumValue) == +(this.actualMinimumValue)) {
            d = -1;
        }
        else {
            d = (a - this.actualMinimumValue.getTime()) / (this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime());
        }
        let e = 0;
        if (this.b8) {
            d = 1 - d;
            e = -e;
        }
        return c.left + c.width * (d - b.left) / b.width - e;
    }
    dy(a, b) {
        if (!b.c.isEmpty) {
            let c = b.d.left;
            let d = b.d.width;
            if (this.categoryMode != 0) {
                let e = this.getCategorySize(b.e, b.d, b.c);
                c += e / 2;
                d -= e;
            }
            let f = b.e.left + b.e.width * (a - c) / this.width;
            f = (f * b.d.width) + b.d.left;
            f = this.getUnscaledValue3(f, NumericScaler.ac, b.c, this.categoryMode);
            return f;
        }
        return this.getUnscaledValue3(a, b.e, b.d, this.categoryMode);
    }
    getUnscaledValue3(a, b, c, d) {
        let e = b.left + b.width * (a - c.left) / c.width;
        if (this.b8) {
            e = 1 - e;
        }
        return truncate(Math.floor(this.actualMinimumValue.getTime() + e * (this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime())));
    }
    i$h() {
        this.ls();
    }
    ls() {
        let a = this.bf != null ? this.bf.mq : Rect.empty;
        let b = !a.isEmpty ? this.i0 : Rect.empty;
        let c = (new Date());
        let d = (new Date());
        let e = false;
        if (!a.isEmpty && !b.isEmpty && this.kw != null) {
            let f = typeCast(FastItemDateTimeColumn.$, this.kw);
            if (f != null) {
                if (this.k5 == null) {
                    this.lt();
                }
            }
            else {
                this.k5 = null;
            }
            if (this.kw.count > 0) {
                e = true;
                let g = this.k5 == null ? 0 : this.k5._inner[0];
                let h = this.k5 == null ? this.kw.count - 1 : this.k5._inner[this.kw.count - 1];
                c = this.kw.item(g);
                d = this.kw.item(h);
                this.k0 = false;
                if (this.categoryMode == 2) {
                    let i = this.lq(c, d);
                    if (+c != +(dateMinValue())) {
                        c = dateSubtract(+c, +i);
                    }
                    d = dateAdd(+d, +i);
                }
            }
        }
        if (this.k3()) {
            e = true;
            c = this.minimumValue;
        }
        if (this.k2()) {
            e = true;
            d = this.maximumValue;
        }
        let j = +(this.actualMinimumValue) != +c || +(this.actualMaximumValue) != +d;
        if (e && j) {
            let k = this.actualMinimumValue;
            let l = this.actualMaximumValue;
            this.actualMinimumValue = c;
            this.actualMaximumValue = d;
            this.lx();
        }
    }
    lx() {
    }
    get kw() {
        return this.kv;
    }
    set kw(a) {
        if (this.kv != a) {
            let b = this.kv;
            this.kv = a;
            this.gz("DateTimeColumn", b, this.kv);
        }
    }
    get k5() {
        return this.k4;
    }
    set k5(a) {
        this.k4 = a;
    }
    get i$b() {
        if (this.k5 == null) {
            let a = typeCast(FastItemDateTimeColumn.$, this.kw);
            if (a != null) {
                this.lt();
            }
            else {
                this.k5 = null;
            }
        }
        return this.k5;
    }
    lt() {
        if (this.k1) {
            this.k5 = new List$1(Number_$type, 0);
            let a = this.k5;
            let b = this.kw.count;
            for (let c = 0; c < b; c++) {
                a.add(c);
            }
        }
        else {
            let d = typeCast(FastItemDateTimeColumn.$, this.kw);
            this.k5 = d.h();
        }
    }
    i$e(a, b, c, d) {
        return this.lf(a, b, c, d);
    }
    lf(a, b, c, d) {
        if (b.isEmpty) {
            return -1;
        }
        let e = d;
        let f = new ScalerParams(0, a, b, this.b8, c);
        let g, h;
        if (this.b8) {
            h = this.dy(e.left, f);
            g = this.dy(e.right, f);
        }
        else {
            g = this.dy(e.left, f);
            h = this.dy(e.right, f);
        }
        let i = Math.max(dateMinValue().getTime(), Math.min(dateMaxValue().getTime(), truncate(g)));
        return this.le(dateFromTicks(i));
    }
    le(a) {
        if (this.kw == null || this.k5.count != this.kw.count) {
            return -1;
        }
        for (let b = 0; b < this.k5.count; b++) {
            let c = this.kw.item(this.k5._inner[b]);
            if (c >= a) {
                return Math.max(b - 1, 0);
            }
        }
        return this.k5.count - 1;
    }
    i$g(a, b, c, d) {
        return this.li(a, b, c, d);
    }
    li(a, b, c, d) {
        if (b.isEmpty) {
            return -1;
        }
        let e = d;
        let f = new ScalerParams(0, a, b, this.b8, c);
        let g, h;
        if (this.b8) {
            h = this.dy(e.left, f);
            g = this.dy(e.right, f);
        }
        else {
            g = this.dy(e.left, f);
            h = this.dy(e.right, f);
        }
        let i = Math.max(dateMinValue().getTime(), Math.min(dateMaxValue().getTime(), truncate(h)));
        return this.lh(dateFromTicks(i));
    }
    lh(a) {
        if (this.kw == null || this.k5.count != this.kw.count) {
            return -1;
        }
        for (let b = this.k5.count - 1; b >= 0; b--) {
            let c = this.k5._inner[b];
            let d = this.kw.item(c);
            if (d < a) {
                return b == this.k5.count - 1 ? b : b + 1;
            }
        }
        return 0;
    }
    i$d(a) {
        if (this.kw == null) {
            return NaN;
        }
        let b = this.kv.item(a);
        let c = b.getTime();
        let d = c;
        return d;
    }
    i$c(a) {
        let b = this;
        if (b.i$b == null) {
            return -1;
        }
        let c = new SortedListView$1(Date_$type, this.kw, b.i$b);
        let ticks_ = a;
        let d = (new Date(ticks_));
        let e = this.lg(d, c);
        if (e >= 0 && e < b.i$b.count && e - 1 >= 0 && e - 1 < b.i$b.count) {
            let diff1_ = d.getTime() - c.item(e - 1).getTime();
            let diff2_ = c.item(e).getTime() - d.getTime();
            let f = e - 1;
            let g = e;
            if (f < 0 && g >= 0) {
                return g;
            }
            if (g > b.i$b.count - 1 && f < b.i$b.count) {
                return f;
            }
            if (f < 0 && g < 0) {
                return -1;
            }
            if (f > b.i$b.count - 1 && g > b.i$b.count - 1) {
                return -1;
            }
            let h = diff1_ / (diff1_ + diff2_);
            if (isNaN_(h)) {
                h = 0;
            }
            return f + h;
        }
        if (e >= 0 && e < b.i$b.count) {
            return e;
        }
        let i = this.iv();
        if (e == b.i$b.count && this.bf != null && this.dv(a, new ScalerParams(0, this.bf.mq, this.i0, this.b8, i)) < (this.i0.right + 2)) {
            return e - 1;
        }
        if (e == -1 && this.bf != null && Math.abs(this.dv(a, new ScalerParams(0, this.bf.mq, this.i0, this.b8, i)) - this.i0.left) < 2) {
            return 0;
        }
        return -1;
    }
    lg(a, b) {
        let c = this;
        if (this.kw == null || c.i$b == null) {
            return -1;
        }
        let d = -1;
        let e = ArrayExtension.binarySearch$11(Date_$type, b, (f) => {
            if (a < f) {
                return -1;
            }
            if (a > f) {
                return 1;
            }
            return 0;
        });
        if (e >= 0) {
            d = e;
        }
        else {
            d = ~e;
        }
        while (d >= 0 && d < b.count && d - 1 >= 0 && +(b.item(d)) == +(b.item(d - 1))) {
            d--;
        }
        return d;
    }
    i$f(a) {
        let b = this;
        if (b.i$b == null || this.kw == null || b.i$b.count != this.kw.count) {
            return -1;
        }
        let c = new SortedListView$1(Date_$type, this.kw, b.i$b);
        let ticks_ = a;
        let d = (new Date(ticks_));
        let e = this.lg(d, c);
        let f = this.iv();
        if (e >= 0 && e < b.i$b.count && e - 1 >= 0 && e - 1 < b.i$b.count) {
            let g = +d - +(c.item(e - 1));
            let h = +(c.item(e)) - +d;
            if (g < h) {
                e = e - 1;
            }
        }
        if (e >= 0 && e < b.i$b.count) {
            return b.i$b._inner[e];
        }
        if (e == b.i$b.count && this.bf != null && this.dv(a, new ScalerParams(0, this.bf.mq, this.i0, this.b8, f)) < (this.i0.right + 2)) {
            return e - 1;
        }
        if (e == -1 && this.bf != null && Math.abs(this.dv(a, new ScalerParams(0, this.bf.mq, this.i0, this.b8, f)) - this.i0.left) < 2) {
            return 0;
        }
        return -1;
    }
    i$i() {
        this.k5 = null;
        this.g4();
    }
    get_k0() {
        return this.kz;
    }
    set_k0(a) {
        this.kz = a;
    }
    get k0() {
        return this.get_k0();
    }
    set k0(a) {
        this.set_k0(a);
    }
    gv(a) {
        super.gv(a);
        this.dateTimeMemberPath = a;
    }
    gy(a) {
        super.gy(a);
        this.minimumValue = a;
    }
    gx(a) {
        super.gy(a);
        this.maximumValue = a;
    }
    cm() {
        if (this.cf && this.cn) {
            this.a9 = this.a8();
        }
        let a = this.actualMinimumValue.getTime();
        let b = this.actualMaximumValue.getTime();
        this.ls();
        let c = !this.k3() ? this.actualMinimumValue.getTime() : this.minimumValue.getTime();
        let d = !this.k2() ? this.actualMaximumValue.getTime() : this.maximumValue.getTime();
        let e = new AxisRangeChangedEventArgs(0, a, c, b, d);
        this.g0(e);
        return true;
    }
    k3() {
        if (+(this.minimumValue) == +(dateMinValue())) {
            return false;
        }
        return (this.minimumValue != null);
    }
    k2() {
        if (+(this.maximumValue) == +(dateMaxValue())) {
            return false;
        }
        return (this.maximumValue != null);
    }
    get actualMinimumValue() {
        return this.k7;
    }
    set actualMinimumValue(a) {
        let b = +(this.k7) != +a;
        if (b) {
            let c = this.k7;
            this.k7 = a;
            this.gz("ActualMinimumValue", c, a);
        }
    }
    e8() {
        return this.actualMinimumValue;
    }
    get actualMaximumValue() {
        return this.k6;
    }
    set actualMaximumValue(a) {
        let b = +(this.k6) != +a;
        if (b) {
            let c = this.k6;
            this.k6 = a;
            this.gz("ActualMaximumValue", c, a);
        }
    }
    e7() {
        return this.maximumValue;
    }
    lu(a) {
        this.g6(a);
        if (this.je == null) {
            return;
        }
        for (let b of fromEnum(this.ct())) {
            b.jc(a);
        }
    }
    gt(a, b, c, d) {
        super.gt(a, b, c, d);
        switch (b) {
            case "FastItemsSource":
                let e = typeCast(IFastItemsSource_$type, c);
                if (e != null) {
                    e.deregisterColumn(this.kw);
                    this.kw = null;
                    e.event = delegateRemove(e.event, runOn(this, this.lr));
                }
                let f = typeCast(IFastItemsSource_$type, d);
                if (f != null) {
                    this.k5 = null;
                    this.kw = this.kx(this.dateTimeMemberPath);
                    f.event = delegateCombine(f.event, runOn(this, this.lr));
                }
                this.lu(false);
                break;
            case TimeAxisBase.$$p[0]:
                if (this.je != null) {
                    this.je.deregisterColumn(this.kw);
                    this.kw = this.kx(this.dateTimeMemberPath);
                    this.k5 = null;
                }
                break;
            case TimeAxisBase.$$p[3]:
                this.ck();
                this.lu(false);
                break;
            case TimeAxisBase.$$p[2]:
                this.ck();
                this.lu(false);
                break;
            case "DateTimeColumn":
                this.ls();
                break;
        }
    }
    lr(a, b) {
        this.k5 = null;
    }
    kx(a) {
        return TimeAxisBase.ky(a, this);
    }
    static ky(a, b) {
        if (a == null) {
            return b.je.registerColumnDateTime(null, null, false);
        }
        let c = null;
        let d = SeriesViewer.bb(a, b.coercionMethods);
        c = d.a;
        return b.je.registerColumnDateTime(a, c, b.expectFunctions);
    }
    as() {
        if (this.co) {
            return (TypeRegistrar.create('HorizontalSmartAxisLabelPanel'));
        }
        else {
            return new HorizontalAxisLabelPanel();
        }
    }
    get_az() {
        return 0;
    }
    get az() {
        return this.get_az();
    }
    g6(a) {
        super.g6(a);
        let b = this.a2.ay();
        let c = this.a2.a1();
        let d = this.a2.az();
        let e = this.a2.a0();
        let f = this.a2.e();
        let g = this.a2.f();
        let h = this.a2.g();
        this.hd();
        this.gh(b);
        this.gh(c);
        this.gh(d);
        this.gh(e);
        this.cu.clear();
        this.cv.clear();
        this.jl.clear();
        this.at.ac = this;
        let i = this.bf != null ? this.bf.mq : Rect.empty;
        let j = !i.isEmpty ? this.i0 : Rect.empty;
        this.at.cp = i;
        this.at.co = j;
        if (i.isEmpty || j.isEmpty) {
            this.bo.count = 0;
            this.bn.count = 0;
            this.bm.count = 0;
        }
        if (this.bo.count == 0) {
            this.at.ab.clear();
        }
        if (this.aw != null) {
            this.aw.registerAxis(this);
        }
        this.ls();
    }
    get_b5() {
        return true;
    }
    startCursor() {
    }
    resetCursor() {
    }
    StartTimeCursor() {
        this.startCursor();
    }
    ResetTimeCursor() {
        this.resetCursor();
    }
    getCategorySize(a, b, c) {
        if (this.jx == 0) {
            return 0;
        }
        let d = this.iy(b, c);
        return d.width / (this.jx * a.width);
    }
    getGroupCenter(a, b, c, d) {
        return this.getCategorySize(b, c, d) * 0.5;
    }
    jq(a, b, c) {
        let d = !isNaN_(this.jn) ? MathUtil.b(this.jn, 0, 1) : 0;
        let e = 1 - 0.5 * d;
        let f = this.getCategorySize(a, b, c) * e;
        return f;
    }
    get_cc() {
        return true;
    }
    lq(a, b) {
        return (0);
    }
    preferredCategoryMode(a) {
        return this.b3 ? 0 : 1;
    }
    get isVertical() {
        return this.ce;
    }
    j$c(a, b) {
        return this.dy.apply(this, arguments);
    }
    j$b(a, b) {
        return this.dv.apply(this, arguments);
    }
    j$d(a, b, c, d, e) {
        this.gl.apply(this, arguments);
    }
    j$e(a, b, c, d) {
        this.gm.apply(this, arguments);
    }
    j$f(a, b, c, d) {
        this.gn.apply(this, arguments);
    }
    get j$a() {
        return this.b8;
    }
    get i$a() {
        return this.b5;
    }
}
TimeAxisBase.$t = markType(TimeAxisBase, 'TimeAxisBase', CategoryAxisBase.$, [ISortingAxis_$type, IDateTimeAxis_$type]);
Type.dep(DependencyProperty, PropertyMetadata, TimeAxisBase, 'gz', ['DateTimeMemberPath::ly', [2, null], 'IsDataPreSorted:k1:lz', [0, false], 'MaximumValue::l0', [3, null], 'MinimumValue::l1', [3, null]]);
