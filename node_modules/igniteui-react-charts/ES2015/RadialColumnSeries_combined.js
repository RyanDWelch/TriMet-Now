/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnchoredRadialSeries } from "./AnchoredRadialSeries";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { Type, Point_$type, markType, runOn, fromEnum } from "igniteui-react-core/ES2015/type";
import { Pool$1 } from "igniteui-react-core/ES2015/Pool$1";
import { Path } from "igniteui-react-core/ES2015/Path";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { PathGeometry } from "igniteui-react-core/ES2015/PathGeometry";
import { PathFigure } from "igniteui-react-core/ES2015/PathFigure";
import { PolyLineSegment } from "igniteui-react-core/ES2015/PolyLineSegment";
import { ViewportUtils } from "./ViewportUtils";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { AnchoredRadialSeriesView } from "./AnchoredRadialSeriesView";
/**
 * @hidden
 */
export class RadialColumnSeries extends AnchoredRadialSeries {
    constructor() {
        super();
        this.ab = RadialColumnSeries.$;
    }
    bf() {
        return new RadialColumnSeriesView(this);
    }
    it(a) {
        super.it(a);
        this.op = a;
    }
    ac() {
        super.ac();
        this.jc(false);
    }
    preferredCategoryMode(a) {
        return a != null && a == this.mz ? 2 : 0;
    }
    hv(a, b) {
        super.hv(a, b);
        let c = b;
        if (a) {
            c.cx.count = 0;
        }
    }
    eg() {
        return this.mz.jq(this.bi.bs, this.bi.br, this.getEffectiveViewport1(this.bi));
    }
    nk(a, b) {
        super.nk(a, b);
        let c = a.f;
        let d = b.bs;
        let e = b.br;
        let f = this.getEffectiveViewport1(b);
        let g = this.lp(b);
        let h = this.m1.jf(e, d, f, g);
        let i = b;
        let j = this.m1;
        let k = Math.max(0, 0.5 * j.lh);
        k = Math.max(k, h.minLength * 0.9);
        let l = ViewportUtils.d(k, d, e);
        let m = this.mz.jq(d, e, f);
        let n = Math.max(0.1 * this.m1.li, k);
        let o = this.m2.d(0, n, d, e);
        let p = this.m2.e(0, n, d, e);
        let q = this.m2.d(m, n, d, e);
        let r = this.m2.e(m, n, d, e);
        let s = Math.sqrt((o - q) * (o - q) + (p - r) * (p - r));
        let t = { $type: Point_$type, x: ViewportUtils.c(0.5, d, e), y: ViewportUtils.f(0.5, d, e) };
        for (let u = 0; u < c.count; ++u) {
            let v = Math.min(a.f._inner[u][2], h.maxLength * 1.1);
            let w = this.m2.d(a.f._inner[u][0], v, d, e);
            let x = this.m2.e(a.f._inner[u][0], v, d, e);
            let y = Math.sqrt((w - t.x) * (w - t.x) + (x - t.y) * (x - t.y));
            let z = y;
            let aa = l;
            let ab = a.f._inner[u][0] - (Math.PI / 2);
            let ac = i.cx.item(u);
            let ad = 0 - (s / 2);
            let ae = (s / 2);
            let af = Math.max(aa, z);
            let ag = Math.min(aa, z);
            let ah = Math.cos(ab);
            let ai = Math.sin(ab);
            let aj = { $type: Point_$type, x: t.x + (ad * ah - af * ai), y: t.y + (ad * ai + af * ah) };
            let ak = { $type: Point_$type, x: t.x + (ae * ah - af * ai), y: t.y + (ae * ai + af * ah) };
            let al = { $type: Point_$type, x: t.x + (ae * ah - ag * ai), y: t.y + (ae * ai + ag * ah) };
            let am = { $type: Point_$type, x: t.x + (ad * ah - ag * ai), y: t.y + (ad * ai + ag * ah) };
            let an = new PathGeometry();
            let ao = new PathFigure();
            ao._startPoint = aj;
            ao._isClosed = true;
            let ap = new PolyLineSegment();
            ap._points.add(ak);
            ap._points.add(al);
            ap._points.add(am);
            ao._segments.add(ap);
            an.b.add(ao);
            ac.aj = an;
        }
        i.cx.count = c.count;
        this.op.c2();
    }
}
RadialColumnSeries.$t = markType(RadialColumnSeries, 'RadialColumnSeries', AnchoredRadialSeries.$);
Type.dep(DependencyProperty, PropertyMetadata, RadialColumnSeries, 'raisePropertyChanged', ['RadiusX:oq:ou', [1, 2], 'RadiusY:or:ov', [1, 2]]);
/**
 * @hidden
 */
export class RadialColumnSeriesView extends AnchoredRadialSeriesView {
    constructor(a) {
        super(a);
        this.cw = null;
        this.cx = null;
        this.cy = null;
        this.cw = a;
        this.cx = ((() => {
            let $ret = new Pool$1(Path.$);
            $ret.create = runOn(this, this.c4);
            $ret.activate = runOn(this, this.cz);
            $ret.disactivate = runOn(this, this.c1);
            $ret.destroy = runOn(this, this.c0);
            return $ret;
        })());
    }
    ap() {
        super.ap();
        this.cy = new List$1(Path.$, 0);
        if (!this.n) {
            this.e.eu = 4;
            this.e.bj = 1;
        }
    }
    c4() {
        let a = new Path();
        this.cy.add(a);
        a._visibility = 1;
        return a;
    }
    cz(a) {
        a._visibility = 0;
    }
    c1(a) {
        a._visibility = 1;
    }
    c0(a) {
        this.cy.remove(a);
    }
    c3(a, b, c, d, e, f) {
        this.an();
    }
    bb(a, b) {
        super.bb(a, b);
        let c = a;
        c._fill = this.e.k2;
        c._stroke = this.e.k3;
        c.ac = this.e.ey;
        c.ai = this.e.la;
        c.ad = this.e.lb;
    }
    bc(a, b) {
        super.bc(a, b);
        let c = a;
        let d = this.bm(b);
        c._fill = d;
        c._stroke = d;
        c.ac = this.e.ey + 3;
    }
    a3(a, b) {
        super.a3(a, b);
        if (a.d) {
            for (let c = 0; c < this.cy.count; c++) {
                let d = this.cy._inner[c];
                this.ba(d, c, b);
                a.s(d);
            }
        }
    }
    ai(a) {
        super.ai(a);
        let b = 0;
        for (let c of fromEnum(this.cx.a)) {
            this.e.a2.exportPathData(a, c, "column" + b, ["Main", "Fill"]);
            b++;
        }
    }
    c2() {
        this.an();
    }
}
RadialColumnSeriesView.$t = markType(RadialColumnSeriesView, 'RadialColumnSeriesView', AnchoredRadialSeriesView.$);
