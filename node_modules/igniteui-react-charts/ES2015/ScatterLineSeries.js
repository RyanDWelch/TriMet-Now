/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { ScatterBase } from "./ScatterBase";
import { UnknownValuePlotting_$type } from "igniteui-react-core/ES2015/UnknownValuePlotting";
import { DependencyProperty } from "igniteui-react-core/ES2015/DependencyProperty";
import { Type, Point_$type, typeCast, Number_$type, enumGetBox, markType } from "igniteui-react-core/ES2015/type";
import { OwnedPoint } from "./OwnedPoint";
import { ScatterFrame } from "./ScatterFrame";
import { ScatterLineSeriesView } from "./ScatterLineSeriesView";
import { PathGeometry } from "igniteui-react-core/ES2015/PathGeometry";
import { Rect } from "igniteui-react-core/ES2015/Rect";
import { Clipper } from "igniteui-react-core/ES2015/Clipper";
import { List$1 } from "igniteui-react-core/ES2015/List$1";
import { ScalerParams } from "./ScalerParams";
import { RectUtil } from "igniteui-react-core/ES2015/RectUtil";
import { PolyLineSegment } from "igniteui-react-core/ES2015/PolyLineSegment";
import { PathFigure } from "igniteui-react-core/ES2015/PathFigure";
import { PathFigureCollection } from "igniteui-react-core/ES2015/PathFigureCollection";
import { Flattener } from "igniteui-react-core/ES2015/Flattener";
import { PropertyMetadata } from "igniteui-react-core/ES2015/PropertyMetadata";
import { isNaN_ } from "igniteui-react-core/ES2015/number";
/**
 * @hidden
 */
export class ScatterLineSeries extends ScatterBase {
    constructor() {
        super();
        this.ab = ScatterLineSeries.$;
        this.m8 = new ScatterFrame();
        this.na = new ScatterFrame();
        this.m7 = new ScatterFrame();
        let a = (b, c, d) => {
            let e = this.bz.indexOf(b.a);
            if (e == -1 || e == 0) {
                return b;
            }
            let f = this.bz.item(e - 1);
            let g;
            if (!((() => { let h = c.g.tryGetValue(f, g); g = h.p1; return h.ret; })())) {
                return b;
            }
            return g;
        };
        this.m8.o = a;
        this.na.o = a;
        this.m7.o = a;
    }
    bf() {
        return new ScatterLineSeriesView(this);
    }
    dh(a, b) {
        if (this.l3(a, b)) {
            return true;
        }
        if (this.ox(a, b)) {
            return true;
        }
        return false;
    }
    ox(a, b) {
        let c = this.bi;
        let d = c.da;
        return this.di(a, b, d.aj);
    }
    n1(a, b) {
        super.n1(a, b);
        a.m.clear();
        a.u.clear();
        let c = b.bs;
        let d = b.br;
        let e = this.getEffectiveViewport1(b);
        let f = this.eu * this.eu;
        let g = 0;
        if (this.nc != null) {
            g = this.nc.count;
        }
        if (this.ne != null) {
            g = Math.min(this.ne.count, g);
        }
        let h = new ScalerParams(0, c, d, this.m3.d, e);
        let i = ((() => {
            let $ret = new ScalerParams(0, c, d, this.m3.e, e);
            $ret.b = this.eh();
            return $ret;
        })());
        let j = (k) => this.m3.a.dv(this.nc.item(k), h);
        let k = (l) => this.m3.b.dv(this.ne.item(l), i);
        let l = d.top - 10;
        let m = d.bottom + 10;
        let n = d.left - 10;
        let o = d.right + 10;
        let p = ((() => {
            let $ret = new Clipper(1, n, m, o, l, false);
            $ret.i = a.m;
            return $ret;
        })());
        for (let q = 0; q < g;) {
            let r = q;
            ++q;
            if (g > this.nj) {
                while (q < g && this.oz(j, k, r, q) < f) {
                    ++q;
                }
                p.j(this.o5(j, k, r, q - 1));
            }
            else {
                let s = new OwnedPoint();
                s.c = { $type: Point_$type, x: j(r), y: k(r) };
                s.a = this.bz.item(r);
                if (!a.u.containsKey(s.a)) {
                    a.u.addItem(s.a, s);
                }
            }
        }
        if (g > this.nj) {
            p.i = null;
        }
    }
    o5(a, b, c, d) {
        if (c == d) {
            return { $type: Point_$type, x: a(c), y: b(c) };
        }
        let e = 0;
        let f = 0;
        let g = (d - c + 1);
        for (let h = c; h <= d; ++h) {
            e += a(h);
            f += b(h);
        }
        return { $type: Point_$type, x: e / g, y: f / g };
    }
    oz(a, b, c, d) {
        let e = a(d) - a(c);
        let f = b(d) - b(c);
        return e * e + f * f;
    }
    oa(a, b) {
        b.c0(false);
        super.oa(a, b);
        let c = new Rect(0, b.br.left, b.br.top, b.br.width, b.br.height);
        c = RectUtil.t(c, this.ey, this.ey);
        this.n5(a, new Clipper(0, c, false));
        let d = typeCast(ScatterLineSeriesView.$, b);
        this.o3(d.da, a.m.count, (e) => a.m._inner[e].x, (e) => a.m._inner[e].y, this.ow, this.eu);
    }
    o3(a, b, c, d, e, f) {
        let g = new PathGeometry();
        a.aj = g;
        g.b = new PathFigureCollection();
        let h = new List$1(PolyLineSegment.$, 0);
        let i = 0;
        for (let j = 0; j < b; j++) {
            if (isNaN_(c(j)) || isNaN_(d(j))) {
                let k = j - i;
                if (k > 0) {
                    if (e == 1 || h.count == 0) {
                        let l = new PolyLineSegment();
                        h.add(l);
                    }
                    this.o2(h._inner[h.count - 1]._points, i, j - 1, c, d, f);
                }
                i = j + 1;
            }
        }
        if (e == 1 || h.count == 0) {
            let m = new PolyLineSegment();
            h.add(m);
        }
        this.o2(h._inner[h.count - 1]._points, i, b - 1, c, d, f);
        for (let n = 0; n < h.count; n++) {
            let o = h._inner[n];
            if (o._points.count > 0) {
                let p = ((() => {
                    let $ret = new PathFigure();
                    $ret.startPoint = o._points._inner[0];
                    return $ret;
                })());
                p._segments.add(o);
                g.b.add(p);
            }
        }
    }
    oy(a, b, c, d, e, f) {
        let g = new List$1(Number_$type, 0);
        let h = d;
        let i = e;
        let j = i - h + 1;
        while (j > 0) {
            if (j <= 512) {
                Flattener.c(g, b, c, h, i, f);
                h = i + 1;
            }
            else {
                let k = h + 512 - 1;
                Flattener.c(g, b, c, h, k, f);
                h = k + 1;
            }
            j = i - h + 1;
        }
        return g;
    }
    o2(a, b, c, d, e, f) {
        if (c > -1) {
            let g = this.eu;
            let h = this.oy(new List$1(Number_$type, 0), d, e, b, c, g);
            let i;
            for (let j = 0; j < h.count; j++) {
                i = h.item(j);
                a.add({ $type: Point_$type, x: d(i), y: e(i) });
            }
        }
    }
    iy(a, b, c, d) {
        super.iy(a, b, c, d);
        switch (b) {
            case ScatterLineSeries.$$p[0]:
                this.jc(false);
                this.ij();
                break;
        }
    }
}
ScatterLineSeries.$t = markType(ScatterLineSeries, 'ScatterLineSeries', ScatterBase.$);
Type.dep(DependencyProperty, PropertyMetadata, ScatterLineSeries, 'raisePropertyChanged', ['UnknownValuePlotting:ow:o4', [UnknownValuePlotting_$type, enumGetBox(UnknownValuePlotting_$type, 1)]]);
